{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/assets/img/async-and-await.jpeg","path":"assets/img/async-and-await.jpeg","modified":1,"renderable":0},{"_id":"source/assets/img/es6.jpg","path":"assets/img/es6.jpg","modified":1,"renderable":0},{"_id":"source/mipha/todomvc/index.html","path":"mipha/todomvc/index.html","modified":1,"renderable":0},{"_id":"themes/dzb/source/css/style.scss","path":"css/style.scss","modified":1,"renderable":1},{"_id":"themes/dzb/source/js/post.js","path":"js/post.js","modified":1,"renderable":1},{"_id":"source/assets/img/coffee-apple-iphone-laptop.jpg","path":"assets/img/coffee-apple-iphone-laptop.jpg","modified":1,"renderable":0},{"_id":"source/assets/img/electron.jpg","path":"assets/img/electron.jpg","modified":1,"renderable":0},{"_id":"source/assets/img/event-loop-node.jpeg","path":"assets/img/event-loop-node.jpeg","modified":1,"renderable":0},{"_id":"source/assets/img/gms_h.jpg","path":"assets/img/gms_h.jpg","modified":1,"renderable":0},{"_id":"source/assets/img/javascript-this.jpeg","path":"assets/img/javascript-this.jpeg","modified":1,"renderable":0},{"_id":"source/assets/img/my2018.jpeg","path":"assets/img/my2018.jpeg","modified":1,"renderable":0},{"_id":"source/assets/img/myself-recently.jpeg","path":"assets/img/myself-recently.jpeg","modified":1,"renderable":0},{"_id":"source/assets/img/new-year-new-blog.jpeg","path":"assets/img/new-year-new-blog.jpeg","modified":1,"renderable":0},{"_id":"source/assets/img/sort.jpg","path":"assets/img/sort.jpg","modified":1,"renderable":0},{"_id":"source/assets/img/pexels-photo-486123.jpeg","path":"assets/img/pexels-photo-486123.jpeg","modified":1,"renderable":0},{"_id":"source/assets/img/pexels-photo-92628.jpeg","path":"assets/img/pexels-photo-92628.jpeg","modified":1,"renderable":0},{"_id":"source/assets/img/sublime.jpeg","path":"assets/img/sublime.jpeg","modified":1,"renderable":0},{"_id":"source/assets/img/20180910-164119.jpg","path":"assets/img/20180910-164119.jpg","modified":1,"renderable":0},{"_id":"source/assets/img/birthday.jpg","path":"assets/img/birthday.jpg","modified":1,"renderable":0},{"_id":"source/assets/img/cors/cookie.jpg","path":"assets/img/cors/cookie.jpg","modified":1,"renderable":0},{"_id":"source/assets/img/conan.jpg","path":"assets/img/conan.jpg","modified":1,"renderable":0},{"_id":"source/assets/img/cross-domain.jpg","path":"assets/img/cross-domain.jpg","modified":1,"renderable":0},{"_id":"source/assets/img/husky.jpg","path":"assets/img/husky.jpg","modified":1,"renderable":0},{"_id":"source/assets/img/my-recently-2.jpeg","path":"assets/img/my-recently-2.jpeg","modified":1,"renderable":0},{"_id":"source/assets/img/performance.jpg","path":"assets/img/performance.jpg","modified":1,"renderable":0},{"_id":"source/assets/img/rap-of-china.jpeg","path":"assets/img/rap-of-china.jpeg","modified":1,"renderable":0},{"_id":"source/assets/img/webpack.jpg","path":"assets/img/webpack.jpg","modified":1,"renderable":0},{"_id":"source/assets/img/remember.jpeg","path":"assets/img/remember.jpeg","modified":1,"renderable":0},{"_id":"source/mipha/todomvc/css/base.css","path":"mipha/todomvc/css/base.css","modified":1,"renderable":0},{"_id":"source/assets/img/zelda/3.jpeg","path":"assets/img/zelda/3.jpeg","modified":1,"renderable":0},{"_id":"source/mipha/todomvc/css/index.css","path":"mipha/todomvc/css/index.css","modified":1,"renderable":0},{"_id":"source/assets/img/zelda.jpg","path":"assets/img/zelda.jpg","modified":1,"renderable":0},{"_id":"themes/dzb/source/css/img/avatar_1.jpeg","path":"css/img/avatar_1.jpeg","modified":1,"renderable":1},{"_id":"source/assets/img/ajax.jpg","path":"assets/img/ajax.jpg","modified":1,"renderable":0},{"_id":"source/assets/img/611541861556_.pic_hd.jpg","path":"assets/img/611541861556_.pic_hd.jpg","modified":1,"renderable":0},{"_id":"source/assets/img/20180910-165529.jpg","path":"assets/img/20180910-165529.jpg","modified":1,"renderable":0},{"_id":"source/assets/img/egg-wechat-mp.jpg","path":"assets/img/egg-wechat-mp.jpg","modified":1,"renderable":0},{"_id":"source/assets/img/html2canvas.jpeg","path":"assets/img/html2canvas.jpeg","modified":1,"renderable":0},{"_id":"source/assets/img/mvvm.jpeg","path":"assets/img/mvvm.jpeg","modified":1,"renderable":0},{"_id":"source/assets/img/zelda/1.jpeg","path":"assets/img/zelda/1.jpeg","modified":1,"renderable":0},{"_id":"source/assets/img/zelda/5.jpg","path":"assets/img/zelda/5.jpg","modified":1,"renderable":0},{"_id":"themes/dzb/source/css/fonts/ionicons.woff","path":"css/fonts/ionicons.woff","modified":1,"renderable":1},{"_id":"themes/dzb/source/css/img/notme.jpeg","path":"css/img/notme.jpeg","modified":1,"renderable":1},{"_id":"themes/dzb/source/css/fonts/ionicons.eot","path":"css/fonts/ionicons.eot","modified":1,"renderable":1},{"_id":"themes/dzb/source/css/img/thumb.jpg","path":"css/img/thumb.jpg","modified":1,"renderable":1},{"_id":"themes/dzb/source/css/img/thumb.jpeg","path":"css/img/thumb.jpeg","modified":1,"renderable":1},{"_id":"source/assets/img/cors/header.jpg","path":"assets/img/cors/header.jpg","modified":1,"renderable":0},{"_id":"source/assets/img/pexels-photo-610294.jpeg","path":"assets/img/pexels-photo-610294.jpeg","modified":1,"renderable":0},{"_id":"source/assets/img/zelda/2.jpeg","path":"assets/img/zelda/2.jpeg","modified":1,"renderable":0},{"_id":"themes/dzb/source/css/fonts/ionicons.ttf","path":"css/fonts/ionicons.ttf","modified":1,"renderable":1},{"_id":"themes/dzb/source/css/img/avatar.jpeg","path":"css/img/avatar.jpeg","modified":1,"renderable":1},{"_id":"source/assets/img/gms.jpg","path":"assets/img/gms.jpg","modified":1,"renderable":0},{"_id":"source/assets/img/express-source-code.jpeg","path":"assets/img/express-source-code.jpeg","modified":1,"renderable":0},{"_id":"source/assets/img/zelda/4.jpg","path":"assets/img/zelda/4.jpg","modified":1,"renderable":0},{"_id":"source/assets/img/cookie.jpeg","path":"assets/img/cookie.jpeg","modified":1,"renderable":0},{"_id":"themes/dzb/source/css/fonts/ionicons.svg","path":"css/fonts/ionicons.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"750f551e73f2c2d3beb9d6c3936541ba77ba14fb","modified":1547538420000},{"_id":"source/CNAME","hash":"098423a433393926ba5925c0b0bd59f7eccecacf","modified":1547730011000},{"_id":"themes/dzb/.DS_Store","hash":"38f372afb2b7c0861daab5d3a39c23b6596c756c","modified":1513302296000},{"_id":"themes/dzb/_config.yml","hash":"b5a7b7ce29172e22bc4fec21a0d463e8dc22466c","modified":1547730011000},{"_id":"source/_drafts/aop-in-javascript.md","hash":"c2fe89848214bf14b4a3c4c8c5d09b28f5849cd1","modified":1547730011000},{"_id":"source/_posts/.DS_Store","hash":"33bf57df6819b595503bcdf14bf2be7c3df65846","modified":1546224680000},{"_id":"source/_posts/a-detailed-introduction-to-webpack-2.md","hash":"b8240b176d2e8815c52f073268981a2a3b664ed3","modified":1547730011000},{"_id":"source/_posts/async-and-await.md","hash":"3a2bc8646f05a88ea1f6dbd4b7f3a18c1f8f4e2a","modified":1547730011000},{"_id":"source/_posts/conan.md","hash":"8a2455ad863b921829fabdcbce35e6686e50f908","modified":1547730011000},{"_id":"source/_posts/a-detailed-introduction-to-webpack-1.md","hash":"228938b2f07dc4aed6fe5ba98dec2634c3f1d47a","modified":1547730011000},{"_id":"source/_posts/cors-cookie.md","hash":"127fec4e983cd785ed17f9235325c40cf102f4b9","modified":1547730011000},{"_id":"source/_posts/electron-in-my-view.md","hash":"2d7cb76188922f84053e4efc97b151c608a1b846","modified":1547730011000},{"_id":"source/_posts/cross-domain.md","hash":"d2c301e6cb1757b5b59a54f93b2a756fe8aff840","modified":1547730011000},{"_id":"source/_posts/eggjs-wechat-mp.md","hash":"69d64dfbd58060591e070e8dddbafb2ea639019a","modified":1547730011000},{"_id":"source/_posts/express-source-code-analysis.md","hash":"c247665409be2b90dfe3a67415a21b049ca4b4f8","modified":1547730011000},{"_id":"source/_posts/gms.md","hash":"a3932b6d77a5547e52e7539fad275c10fa417ec9","modified":1547730011000},{"_id":"source/_posts/javaScript-this.md","hash":"f772598437892bf7471be215b8adab6f279d481b","modified":1547730011000},{"_id":"source/_posts/how-to-use-arguments-and-parameters-in-es6.md","hash":"86492eccf5eaea90fdc6d6941f7600418accf221","modified":1547730011000},{"_id":"source/_posts/husky-git-hook.md","hash":"801e1a418630aa1a7af1af0d1657af663127648e","modified":1547730011000},{"_id":"source/_posts/my-birthday.md","hash":"8ce4120e739766ab02c0c8f9dfe24992b95c7d9d","modified":1547730011000},{"_id":"source/_posts/my2018.md","hash":"4cd353e2dfb5a18414f61e8de72fc9e01009f0f5","modified":1547730011000},{"_id":"source/_posts/my-fe-and-me.md","hash":"46abc06a13ee9f1f8fe5f487a262cdc5ccdd0f57","modified":1547730011000},{"_id":"source/_posts/myself-recently.md","hash":"fa330d11bdcfda42ec8fc150735411ccfe3cdc02","modified":1547730011000},{"_id":"source/_posts/new-blog-and-new-year.md","hash":"b947aa7580ed99e2c2ddc59977abbac28ad02a1f","modified":1547730011000},{"_id":"source/_posts/remeber.md","hash":"d9e1fa5e4a6721e50301cac1303e38baee820804","modified":1547730011000},{"_id":"source/_posts/rap-of-china.md","hash":"0db3a3e577f41e36d30128737061c7aacbfdb989","modified":1547730011000},{"_id":"source/_posts/sort-search.md","hash":"aecb1b5b6ee0513e0c63f901f9bb29c5d6a14076","modified":1547730011000},{"_id":"source/_posts/review-xhr.md","hash":"78c6916cf377aa03eb535aac24311507cef0498b","modified":1547730011000},{"_id":"source/about/index.md","hash":"9ffea9266f2c8317238a08316f208a52f0f43304","modified":1547730011000},{"_id":"source/assets/.DS_Store","hash":"6984db8846d4409e4765176e6fdd1109533163cd","modified":1547538425000},{"_id":"source/_posts/the-legend-of-zelda-breath-of-the-wild.md","hash":"a1c5a69936413ee63d5cd7f2318c2cc376e990b4","modified":1547730011000},{"_id":"source/_posts/sublime-bf.md","hash":"fac0d7ff843336a788d72619db9635ea6edb8437","modified":1547730011000},{"_id":"source/_posts/use-clustery-render-large-list.md","hash":"e2921140aacdfe320d428b348137a2a47a89f6bc","modified":1547730011000},{"_id":"source/mipha/.DS_Store","hash":"d6cde5937d16fa0743f205a6ff00b6d4e681ef4d","modified":1512627816000},{"_id":"themes/dzb/languages/es.yml","hash":"d7432219be5bee4cb569331378ade61b749688e0","modified":1547730011000},{"_id":"themes/dzb/languages/ja.yml","hash":"ff972961e5f468a695d80d21b62c3e9032cdf561","modified":1547730011000},{"_id":"themes/dzb/languages/en.yml","hash":"ade241498b85503a8953a1deca963222f47067a7","modified":1547730011000},{"_id":"themes/dzb/languages/fr.yml","hash":"cb3e597cbec7e8f458858c457bafd1f3a225083d","modified":1547730011000},{"_id":"themes/dzb/languages/ko.yml","hash":"7c4ad4577dc0577ad2ca1c0410507f5e5fadf530","modified":1547730011000},{"_id":"themes/dzb/languages/tr.yml","hash":"8b7eb6aec264db50dbabea89f680acca256f4cd1","modified":1547730011000},{"_id":"themes/dzb/layout/_archive.ejs","hash":"10d87c585e8f7c57592093e1cdb4dfeea7d64d25","modified":1547730011000},{"_id":"themes/dzb/languages/id.yml","hash":"70ec9ab2ac04cf882e81377ca5ad15bf8adceca8","modified":1547730011000},{"_id":"themes/dzb/languages/ru.yml","hash":"d1aab2b0c939d0c6020f881d664b660a01ee7327","modified":1547730011000},{"_id":"themes/dzb/languages/pt-BR.yml","hash":"3c5d5293575593705b9a2dfa9d97b017eb4bc8c3","modified":1547730011000},{"_id":"themes/dzb/languages/zh-TW.yml","hash":"d8d96a0a17c20af11919ce036e87379a6b163db9","modified":1547730011000},{"_id":"themes/dzb/languages/zh-CN.yml","hash":"3dc8ec524805afd090438be717908750da439204","modified":1547730011000},{"_id":"themes/dzb/layout/layout.ejs","hash":"6410d65e208842301ad7fd18816d8d5dbe67dcc4","modified":1547730011000},{"_id":"themes/dzb/layout/page.ejs","hash":"f520c5fcd3467d62522945bbe896431eb6463c18","modified":1547730011000},{"_id":"themes/dzb/layout/index.ejs","hash":"d7bc92dfaee6939c2f4db6a033e2d0f5e96dc24c","modified":1547730011000},{"_id":"themes/dzb/layout/post.ejs","hash":"9e6afb6c9b9269e56b93298bf42b87059699e733","modified":1547730011000},{"_id":"themes/dzb/layout/tag.ejs","hash":"904c247ef5b2887cd32a61d28c23a99c3c9a3c22","modified":1547730011000},{"_id":"themes/dzb/source/.DS_Store","hash":"f6176d956b5982cd2bb5eb1e504b17a42644759a","modified":1513302296000},{"_id":"themes/dzb/layout/common/footer.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1547730011000},{"_id":"themes/dzb/layout/common/comment.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1547730011000},{"_id":"source/assets/img/.DS_Store","hash":"2ad607791162a9c9b40d236d30f00a9a7ac0b62b","modified":1538992852000},{"_id":"source/assets/img/async-and-await.jpeg","hash":"c0459d79e2f30f327d8351fbedf21a0e8982bbd6","modified":1547730011000},{"_id":"source/assets/img/es6.jpg","hash":"8ce63ca3030892593f6c0b6b8bd049a3bdf1c181","modified":1547730011000},{"_id":"themes/dzb/layout/common/side.ejs","hash":"e23ba42c427bd027cd5a99e33813ad7a1f82f25e","modified":1547730011000},{"_id":"themes/dzb/layout/common/head.ejs","hash":"a11d951db5fad99547e3255153795c136ffc8382","modified":1547730011000},{"_id":"source/mipha/todomvc/index.html","hash":"767c42a04303b6c0a8d3c8369c9a2a5e4fc10ab9","modified":1547730011000},{"_id":"themes/dzb/layout/common/posts.ejs","hash":"4d97b880448676831974002862ebeaaccd94144b","modified":1547730011000},{"_id":"themes/dzb/source/css/.DS_Store","hash":"596c318eaa1cce829baa5828a2ea68f84b0c4080","modified":1513302301000},{"_id":"themes/dzb/source/css/style.scss","hash":"7aebbfb803448b5c76390fba1dce33809454c8fa","modified":1547730011000},{"_id":"themes/dzb/source/js/post.js","hash":"c61e78f6abef40337054f45b06567c410a7690ae","modified":1547730011000},{"_id":"source/assets/img/coffee-apple-iphone-laptop.jpg","hash":"4572cc5ae0422165a811a63696b2e1f46c5401d2","modified":1547730011000},{"_id":"source/assets/img/electron.jpg","hash":"b4aa1bc9e99fc85545d2d675a719c8d182469c88","modified":1547730011000},{"_id":"source/assets/img/event-loop-node.jpeg","hash":"6bebc397ab8914924dc5810d597c387383535410","modified":1547730011000},{"_id":"source/assets/img/gms_h.jpg","hash":"23d4df06b0297e731ecc8acdcfd8422655c62e13","modified":1547730011000},{"_id":"source/assets/img/javascript-this.jpeg","hash":"157ccc8282bcb985b3ec2c4da9de15fb85d9cd39","modified":1547730011000},{"_id":"source/assets/img/my2018.jpeg","hash":"60f4a6dcd977cf97ea51e6aba22142d1a7c17b82","modified":1547730011000},{"_id":"source/assets/img/myself-recently.jpeg","hash":"242d7c3add158b7b6dabff8d6c8e19441f527cd8","modified":1547730011000},{"_id":"source/assets/img/new-year-new-blog.jpeg","hash":"ba092999672175a8d8514b443142475b7455e472","modified":1547730011000},{"_id":"source/assets/img/sort.jpg","hash":"bfba9a256fd0f8356d91cacbc40fb441def9db39","modified":1547730011000},{"_id":"source/assets/img/pexels-photo-486123.jpeg","hash":"bcd00a22c1ef3570a77c344364f6673375e5df41","modified":1547730011000},{"_id":"source/assets/img/pexels-photo-92628.jpeg","hash":"81a85b9803268e5ca44b00754801e97344474da3","modified":1547730011000},{"_id":"source/assets/img/sublime.jpeg","hash":"f473b47eb588ef3fdcf66605120625c554e3f16b","modified":1547730011000},{"_id":"source/assets/img/20180910-164119.jpg","hash":"4eb51c6098bc04c7c55cd5f7723ea2d23613ab7a","modified":1547730011000},{"_id":"source/assets/img/birthday.jpg","hash":"880a06823f7f91f88c9e114a4f38bf78add162aa","modified":1547730011000},{"_id":"source/assets/img/cors/cookie.jpg","hash":"95d5d9ca1f3f5b19cf3a0911a957113c9da7c6ef","modified":1547730011000},{"_id":"source/assets/img/conan.jpg","hash":"da9aa31816f59268989a9f1c36236dd38bf4a3c6","modified":1547730011000},{"_id":"source/assets/img/cross-domain.jpg","hash":"5a3b2a273509088769346e444c348169730c906d","modified":1547730011000},{"_id":"source/assets/img/husky.jpg","hash":"f0ece7c88a71a025d0bd702d091c1ea34760b79b","modified":1547730011000},{"_id":"source/assets/img/my-recently-2.jpeg","hash":"d16d77ea70d292b5ad6ae215b9ab66224ccc82b3","modified":1547730011000},{"_id":"source/assets/img/performance.jpg","hash":"6e9b3843451899c867730fe5ff552a760ed83a17","modified":1547730011000},{"_id":"source/assets/img/rap-of-china.jpeg","hash":"310322e5510f8fe3e090ab3db0dd5d82c8822e42","modified":1547730011000},{"_id":"source/assets/img/zelda/.DS_Store","hash":"8e812fc122e14ccb113683e7b6dbc0b815458f08","modified":1513926236000},{"_id":"source/assets/img/webpack.jpg","hash":"9c13c1ca12cbdde327ea25388a1f7df74b4df268","modified":1547730011000},{"_id":"source/assets/img/remember.jpeg","hash":"671c174f2b797fadd5c1a57f6a2097056b2cebd3","modified":1547730011000},{"_id":"source/mipha/todomvc/css/base.css","hash":"29af76d1e261b926a9442d5392ca14c7caf4636a","modified":1547730011000},{"_id":"source/assets/img/zelda/3.jpeg","hash":"f07c968da827f1b729a27e14e19a83b23ec3b53b","modified":1547730011000},{"_id":"source/mipha/todomvc/css/index.css","hash":"489806ecd57cc1b41726c0d14ad6c6026822b357","modified":1547730011000},{"_id":"source/assets/img/zelda.jpg","hash":"36fea23177c317aa63b0fbb9a5bd26674a492c6f","modified":1547730011000},{"_id":"themes/dzb/source/css/img/.DS_Store","hash":"63edfb4c15a33699e6436f81488d8b845f26c8d2","modified":1504249423000},{"_id":"themes/dzb/source/css/img/avatar_1.jpeg","hash":"4ae6411667057ba0f29b1da98d8513b01d0d3371","modified":1547730011000},{"_id":"themes/dzb/source/css/scss/.DS_Store","hash":"f245896f45ab4de54f1df07046343807e6d39c1f","modified":1504159784000},{"_id":"themes/dzb/source/css/scss/_global.scss","hash":"d03d59a52d6268d80c699d06098237d1b4658840","modified":1547730011000},{"_id":"themes/dzb/source/css/scss/_highlight.scss","hash":"b2a36416754f9f03bd6e50d2bfa8f0e5b9a13b96","modified":1547730011000},{"_id":"themes/dzb/source/css/scss/_reset.scss","hash":"9d6b6053a550746cc669043a71db509d54ec99b5","modified":1547730011000},{"_id":"themes/dzb/source/css/scss/_side.scss","hash":"bcea1711cf1be16d568d669aecb21c1f7dcf2d36","modified":1547730011000},{"_id":"themes/dzb/source/css/scss/_timeline.scss","hash":"de10da76fc20c7af4993fa783584c2a4c77ac298","modified":1547730011000},{"_id":"themes/dzb/source/css/scss/_variables.scss","hash":"4173ebb365450ca31e06f8818fe7ee289f3e7891","modified":1547730011000},{"_id":"themes/dzb/source/css/scss/_index.scss","hash":"5fbbac3cc74de66179f2cce5c60f3b925508a40e","modified":1547730011000},{"_id":"themes/dzb/source/css/scss/_ionicons.scss","hash":"af010623e88121b7c1c396fbea4033d9bd767f09","modified":1547730011000},{"_id":"source/assets/img/ajax.jpg","hash":"ff64ccbb5397ea3e73eb0e892343c12802923f4e","modified":1547730011000},{"_id":"source/assets/img/611541861556_.pic_hd.jpg","hash":"bc8112c89002365e6f19db31981b0427c455ba85","modified":1547730011000},{"_id":"source/assets/img/20180910-165529.jpg","hash":"995fffa01c777c8fc7f164cef44b2d9a1ddf0641","modified":1547730011000},{"_id":"source/assets/img/egg-wechat-mp.jpg","hash":"d9d147d58cb75b79fd88c6503e7279a3a77418ac","modified":1547730011000},{"_id":"source/assets/img/html2canvas.jpeg","hash":"d8ac90e5cacb97a581fcde653be902e7497dfe7d","modified":1547730011000},{"_id":"source/assets/img/mvvm.jpeg","hash":"947eed4601d3730bd44db1ec60d7aee9d0d4ae62","modified":1547730011000},{"_id":"source/assets/img/zelda/1.jpeg","hash":"ff015786d1e232624ead2fe0b709c2897f02fa40","modified":1547730011000},{"_id":"source/assets/img/zelda/5.jpg","hash":"60fbcf9006a0d788965c5a42eba8da028252547d","modified":1547730011000},{"_id":"themes/dzb/source/css/fonts/ionicons.woff","hash":"e46819e863a46751d622c1190c4e8a83ebc20612","modified":1547730011000},{"_id":"themes/dzb/source/css/img/notme.jpeg","hash":"3d10e504afb9fa8c502b9039d47c188964df6601","modified":1547730011000},{"_id":"themes/dzb/source/css/fonts/ionicons.eot","hash":"61532e89e212f8dd16ba31f3ebcf35c0a7334035","modified":1547730011000},{"_id":"themes/dzb/source/css/img/thumb.jpg","hash":"fd3cc8a8ac6076a08f033394384ab6b3420ee146","modified":1547730011000},{"_id":"themes/dzb/source/css/img/thumb.jpeg","hash":"e13b8b24e827dc4ea1a15e0c55862b5eae2372f2","modified":1547730011000},{"_id":"source/assets/img/cors/header.jpg","hash":"f2d09411bbd45966e177b76de2575e62202d9579","modified":1547730011000},{"_id":"source/assets/img/pexels-photo-610294.jpeg","hash":"e52d772d1791ad8ab6c1fe290d90352a21ea2396","modified":1547730011000},{"_id":"source/assets/img/zelda/2.jpeg","hash":"6f0de2e4c64d537b71fd1dd1d5db143e6874728b","modified":1547730011000},{"_id":"themes/dzb/source/css/fonts/ionicons.ttf","hash":"1b0a0de084905946a20300ca8c354865dec46764","modified":1547730011000},{"_id":"themes/dzb/source/css/img/avatar.jpeg","hash":"207a900c357061fa3276ac6675dc87b87bc39315","modified":1547730011000},{"_id":"source/assets/img/gms.jpg","hash":"0655bae28df702fcc2a5f404e2c3586390ee0f90","modified":1547730011000},{"_id":"source/assets/img/express-source-code.jpeg","hash":"618b2146e1fceb66eb10eb44033d7cac84973fa9","modified":1547730011000},{"_id":"source/assets/img/zelda/4.jpg","hash":"4230d81eb433ec0c434917c23772e6431b0674a6","modified":1547730011000},{"_id":"source/assets/img/cookie.jpeg","hash":"da4bd698461f6176421e2e9557de4af1c6b7940a","modified":1547730011000},{"_id":"themes/dzb/source/css/fonts/ionicons.svg","hash":"3f1ca28fcb042d2bcc6ee6a4e3dd817e5132eeea","modified":1547730011000},{"_id":"public/atom.xml","hash":"f88d21b07392614d5939a28aa4b467c1c6f45cc5","modified":1547777298939},{"_id":"public/about/index.html","hash":"c4128608bfe7002b6a936428bf8460843c4f17a6","modified":1547777299095},{"_id":"public/2019/01/17/conan/index.html","hash":"0c837f6917a4a4e7a4ce01efde537e37b0526251","modified":1547777299095},{"_id":"public/2019/01/17/cors-cookie/index.html","hash":"7e08029b1271498f5cbbbbaf075ac6373c57b35c","modified":1547777299095},{"_id":"public/2019/01/17/cross-domain/index.html","hash":"672fdffe2650222ec47041d7d8afeba5545704ff","modified":1547777299095},{"_id":"public/2019/01/17/eggjs-wechat-mp/index.html","hash":"db71fd1a536e55e2a216720a8d2531d092d27f70","modified":1547777299095},{"_id":"public/2019/01/17/gms/index.html","hash":"82c3ff207028da0ee05aa50b4f7d1c2531099778","modified":1547777299095},{"_id":"public/2019/01/17/husky-git-hook/index.html","hash":"f03d42d9319594ffb31714902f17fbf5e6886724","modified":1547777299095},{"_id":"public/2019/01/17/my-birthday/index.html","hash":"ccc7f31b24b23faca5f7004f2f6de3880c4ddcfd","modified":1547777299095},{"_id":"public/2019/01/17/my2018/index.html","hash":"eb4c10f8a096352dd6c5d9206be5e0b3aaf12664","modified":1547777299095},{"_id":"public/2019/01/17/my-fe-and-me/index.html","hash":"0dc8accb71c04ae87e07235aa7cb88cd48da7e06","modified":1547777299095},{"_id":"public/2019/01/17/myself-recently/index.html","hash":"f4b88d23c225a33e31879d6c62e9e055eb43285c","modified":1547777299095},{"_id":"public/2019/01/17/sort-search/index.html","hash":"1c4e6d06130825b07456a239a5b1eba8ff6d4eb9","modified":1547777299096},{"_id":"public/2019/01/17/sublime-bf/index.html","hash":"42c65b2acca26b183528ef00d9b54c669048797c","modified":1547777299096},{"_id":"public/2019/01/17/the-legend-of-zelda-breath-of-the-wild/index.html","hash":"a818b6255565a0f7d826bd636378d8066e187c8a","modified":1547777299096},{"_id":"public/2019/01/17/use-clustery-render-large-list/index.html","hash":"e2c731d783c929033ed36a100eaf22733b8c8930","modified":1547777299096},{"_id":"public/2017/09/21/javaScript-this/index.html","hash":"920072bddc8e28c31aa12b28f33a0ed4ada80afa","modified":1547777299096},{"_id":"public/2017/09/14/async-and-await/index.html","hash":"63affee00a44761b592b08bef3355090ddb4fa16","modified":1547777299096},{"_id":"public/2017/09/13/express-source-code-analysis/index.html","hash":"99f056472bcd15af41d9d9c61d045c676bb41843","modified":1547777299096},{"_id":"public/2017/09/10/rap-of-china/index.html","hash":"7983515fd86ce04f8d755f6eee0db6db41db7f30","modified":1547777299096},{"_id":"public/2017/06/16/remeber/index.html","hash":"04b908eff35d6228648147f675e958a110d783de","modified":1547777299096},{"_id":"public/2017/06/06/review-xhr/index.html","hash":"c09ec34697a09646e0e512cae0861464fb84e9d4","modified":1547777299096},{"_id":"public/2017/02/26/new-blog-and-new-year/index.html","hash":"54db79f558a12b1a613428502e171174cade6a93","modified":1547777299096},{"_id":"public/archives/index.html","hash":"5b609a3a6cacb5614d2b12bd4624c0a265b0441d","modified":1547777299096},{"_id":"public/archives/page/2/index.html","hash":"91a80d441108ec6cc40fc69105dda35fe052f519","modified":1547777299096},{"_id":"public/archives/page/3/index.html","hash":"1d6099f6e3f1d66ea2722eead0706b594443c291","modified":1547777299096},{"_id":"public/archives/2017/index.html","hash":"9092e303f3fb06d114ef11135ffeff5579ec15ab","modified":1547777299096},{"_id":"public/archives/2017/02/index.html","hash":"3b7b8efd964aaee5526659f05f2536f701b4bb04","modified":1547777299096},{"_id":"public/archives/2017/06/index.html","hash":"4b7fbfcc01159e28adf84d330344526fe8ca89ba","modified":1547777299096},{"_id":"public/archives/2017/09/index.html","hash":"556afb27c474324974636bf158f196d724081b16","modified":1547777299096},{"_id":"public/archives/2019/index.html","hash":"c12d03dff7f9da3548b72932d33599050b036679","modified":1547777299096},{"_id":"public/archives/2019/page/2/index.html","hash":"c2e8f3f44ef1ff1df8d3563ee9c872121a950561","modified":1547777299096},{"_id":"public/archives/2019/01/index.html","hash":"0fb2c652093a748afbc71124d3df9a815a1873f4","modified":1547777299096},{"_id":"public/archives/2019/01/page/2/index.html","hash":"9b228a8a7ff39eda65a2105440619951a3380867","modified":1547777299097},{"_id":"public/index.html","hash":"8ad950e88fdb276c138f6b79dc1b1997c2802e99","modified":1547777299097},{"_id":"public/page/2/index.html","hash":"23b52313197059f51687e737e1ad4692404452f4","modified":1547777299097},{"_id":"public/page/3/index.html","hash":"61060c1faf70bd435b7304e6ff7f2358f61a6904","modified":1547777299097},{"_id":"public/tags/javascript/index.html","hash":"bb65ff721f4f2a1a697babc758990f50fa88a180","modified":1547777299097},{"_id":"public/tags/ES6/index.html","hash":"30644e8b4313bb1f1ef56b04b29da887adc649b7","modified":1547777299097},{"_id":"public/tags/life/index.html","hash":"5731d7de018501b4c522ab7b3c829c80fa6e6c50","modified":1547777299097},{"_id":"public/tags/JavaScript/index.html","hash":"7031dcf71b281d93e9de29303c704af3af1d4088","modified":1547777299097},{"_id":"public/tags/XHR/index.html","hash":"04f34e021e5f8a731763f3b90cd929982632903a","modified":1547777299097},{"_id":"public/tags/nodejs/index.html","hash":"1654811dde3f5c62be029877ad46a5a5faaa1f4f","modified":1547777299097},{"_id":"public/tags/gulp/index.html","hash":"db56e33c8d16ae93fa9ea12a64d9c474734ef726","modified":1547777299097},{"_id":"public/tags/Git/index.html","hash":"72966a5ab31b45d85f050d147eec51976679d31d","modified":1547777299097},{"_id":"public/tags/webpack/index.html","hash":"36962e1ed61b5b011ea9587c606f2cf5b9d14c97","modified":1547777299097},{"_id":"public/tags/electron/index.html","hash":"a59f2cde657aa1d8b4142d6e44ba3ca1f3069931","modified":1547777299097},{"_id":"public/tags/algorithm/index.html","hash":"093463707e5597e9473e75fa6ce2f1de46d5e236","modified":1547777299097},{"_id":"public/tags/xhr/index.html","hash":"11b039fa59c654cd73639d70e1fca136c42354ab","modified":1547777299097},{"_id":"public/tags/editor/index.html","hash":"ce26adabab72f934d7c10d9265b6fe8cec8b91d0","modified":1547777299097},{"_id":"public/tags/game/index.html","hash":"a2e7a1d90e389b0d2dcc842fbc5d21300f86ee55","modified":1547777299097},{"_id":"public/tags/performance/index.html","hash":"05f6785478d71def165fc192574de9a3ee910cd2","modified":1547777299097},{"_id":"public/2019/01/17/electron-in-my-view/index.html","hash":"f7fafaf4bc8ba293f802cce8631c8dcb6375ccce","modified":1547777299097},{"_id":"public/2019/01/17/a-detailed-introduction-to-webpack-2/index.html","hash":"85c6f9850f7213269f3ea6b883102e87fbb046b8","modified":1547777299098},{"_id":"public/2019/01/17/a-detailed-introduction-to-webpack-1/index.html","hash":"7e209cad97aa2f38878dfb183f904e8733e62b62","modified":1547777299098},{"_id":"public/2019/01/17/how-to-use-arguments-and-parameters-in-es6/index.html","hash":"603729249256d7e9d1a275a1690a727bb522686c","modified":1547777299098},{"_id":"public/CNAME","hash":"098423a433393926ba5925c0b0bd59f7eccecacf","modified":1547777299106},{"_id":"public/mipha/todomvc/index.html","hash":"767c42a04303b6c0a8d3c8369c9a2a5e4fc10ab9","modified":1547777299106},{"_id":"public/assets/img/es6.jpg","hash":"8ce63ca3030892593f6c0b6b8bd049a3bdf1c181","modified":1547777299106},{"_id":"public/assets/img/cors/cookie.jpg","hash":"95d5d9ca1f3f5b19cf3a0911a957113c9da7c6ef","modified":1547777299106},{"_id":"public/mipha/todomvc/css/base.css","hash":"29af76d1e261b926a9442d5392ca14c7caf4636a","modified":1547777299106},{"_id":"public/assets/img/zelda/3.jpeg","hash":"f07c968da827f1b729a27e14e19a83b23ec3b53b","modified":1547777299106},{"_id":"public/mipha/todomvc/css/index.css","hash":"489806ecd57cc1b41726c0d14ad6c6026822b357","modified":1547777299106},{"_id":"public/css/img/avatar_1.jpeg","hash":"4ae6411667057ba0f29b1da98d8513b01d0d3371","modified":1547777299106},{"_id":"public/css/img/notme.jpeg","hash":"3d10e504afb9fa8c502b9039d47c188964df6601","modified":1547777299106},{"_id":"public/assets/img/async-and-await.jpeg","hash":"c0459d79e2f30f327d8351fbedf21a0e8982bbd6","modified":1547777299161},{"_id":"public/assets/img/coffee-apple-iphone-laptop.jpg","hash":"4572cc5ae0422165a811a63696b2e1f46c5401d2","modified":1547777299161},{"_id":"public/assets/img/electron.jpg","hash":"b4aa1bc9e99fc85545d2d675a719c8d182469c88","modified":1547777299161},{"_id":"public/assets/img/event-loop-node.jpeg","hash":"6bebc397ab8914924dc5810d597c387383535410","modified":1547777299161},{"_id":"public/assets/img/gms_h.jpg","hash":"23d4df06b0297e731ecc8acdcfd8422655c62e13","modified":1547777299161},{"_id":"public/assets/img/my2018.jpeg","hash":"60f4a6dcd977cf97ea51e6aba22142d1a7c17b82","modified":1547777299161},{"_id":"public/assets/img/myself-recently.jpeg","hash":"242d7c3add158b7b6dabff8d6c8e19441f527cd8","modified":1547777299162},{"_id":"public/assets/img/pexels-photo-92628.jpeg","hash":"81a85b9803268e5ca44b00754801e97344474da3","modified":1547777299162},{"_id":"public/assets/img/new-year-new-blog.jpeg","hash":"ba092999672175a8d8514b443142475b7455e472","modified":1547777299162},{"_id":"public/assets/img/sort.jpg","hash":"bfba9a256fd0f8356d91cacbc40fb441def9db39","modified":1547777299162},{"_id":"public/assets/img/pexels-photo-486123.jpeg","hash":"bcd00a22c1ef3570a77c344364f6673375e5df41","modified":1547777299162},{"_id":"public/assets/img/performance.jpg","hash":"6e9b3843451899c867730fe5ff552a760ed83a17","modified":1547777299162},{"_id":"public/assets/img/zelda/1.jpeg","hash":"ff015786d1e232624ead2fe0b709c2897f02fa40","modified":1547777299162},{"_id":"public/assets/img/zelda/5.jpg","hash":"60fbcf9006a0d788965c5a42eba8da028252547d","modified":1547777299162},{"_id":"public/css/fonts/ionicons.woff","hash":"e46819e863a46751d622c1190c4e8a83ebc20612","modified":1547777299162},{"_id":"public/css/fonts/ionicons.eot","hash":"61532e89e212f8dd16ba31f3ebcf35c0a7334035","modified":1547777299163},{"_id":"public/css/img/thumb.jpg","hash":"fd3cc8a8ac6076a08f033394384ab6b3420ee146","modified":1547777299163},{"_id":"public/css/img/thumb.jpeg","hash":"e13b8b24e827dc4ea1a15e0c55862b5eae2372f2","modified":1547777299163},{"_id":"public/assets/img/cors/header.jpg","hash":"f2d09411bbd45966e177b76de2575e62202d9579","modified":1547777299163},{"_id":"public/assets/img/zelda/2.jpeg","hash":"6f0de2e4c64d537b71fd1dd1d5db143e6874728b","modified":1547777299163},{"_id":"public/js/post.js","hash":"c61e78f6abef40337054f45b06567c410a7690ae","modified":1547777299167},{"_id":"public/css/style.css","hash":"5af2ce7b9917cd0b104f435a493d739c3ea84cd2","modified":1547777299167},{"_id":"public/assets/img/javascript-this.jpeg","hash":"157ccc8282bcb985b3ec2c4da9de15fb85d9cd39","modified":1547777299167},{"_id":"public/assets/img/sublime.jpeg","hash":"f473b47eb588ef3fdcf66605120625c554e3f16b","modified":1547777299168},{"_id":"public/assets/img/conan.jpg","hash":"da9aa31816f59268989a9f1c36236dd38bf4a3c6","modified":1547777299168},{"_id":"public/assets/img/cross-domain.jpg","hash":"5a3b2a273509088769346e444c348169730c906d","modified":1547777299168},{"_id":"public/assets/img/husky.jpg","hash":"f0ece7c88a71a025d0bd702d091c1ea34760b79b","modified":1547777299168},{"_id":"public/assets/img/my-recently-2.jpeg","hash":"d16d77ea70d292b5ad6ae215b9ab66224ccc82b3","modified":1547777299168},{"_id":"public/assets/img/rap-of-china.jpeg","hash":"310322e5510f8fe3e090ab3db0dd5d82c8822e42","modified":1547777299168},{"_id":"public/assets/img/webpack.jpg","hash":"9c13c1ca12cbdde327ea25388a1f7df74b4df268","modified":1547777299168},{"_id":"public/assets/img/remember.jpeg","hash":"671c174f2b797fadd5c1a57f6a2097056b2cebd3","modified":1547777299168},{"_id":"public/assets/img/zelda.jpg","hash":"36fea23177c317aa63b0fbb9a5bd26674a492c6f","modified":1547777299168},{"_id":"public/assets/img/html2canvas.jpeg","hash":"d8ac90e5cacb97a581fcde653be902e7497dfe7d","modified":1547777299168},{"_id":"public/assets/img/mvvm.jpeg","hash":"947eed4601d3730bd44db1ec60d7aee9d0d4ae62","modified":1547777299168},{"_id":"public/css/fonts/ionicons.ttf","hash":"1b0a0de084905946a20300ca8c354865dec46764","modified":1547777299168},{"_id":"public/assets/img/egg-wechat-mp.jpg","hash":"d9d147d58cb75b79fd88c6503e7279a3a77418ac","modified":1547777299173},{"_id":"public/css/img/avatar.jpeg","hash":"207a900c357061fa3276ac6675dc87b87bc39315","modified":1547777299173},{"_id":"public/assets/img/gms.jpg","hash":"0655bae28df702fcc2a5f404e2c3586390ee0f90","modified":1547777299174},{"_id":"public/assets/img/ajax.jpg","hash":"ff64ccbb5397ea3e73eb0e892343c12802923f4e","modified":1547777299181},{"_id":"public/assets/img/20180910-165529.jpg","hash":"995fffa01c777c8fc7f164cef44b2d9a1ddf0641","modified":1547777299181},{"_id":"public/assets/img/birthday.jpg","hash":"880a06823f7f91f88c9e114a4f38bf78add162aa","modified":1547777299188},{"_id":"public/assets/img/20180910-164119.jpg","hash":"4eb51c6098bc04c7c55cd5f7723ea2d23613ab7a","modified":1547777299188},{"_id":"public/assets/img/611541861556_.pic_hd.jpg","hash":"bc8112c89002365e6f19db31981b0427c455ba85","modified":1547777299189},{"_id":"public/assets/img/pexels-photo-610294.jpeg","hash":"e52d772d1791ad8ab6c1fe290d90352a21ea2396","modified":1547777299196},{"_id":"public/assets/img/cookie.jpeg","hash":"da4bd698461f6176421e2e9557de4af1c6b7940a","modified":1547777299196},{"_id":"public/css/fonts/ionicons.svg","hash":"3f1ca28fcb042d2bcc6ee6a4e3dd817e5132eeea","modified":1547777299197},{"_id":"public/assets/img/express-source-code.jpeg","hash":"618b2146e1fceb66eb10eb44033d7cac84973fa9","modified":1547777299202},{"_id":"public/assets/img/zelda/4.jpg","hash":"4230d81eb433ec0c434917c23772e6431b0674a6","modified":1547777299202}],"Category":[],"Data":[],"Page":[{"title":"about","date":"2017-09-01T06:49:10.000Z","_content":"\nDarkZone，现居杭州，前端工程师。\n\n三无青年。\n\n宅。\n\n\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2017-09-01 14:49:10\n---\n\nDarkZone，现居杭州，前端工程师。\n\n三无青年。\n\n宅。\n\n\n","updated":"2019-01-17T13:00:11.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjr1en2nu000vha9snu82mj7k","content":"<p>DarkZone，现居杭州，前端工程师。</p>\n<p>三无青年。</p>\n<p>宅。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>DarkZone，现居杭州，前端工程师。</p>\n<p>三无青年。</p>\n<p>宅。</p>\n"}],"Post":[{"layout":"post","title":"JavaScript 中的 AOP","banner":"assets/img/webpack.jpg","_content":"\n最早接触 AOP 这个概念是因为使用 [NEJ](https://github.com/genify/nej) 这个框架。在[平台适配系统](https://github.com/genify/nej/blob/master/doc/PLATFORM.md)这篇文档中详细讲解了 NEJ 是如何使用 AOP 思想来做平台适配工作的。\n\n## 什么是 AOP\n\nAOP 是 Aspect Oriented Programming（面向切面编程）的缩写，其核心思想是将横切关注点从主关注点中分离出来，因此特定领域的问题代码可以从标准业务逻辑中分离出来，从而使得主业务逻辑和领域性业务逻辑之间不会存在任何耦合性。\n\n## NEJ 中的 AOP\n\n上面说到，NEJ 是基于 AOP 的思想来做平台适配的。在做平台适配的时候，我们经常会写出这样代码：\n\n```js\nfunction doSomething(){\n    if(isTrident){\n        // TODO trident implement\n    }else if(isWebkit){\n        // TODO webkit implement\n    }else if(isGecko){\n        // TODO gecko implement\n    }else if(isPresto){\n        // TODO presto implement\n    }else{\n        // TODO w3c implement\n    }\n}\n```\n\n上面的代码对主逻辑有极强的侵入性，而且在日后修改的时候总是会修改到主逻辑，变的难以维护。\n\n```js\nfunction doSomething(){\n    // TODO w3c implement\n}\n\n// trident implement\ndoSomething = doSomething._$aop(\n    function(_event){\n        // TODO trident implement\n    }\n);\n// … …\n\ndoSomething(1,2,3);\n```\n\n我们来看下 NEJ `_$aop` 的实现：\n\n```js\nvar _extpro = Function.prototype;\n    /**\n     * AOP增强操作，增强操作接受一个输入参数包含以下信息\n     *\n     *  | 参数名称 | 参数类型  | 参数描述 |\n     *  | :--     | :--      | :-- |\n     *  | args    | Array    | 函数调用时实际输入参数，各增强操作中可以改变值后将影响至后续的操作 |\n     *  | value   | Variable | 输出结果 |\n     *  | stopped | Boolean  | 是否结束操作，终止后续操作 |\n     *\n     * @method external:Function#_$aop\n     * @param  {Function} arg0 - 前置操作，接受一个输入参数，见描述信息\n     * @param  {Function} arg1 - 后置操作，接受一个输入参数，见描述信息\n     * @return {Function}        增强后操作函数\n     */\n    _extpro._$aop = function(_before,_after){\n        var _after = _after||_f,\n            _before = _before||_f,\n            _handler = this;\n        return function(){\n            var _event = {args:_r.slice.call(arguments,0)};\n            _before(_event);\n            if (!_event.stopped){\n                _event.value = _handler.apply(this,_event.args);\n                _after(_event);\n            }\n            return _event.value;\n        };\n    };\n```\n`_$aop` 挂载在 Function 的原型，接受两个参数，一个是方法的前置操作，一个是后置操作。做平台适配的时候可以传入前置方法，给特定平台加入特定代码，完成后再执行主逻辑里标准规范的代码。可以看到，主逻辑并没有被侵入，适配的逻辑都写在了外部。在需要修改或者移除该平台的适配的时候，只需修改前置操作的方法即可。主逻辑不受任何影响。\n\n## ES7 中的 AOP - 装饰器\n\nES7 借鉴其他语言（如 python）引入了装饰器的概念，让我们可以更优雅的在 JavaScript 中使用 AOP。ES7 中的装饰器主要对类进行类进行装饰，可以对类、类方法、类属性进行装饰。\n\n```js\nclass Man {\n    say(str) {\n        console.log(str);\n    }\n}\n```\n\n调用 setAge 设置年龄的时候，我们需要做一些校验，比如只允许数字。\n\n## Typescript 中的 AOP - 装饰器和反射\n\n## 一些应用\n\n## 和 OOP 的区别\n\n## 和中间件的区别\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_drafts/aop-in-javascript.md","raw":"\nlayout: post\ntitle: JavaScript 中的 AOP\nbanner: assets/img/webpack.jpg\ntags: javascript\n---\n\n最早接触 AOP 这个概念是因为使用 [NEJ](https://github.com/genify/nej) 这个框架。在[平台适配系统](https://github.com/genify/nej/blob/master/doc/PLATFORM.md)这篇文档中详细讲解了 NEJ 是如何使用 AOP 思想来做平台适配工作的。\n\n## 什么是 AOP\n\nAOP 是 Aspect Oriented Programming（面向切面编程）的缩写，其核心思想是将横切关注点从主关注点中分离出来，因此特定领域的问题代码可以从标准业务逻辑中分离出来，从而使得主业务逻辑和领域性业务逻辑之间不会存在任何耦合性。\n\n## NEJ 中的 AOP\n\n上面说到，NEJ 是基于 AOP 的思想来做平台适配的。在做平台适配的时候，我们经常会写出这样代码：\n\n```js\nfunction doSomething(){\n    if(isTrident){\n        // TODO trident implement\n    }else if(isWebkit){\n        // TODO webkit implement\n    }else if(isGecko){\n        // TODO gecko implement\n    }else if(isPresto){\n        // TODO presto implement\n    }else{\n        // TODO w3c implement\n    }\n}\n```\n\n上面的代码对主逻辑有极强的侵入性，而且在日后修改的时候总是会修改到主逻辑，变的难以维护。\n\n```js\nfunction doSomething(){\n    // TODO w3c implement\n}\n\n// trident implement\ndoSomething = doSomething._$aop(\n    function(_event){\n        // TODO trident implement\n    }\n);\n// … …\n\ndoSomething(1,2,3);\n```\n\n我们来看下 NEJ `_$aop` 的实现：\n\n```js\nvar _extpro = Function.prototype;\n    /**\n     * AOP增强操作，增强操作接受一个输入参数包含以下信息\n     *\n     *  | 参数名称 | 参数类型  | 参数描述 |\n     *  | :--     | :--      | :-- |\n     *  | args    | Array    | 函数调用时实际输入参数，各增强操作中可以改变值后将影响至后续的操作 |\n     *  | value   | Variable | 输出结果 |\n     *  | stopped | Boolean  | 是否结束操作，终止后续操作 |\n     *\n     * @method external:Function#_$aop\n     * @param  {Function} arg0 - 前置操作，接受一个输入参数，见描述信息\n     * @param  {Function} arg1 - 后置操作，接受一个输入参数，见描述信息\n     * @return {Function}        增强后操作函数\n     */\n    _extpro._$aop = function(_before,_after){\n        var _after = _after||_f,\n            _before = _before||_f,\n            _handler = this;\n        return function(){\n            var _event = {args:_r.slice.call(arguments,0)};\n            _before(_event);\n            if (!_event.stopped){\n                _event.value = _handler.apply(this,_event.args);\n                _after(_event);\n            }\n            return _event.value;\n        };\n    };\n```\n`_$aop` 挂载在 Function 的原型，接受两个参数，一个是方法的前置操作，一个是后置操作。做平台适配的时候可以传入前置方法，给特定平台加入特定代码，完成后再执行主逻辑里标准规范的代码。可以看到，主逻辑并没有被侵入，适配的逻辑都写在了外部。在需要修改或者移除该平台的适配的时候，只需修改前置操作的方法即可。主逻辑不受任何影响。\n\n## ES7 中的 AOP - 装饰器\n\nES7 借鉴其他语言（如 python）引入了装饰器的概念，让我们可以更优雅的在 JavaScript 中使用 AOP。ES7 中的装饰器主要对类进行类进行装饰，可以对类、类方法、类属性进行装饰。\n\n```js\nclass Man {\n    say(str) {\n        console.log(str);\n    }\n}\n```\n\n调用 setAge 设置年龄的时候，我们需要做一些校验，比如只允许数字。\n\n## Typescript 中的 AOP - 装饰器和反射\n\n## 一些应用\n\n## 和 OOP 的区别\n\n## 和中间件的区别\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"aop-in-javascript","published":0,"date":"2019-01-17T13:00:11.000Z","updated":"2019-01-17T13:00:11.000Z","comments":1,"photos":[],"link":"","_id":"cjr1en2mm0000ha9scx1jho3m","content":"<p>最早接触 AOP 这个概念是因为使用 <a href=\"https://github.com/genify/nej\" target=\"_blank\" rel=\"noopener\">NEJ</a> 这个框架。在<a href=\"https://github.com/genify/nej/blob/master/doc/PLATFORM.md\" target=\"_blank\" rel=\"noopener\">平台适配系统</a>这篇文档中详细讲解了 NEJ 是如何使用 AOP 思想来做平台适配工作的。</p>\n<h2 id=\"什么是-aop\">什么是 AOP</h2>\n<p>AOP 是 Aspect Oriented Programming（面向切面编程）的缩写，其核心思想是将横切关注点从主关注点中分离出来，因此特定领域的问题代码可以从标准业务逻辑中分离出来，从而使得主业务逻辑和领域性业务逻辑之间不会存在任何耦合性。</p>\n<h2 id=\"nej-中的-aop\">NEJ 中的 AOP</h2>\n<p>上面说到，NEJ 是基于 AOP 的思想来做平台适配的。在做平台适配的时候，我们经常会写出这样代码：</p>\n<pre><code class=\"language-js\">function doSomething(){\n    if(isTrident){\n        // TODO trident implement\n    }else if(isWebkit){\n        // TODO webkit implement\n    }else if(isGecko){\n        // TODO gecko implement\n    }else if(isPresto){\n        // TODO presto implement\n    }else{\n        // TODO w3c implement\n    }\n}\n</code></pre>\n<p>上面的代码对主逻辑有极强的侵入性，而且在日后修改的时候总是会修改到主逻辑，变的难以维护。</p>\n<pre><code class=\"language-js\">function doSomething(){\n    // TODO w3c implement\n}\n\n// trident implement\ndoSomething = doSomething._$aop(\n    function(_event){\n        // TODO trident implement\n    }\n);\n// … …\n\ndoSomething(1,2,3);\n</code></pre>\n<p>我们来看下 NEJ <code>_$aop</code> 的实现：</p>\n<pre><code class=\"language-js\">var _extpro = Function.prototype;\n    /**\n     * AOP增强操作，增强操作接受一个输入参数包含以下信息\n     *\n     *  | 参数名称 | 参数类型  | 参数描述 |\n     *  | :--     | :--      | :-- |\n     *  | args    | Array    | 函数调用时实际输入参数，各增强操作中可以改变值后将影响至后续的操作 |\n     *  | value   | Variable | 输出结果 |\n     *  | stopped | Boolean  | 是否结束操作，终止后续操作 |\n     *\n     * @method external:Function#_$aop\n     * @param  {Function} arg0 - 前置操作，接受一个输入参数，见描述信息\n     * @param  {Function} arg1 - 后置操作，接受一个输入参数，见描述信息\n     * @return {Function}        增强后操作函数\n     */\n    _extpro._$aop = function(_before,_after){\n        var _after = _after||_f,\n            _before = _before||_f,\n            _handler = this;\n        return function(){\n            var _event = {args:_r.slice.call(arguments,0)};\n            _before(_event);\n            if (!_event.stopped){\n                _event.value = _handler.apply(this,_event.args);\n                _after(_event);\n            }\n            return _event.value;\n        };\n    };\n</code></pre>\n<p><code>_$aop</code> 挂载在 Function 的原型，接受两个参数，一个是方法的前置操作，一个是后置操作。做平台适配的时候可以传入前置方法，给特定平台加入特定代码，完成后再执行主逻辑里标准规范的代码。可以看到，主逻辑并没有被侵入，适配的逻辑都写在了外部。在需要修改或者移除该平台的适配的时候，只需修改前置操作的方法即可。主逻辑不受任何影响。</p>\n<h2 id=\"es7-中的-aop-装饰器\">ES7 中的 AOP - 装饰器</h2>\n<p>ES7 借鉴其他语言（如 python）引入了装饰器的概念，让我们可以更优雅的在 JavaScript 中使用 AOP。ES7 中的装饰器主要对类进行类进行装饰，可以对类、类方法、类属性进行装饰。</p>\n<pre><code class=\"language-js\">class Man {\n    say(str) {\n        console.log(str);\n    }\n}\n</code></pre>\n<p>调用 setAge 设置年龄的时候，我们需要做一些校验，比如只允许数字。</p>\n<h2 id=\"typescript-中的-aop-装饰器和反射\">Typescript 中的 AOP - 装饰器和反射</h2>\n<h2 id=\"一些应用\">一些应用</h2>\n<h2 id=\"和-oop-的区别\">和 OOP 的区别</h2>\n<h2 id=\"和中间件的区别\">和中间件的区别</h2>\n","site":{"data":{}},"excerpt":"","more":"<p>最早接触 AOP 这个概念是因为使用 <a href=\"https://github.com/genify/nej\" target=\"_blank\" rel=\"noopener\">NEJ</a> 这个框架。在<a href=\"https://github.com/genify/nej/blob/master/doc/PLATFORM.md\" target=\"_blank\" rel=\"noopener\">平台适配系统</a>这篇文档中详细讲解了 NEJ 是如何使用 AOP 思想来做平台适配工作的。</p>\n<h2 id=\"什么是-aop\">什么是 AOP</h2>\n<p>AOP 是 Aspect Oriented Programming（面向切面编程）的缩写，其核心思想是将横切关注点从主关注点中分离出来，因此特定领域的问题代码可以从标准业务逻辑中分离出来，从而使得主业务逻辑和领域性业务逻辑之间不会存在任何耦合性。</p>\n<h2 id=\"nej-中的-aop\">NEJ 中的 AOP</h2>\n<p>上面说到，NEJ 是基于 AOP 的思想来做平台适配的。在做平台适配的时候，我们经常会写出这样代码：</p>\n<pre><code class=\"language-js\">function doSomething(){\n    if(isTrident){\n        // TODO trident implement\n    }else if(isWebkit){\n        // TODO webkit implement\n    }else if(isGecko){\n        // TODO gecko implement\n    }else if(isPresto){\n        // TODO presto implement\n    }else{\n        // TODO w3c implement\n    }\n}\n</code></pre>\n<p>上面的代码对主逻辑有极强的侵入性，而且在日后修改的时候总是会修改到主逻辑，变的难以维护。</p>\n<pre><code class=\"language-js\">function doSomething(){\n    // TODO w3c implement\n}\n\n// trident implement\ndoSomething = doSomething._$aop(\n    function(_event){\n        // TODO trident implement\n    }\n);\n// … …\n\ndoSomething(1,2,3);\n</code></pre>\n<p>我们来看下 NEJ <code>_$aop</code> 的实现：</p>\n<pre><code class=\"language-js\">var _extpro = Function.prototype;\n    /**\n     * AOP增强操作，增强操作接受一个输入参数包含以下信息\n     *\n     *  | 参数名称 | 参数类型  | 参数描述 |\n     *  | :--     | :--      | :-- |\n     *  | args    | Array    | 函数调用时实际输入参数，各增强操作中可以改变值后将影响至后续的操作 |\n     *  | value   | Variable | 输出结果 |\n     *  | stopped | Boolean  | 是否结束操作，终止后续操作 |\n     *\n     * @method external:Function#_$aop\n     * @param  {Function} arg0 - 前置操作，接受一个输入参数，见描述信息\n     * @param  {Function} arg1 - 后置操作，接受一个输入参数，见描述信息\n     * @return {Function}        增强后操作函数\n     */\n    _extpro._$aop = function(_before,_after){\n        var _after = _after||_f,\n            _before = _before||_f,\n            _handler = this;\n        return function(){\n            var _event = {args:_r.slice.call(arguments,0)};\n            _before(_event);\n            if (!_event.stopped){\n                _event.value = _handler.apply(this,_event.args);\n                _after(_event);\n            }\n            return _event.value;\n        };\n    };\n</code></pre>\n<p><code>_$aop</code> 挂载在 Function 的原型，接受两个参数，一个是方法的前置操作，一个是后置操作。做平台适配的时候可以传入前置方法，给特定平台加入特定代码，完成后再执行主逻辑里标准规范的代码。可以看到，主逻辑并没有被侵入，适配的逻辑都写在了外部。在需要修改或者移除该平台的适配的时候，只需修改前置操作的方法即可。主逻辑不受任何影响。</p>\n<h2 id=\"es7-中的-aop-装饰器\">ES7 中的 AOP - 装饰器</h2>\n<p>ES7 借鉴其他语言（如 python）引入了装饰器的概念，让我们可以更优雅的在 JavaScript 中使用 AOP。ES7 中的装饰器主要对类进行类进行装饰，可以对类、类方法、类属性进行装饰。</p>\n<pre><code class=\"language-js\">class Man {\n    say(str) {\n        console.log(str);\n    }\n}\n</code></pre>\n<p>调用 setAge 设置年龄的时候，我们需要做一些校验，比如只允许数字。</p>\n<h2 id=\"typescript-中的-aop-装饰器和反射\">Typescript 中的 AOP - 装饰器和反射</h2>\n<h2 id=\"一些应用\">一些应用</h2>\n<h2 id=\"和-oop-的区别\">和 OOP 的区别</h2>\n<h2 id=\"和中间件的区别\">和中间件的区别</h2>\n"},{"layout":"post","title":"async & await","banner":"assets/img/async-and-await.jpeg","date":"2017-09-14T11:27:00.000Z","label":"译","_content":"\n[JavaScript Promises](https://davidwalsh.name/promises)的出现，让我们可以走出回调地狱，着实惊艳。Promises 允许我们更好的引入和处理异步任务，虽然如此，但引入好多的 `then` 还是会让代码变的混乱。我已经开始使用 ES2017 里的 `async` 和 `await` 关键字来简化 promises 的处理。让我们一睹 `async` 和 `await` 的风采！\n\n## 快速入门\n\n* `async` 是函数声明的关键字\n* `await` 用于 promises 处理过程中\n* `await` 必须用在 `async` 声明的函数内部，虽然 Chrome 已经支持“顶级的”的 `await`\n* `async` 函数返回 promises 对象，不关心函数的返回值是什么\n* `async/await` 和 promises 的底层实现是一样的\n* 大多数浏览器和 Nodejs 已经可用\n\n## `async` 和 `await` 的好处\n\n* 代码更加清晰简洁\n* 更少的回调，调试更加简单\n* 容易从 promises 中的 `then / catch` 转换\n* 代码看起来自上而下，更少的缩进。\n\n## `async` 和 `await` 简介\n\n从实例入手要更简单，我们先来看一个简单的 `async/await` 的使用方法：\n\n```js\n// 使用 async 定义函数，然后 await 才能使用\nasync function fetchContent() {\n  // Instead of using fetch().then, use await\n  let content = await fetch('/');\n  let text = await content.text();\n  \n  // async 函数内，text 是响应值\n  console.log(text);\n\n  // Resolve this async function with the text\n  return text;\n}\n\n// Use the async function\nvar promise = fetchContent().then(...);\n```\n\n首先使用 `async` 声明函数；声明之后，`await` 可以用在该函数内部。`await` 关键字后面跟 promise：[`fetch API`](https://davidwalsh.name/fetch)。异步任务（在这个例子是 `fetch`）执行之后，一直在执行完成才继续下一个任务（并没有产生阻塞）。最后这个函数处理了返回值并且返回了一个 promises 对象。\n\n代码自上而下，告别回调，异步处理变的更加简单！\n\n## 转换 Promise 为 `await`\n\n当时间允许，你一定很想将你的 promise 的代码升级到 `await`，让我们看下该怎么做：\n\n```js\n// Before: callback city!\nfetch('/users.json')\n  .then(response => response.json())\n  .then(json => {\n    console.log(json);\n  })\n  .catch(e => { console.log('error!'); })\n\n// After: no more callbacks!\nasync function getJson() {\n  try {\n    let response = await fetch('/users.json');\n    let json = await response.json();\n    console.log(json);\n  }\n  catch(e) {\n    console.log('Error!', e);\n  }\n}\n```\n\n从使用多个 `then` 到 `await` 十分简单，但你的代码的维护性变得很高。\n\n## `async` / `await` 模式\n\n声明 `async` 函数有以下方式：\n\n### 匿名 Async 函数\n\n```js\nlet main = (async function() {\n  let value = await fetch('/');\n})();\n```\n\n### Async 函数声明\n\n```js\nasync function main() {\n  let value = await fetch('/');\n};\n```\n\n### Async 函数赋值\n\n```js\nlet main = async function() {\n  let value = await fetch('/');\n};\n\n// Arrow functions too!\nlet main = async () => {\n  let value = await fetch('/');\n};\n```\n\n### Async 函数作为参数\n\n```js\ndocument.body.addEventListener('click', async function() {\n  let value = await fetch('/');\n});\n```\n\n### 对象和类方法\n\n```js\n// Object property\nlet obj = {\n  async method() {\n    let value = await fetch('/');\n  }\n};\n\n// Class methods\nclass MyClass {\n  async myMethod() {\n    let value = await fetch('/');\n  }\n}\n```\n\n正如你看到的，增加 `async` 函数十分简单，而且能很好的适用各种函数创建的流程。\n\n## 错误处理\n\n传统的 promises 允许使用 `catch` 回调处理 rejection，当你使用 `await`，最好使用 `try/catch`：\n\n```js\ntry {\n  let x = await myAsyncFunction();\n}\ncatch(e) {\n // Error!\n}\n```\n\n老式的 `try/catch` 不如 promises 的 `catch` 优雅，但在这里，它很给力！\n\n## 并行\n\nGoogle 的Jake Archibald在[Async functions document](https://developers.google.com/web/fundamentals/getting-started/primers/async-functions)中提出了一个完美的观点：不要用 `await` 使得任务变的太序列化。也就是说对于可以同时执行的任务，先触发任务然后再使用 `await`，而不是直接使用 `await` 使得任务像堆栈式一样的存储。\n\n```js\n// Will take 1000ms total!\nasync function series() {\n  await wait(500);\n  await wait(500);\n  return \"done!\";\n}\n\n// Would take only 500ms total!\nasync function parallel() {\n  const wait1 = wait(500);\n  const wait2 = wait(500);\n  await wait1;\n  await wait2;\n  return \"done!\";\n}\n```\n\n\n第一个代码块反面例子，第二个 `await` 需要等待第一个 `await` 执行完毕后才执行，第二个代码块是一个更好的方法，同时触发了两个任务，然后才使用 `await`；这样做可以使得多个异步操作同时执行！\n\n## `Promise.all` 等价方式\n\nPrimises API 中我最爱的 API 之一就是 `Promise.all`：当多有任务完成后才会触发回调。`async / await` 中没有等价的操作，但是[这篇文章](https://medium.com/@bluepnume/learn-about-promises-before-you-start-using-async-await-eb148164a9c8)提供了一个很好的解决方案：\n\n```js\nlet [foo, bar] = await Promise.all([getFoo(), getBar()]);\n```\n\n请记住，`async / await`和 promises 在底层实现上是一致的，所以我们可以简单的等待（await）所有的 promises 任务结束!\n\n现在大多数浏览器都可以使用 `async` 和 `await`，Nodejs 一样可用，老版本的Nodejs可以使用 [transform-async-to-generator](https://babeljs.io/docs/plugins/transform-async-to-generator/) 这个 babel 插件来使用 `async` 和 `await`。Promises 依然很棒，但 `async` 和 `await` 使得它可维护性更好。\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/async-and-await.md","raw":"\nlayout: post\ntitle: async & await\nbanner: assets/img/async-and-await.jpeg\ndate: 2017-9-14 19:27\nlabel: 译\ntags:\n- ES6\n---\n\n[JavaScript Promises](https://davidwalsh.name/promises)的出现，让我们可以走出回调地狱，着实惊艳。Promises 允许我们更好的引入和处理异步任务，虽然如此，但引入好多的 `then` 还是会让代码变的混乱。我已经开始使用 ES2017 里的 `async` 和 `await` 关键字来简化 promises 的处理。让我们一睹 `async` 和 `await` 的风采！\n\n## 快速入门\n\n* `async` 是函数声明的关键字\n* `await` 用于 promises 处理过程中\n* `await` 必须用在 `async` 声明的函数内部，虽然 Chrome 已经支持“顶级的”的 `await`\n* `async` 函数返回 promises 对象，不关心函数的返回值是什么\n* `async/await` 和 promises 的底层实现是一样的\n* 大多数浏览器和 Nodejs 已经可用\n\n## `async` 和 `await` 的好处\n\n* 代码更加清晰简洁\n* 更少的回调，调试更加简单\n* 容易从 promises 中的 `then / catch` 转换\n* 代码看起来自上而下，更少的缩进。\n\n## `async` 和 `await` 简介\n\n从实例入手要更简单，我们先来看一个简单的 `async/await` 的使用方法：\n\n```js\n// 使用 async 定义函数，然后 await 才能使用\nasync function fetchContent() {\n  // Instead of using fetch().then, use await\n  let content = await fetch('/');\n  let text = await content.text();\n  \n  // async 函数内，text 是响应值\n  console.log(text);\n\n  // Resolve this async function with the text\n  return text;\n}\n\n// Use the async function\nvar promise = fetchContent().then(...);\n```\n\n首先使用 `async` 声明函数；声明之后，`await` 可以用在该函数内部。`await` 关键字后面跟 promise：[`fetch API`](https://davidwalsh.name/fetch)。异步任务（在这个例子是 `fetch`）执行之后，一直在执行完成才继续下一个任务（并没有产生阻塞）。最后这个函数处理了返回值并且返回了一个 promises 对象。\n\n代码自上而下，告别回调，异步处理变的更加简单！\n\n## 转换 Promise 为 `await`\n\n当时间允许，你一定很想将你的 promise 的代码升级到 `await`，让我们看下该怎么做：\n\n```js\n// Before: callback city!\nfetch('/users.json')\n  .then(response => response.json())\n  .then(json => {\n    console.log(json);\n  })\n  .catch(e => { console.log('error!'); })\n\n// After: no more callbacks!\nasync function getJson() {\n  try {\n    let response = await fetch('/users.json');\n    let json = await response.json();\n    console.log(json);\n  }\n  catch(e) {\n    console.log('Error!', e);\n  }\n}\n```\n\n从使用多个 `then` 到 `await` 十分简单，但你的代码的维护性变得很高。\n\n## `async` / `await` 模式\n\n声明 `async` 函数有以下方式：\n\n### 匿名 Async 函数\n\n```js\nlet main = (async function() {\n  let value = await fetch('/');\n})();\n```\n\n### Async 函数声明\n\n```js\nasync function main() {\n  let value = await fetch('/');\n};\n```\n\n### Async 函数赋值\n\n```js\nlet main = async function() {\n  let value = await fetch('/');\n};\n\n// Arrow functions too!\nlet main = async () => {\n  let value = await fetch('/');\n};\n```\n\n### Async 函数作为参数\n\n```js\ndocument.body.addEventListener('click', async function() {\n  let value = await fetch('/');\n});\n```\n\n### 对象和类方法\n\n```js\n// Object property\nlet obj = {\n  async method() {\n    let value = await fetch('/');\n  }\n};\n\n// Class methods\nclass MyClass {\n  async myMethod() {\n    let value = await fetch('/');\n  }\n}\n```\n\n正如你看到的，增加 `async` 函数十分简单，而且能很好的适用各种函数创建的流程。\n\n## 错误处理\n\n传统的 promises 允许使用 `catch` 回调处理 rejection，当你使用 `await`，最好使用 `try/catch`：\n\n```js\ntry {\n  let x = await myAsyncFunction();\n}\ncatch(e) {\n // Error!\n}\n```\n\n老式的 `try/catch` 不如 promises 的 `catch` 优雅，但在这里，它很给力！\n\n## 并行\n\nGoogle 的Jake Archibald在[Async functions document](https://developers.google.com/web/fundamentals/getting-started/primers/async-functions)中提出了一个完美的观点：不要用 `await` 使得任务变的太序列化。也就是说对于可以同时执行的任务，先触发任务然后再使用 `await`，而不是直接使用 `await` 使得任务像堆栈式一样的存储。\n\n```js\n// Will take 1000ms total!\nasync function series() {\n  await wait(500);\n  await wait(500);\n  return \"done!\";\n}\n\n// Would take only 500ms total!\nasync function parallel() {\n  const wait1 = wait(500);\n  const wait2 = wait(500);\n  await wait1;\n  await wait2;\n  return \"done!\";\n}\n```\n\n\n第一个代码块反面例子，第二个 `await` 需要等待第一个 `await` 执行完毕后才执行，第二个代码块是一个更好的方法，同时触发了两个任务，然后才使用 `await`；这样做可以使得多个异步操作同时执行！\n\n## `Promise.all` 等价方式\n\nPrimises API 中我最爱的 API 之一就是 `Promise.all`：当多有任务完成后才会触发回调。`async / await` 中没有等价的操作，但是[这篇文章](https://medium.com/@bluepnume/learn-about-promises-before-you-start-using-async-await-eb148164a9c8)提供了一个很好的解决方案：\n\n```js\nlet [foo, bar] = await Promise.all([getFoo(), getBar()]);\n```\n\n请记住，`async / await`和 promises 在底层实现上是一致的，所以我们可以简单的等待（await）所有的 promises 任务结束!\n\n现在大多数浏览器都可以使用 `async` 和 `await`，Nodejs 一样可用，老版本的Nodejs可以使用 [transform-async-to-generator](https://babeljs.io/docs/plugins/transform-async-to-generator/) 这个 babel 插件来使用 `async` 和 `await`。Promises 依然很棒，但 `async` 和 `await` 使得它可维护性更好。\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"async-and-await","published":1,"updated":"2019-01-17T13:00:11.000Z","comments":1,"photos":[],"link":"","_id":"cjr1en2mp0001ha9slznarwsi","content":"<p><a href=\"https://davidwalsh.name/promises\" target=\"_blank\" rel=\"noopener\">JavaScript Promises</a>的出现，让我们可以走出回调地狱，着实惊艳。Promises 允许我们更好的引入和处理异步任务，虽然如此，但引入好多的 <code>then</code> 还是会让代码变的混乱。我已经开始使用 ES2017 里的 <code>async</code> 和 <code>await</code> 关键字来简化 promises 的处理。让我们一睹 <code>async</code> 和 <code>await</code> 的风采！</p>\n<h2 id=\"快速入门\">快速入门</h2>\n<ul>\n<li><code>async</code> 是函数声明的关键字</li>\n<li><code>await</code> 用于 promises 处理过程中</li>\n<li><code>await</code> 必须用在 <code>async</code> 声明的函数内部，虽然 Chrome 已经支持“顶级的”的 <code>await</code></li>\n<li><code>async</code> 函数返回 promises 对象，不关心函数的返回值是什么</li>\n<li><code>async/await</code> 和 promises 的底层实现是一样的</li>\n<li>大多数浏览器和 Nodejs 已经可用</li>\n</ul>\n<h2 id=\"async-和-await-的好处\"><code>async</code> 和 <code>await</code> 的好处</h2>\n<ul>\n<li>代码更加清晰简洁</li>\n<li>更少的回调，调试更加简单</li>\n<li>容易从 promises 中的 <code>then / catch</code> 转换</li>\n<li>代码看起来自上而下，更少的缩进。</li>\n</ul>\n<h2 id=\"async-和-await-简介\"><code>async</code> 和 <code>await</code> 简介</h2>\n<p>从实例入手要更简单，我们先来看一个简单的 <code>async/await</code> 的使用方法：</p>\n<pre><code class=\"language-js\">// 使用 async 定义函数，然后 await 才能使用\nasync function fetchContent() {\n  // Instead of using fetch().then, use await\n  let content = await fetch('/');\n  let text = await content.text();\n  \n  // async 函数内，text 是响应值\n  console.log(text);\n\n  // Resolve this async function with the text\n  return text;\n}\n\n// Use the async function\nvar promise = fetchContent().then(...);\n</code></pre>\n<p>首先使用 <code>async</code> 声明函数；声明之后，<code>await</code> 可以用在该函数内部。<code>await</code> 关键字后面跟 promise：<a href=\"https://davidwalsh.name/fetch\" target=\"_blank\" rel=\"noopener\"><code>fetch API</code></a>。异步任务（在这个例子是 <code>fetch</code>）执行之后，一直在执行完成才继续下一个任务（并没有产生阻塞）。最后这个函数处理了返回值并且返回了一个 promises 对象。</p>\n<p>代码自上而下，告别回调，异步处理变的更加简单！</p>\n<h2 id=\"转换-promise-为-await\">转换 Promise 为 <code>await</code></h2>\n<p>当时间允许，你一定很想将你的 promise 的代码升级到 <code>await</code>，让我们看下该怎么做：</p>\n<pre><code class=\"language-js\">// Before: callback city!\nfetch('/users.json')\n  .then(response =&gt; response.json())\n  .then(json =&gt; {\n    console.log(json);\n  })\n  .catch(e =&gt; { console.log('error!'); })\n\n// After: no more callbacks!\nasync function getJson() {\n  try {\n    let response = await fetch('/users.json');\n    let json = await response.json();\n    console.log(json);\n  }\n  catch(e) {\n    console.log('Error!', e);\n  }\n}\n</code></pre>\n<p>从使用多个 <code>then</code> 到 <code>await</code> 十分简单，但你的代码的维护性变得很高。</p>\n<h2 id=\"async-await-模式\"><code>async</code> / <code>await</code> 模式</h2>\n<p>声明 <code>async</code> 函数有以下方式：</p>\n<h3 id=\"匿名-async-函数\">匿名 Async 函数</h3>\n<pre><code class=\"language-js\">let main = (async function() {\n  let value = await fetch('/');\n})();\n</code></pre>\n<h3 id=\"async-函数声明\">Async 函数声明</h3>\n<pre><code class=\"language-js\">async function main() {\n  let value = await fetch('/');\n};\n</code></pre>\n<h3 id=\"async-函数赋值\">Async 函数赋值</h3>\n<pre><code class=\"language-js\">let main = async function() {\n  let value = await fetch('/');\n};\n\n// Arrow functions too!\nlet main = async () =&gt; {\n  let value = await fetch('/');\n};\n</code></pre>\n<h3 id=\"async-函数作为参数\">Async 函数作为参数</h3>\n<pre><code class=\"language-js\">document.body.addEventListener('click', async function() {\n  let value = await fetch('/');\n});\n</code></pre>\n<h3 id=\"对象和类方法\">对象和类方法</h3>\n<pre><code class=\"language-js\">// Object property\nlet obj = {\n  async method() {\n    let value = await fetch('/');\n  }\n};\n\n// Class methods\nclass MyClass {\n  async myMethod() {\n    let value = await fetch('/');\n  }\n}\n</code></pre>\n<p>正如你看到的，增加 <code>async</code> 函数十分简单，而且能很好的适用各种函数创建的流程。</p>\n<h2 id=\"错误处理\">错误处理</h2>\n<p>传统的 promises 允许使用 <code>catch</code> 回调处理 rejection，当你使用 <code>await</code>，最好使用 <code>try/catch</code>：</p>\n<pre><code class=\"language-js\">try {\n  let x = await myAsyncFunction();\n}\ncatch(e) {\n // Error!\n}\n</code></pre>\n<p>老式的 <code>try/catch</code> 不如 promises 的 <code>catch</code> 优雅，但在这里，它很给力！</p>\n<h2 id=\"并行\">并行</h2>\n<p>Google 的Jake Archibald在<a href=\"https://developers.google.com/web/fundamentals/getting-started/primers/async-functions\" target=\"_blank\" rel=\"noopener\">Async functions document</a>中提出了一个完美的观点：不要用 <code>await</code> 使得任务变的太序列化。也就是说对于可以同时执行的任务，先触发任务然后再使用 <code>await</code>，而不是直接使用 <code>await</code> 使得任务像堆栈式一样的存储。</p>\n<pre><code class=\"language-js\">// Will take 1000ms total!\nasync function series() {\n  await wait(500);\n  await wait(500);\n  return &quot;done!&quot;;\n}\n\n// Would take only 500ms total!\nasync function parallel() {\n  const wait1 = wait(500);\n  const wait2 = wait(500);\n  await wait1;\n  await wait2;\n  return &quot;done!&quot;;\n}\n</code></pre>\n<p>第一个代码块反面例子，第二个 <code>await</code> 需要等待第一个 <code>await</code> 执行完毕后才执行，第二个代码块是一个更好的方法，同时触发了两个任务，然后才使用 <code>await</code>；这样做可以使得多个异步操作同时执行！</p>\n<h2 id=\"promise-all-等价方式\"><code>Promise.all</code> 等价方式</h2>\n<p>Primises API 中我最爱的 API 之一就是 <code>Promise.all</code>：当多有任务完成后才会触发回调。<code>async / await</code> 中没有等价的操作，但是<a href=\"https://medium.com/@bluepnume/learn-about-promises-before-you-start-using-async-await-eb148164a9c8\" target=\"_blank\" rel=\"noopener\">这篇文章</a>提供了一个很好的解决方案：</p>\n<pre><code class=\"language-js\">let [foo, bar] = await Promise.all([getFoo(), getBar()]);\n</code></pre>\n<p>请记住，<code>async / await</code>和 promises 在底层实现上是一致的，所以我们可以简单的等待（await）所有的 promises 任务结束!</p>\n<p>现在大多数浏览器都可以使用 <code>async</code> 和 <code>await</code>，Nodejs 一样可用，老版本的Nodejs可以使用 <a href=\"https://babeljs.io/docs/plugins/transform-async-to-generator/\" target=\"_blank\" rel=\"noopener\">transform-async-to-generator</a> 这个 babel 插件来使用 <code>async</code> 和 <code>await</code>。Promises 依然很棒，但 <code>async</code> 和 <code>await</code> 使得它可维护性更好。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://davidwalsh.name/promises\" target=\"_blank\" rel=\"noopener\">JavaScript Promises</a>的出现，让我们可以走出回调地狱，着实惊艳。Promises 允许我们更好的引入和处理异步任务，虽然如此，但引入好多的 <code>then</code> 还是会让代码变的混乱。我已经开始使用 ES2017 里的 <code>async</code> 和 <code>await</code> 关键字来简化 promises 的处理。让我们一睹 <code>async</code> 和 <code>await</code> 的风采！</p>\n<h2 id=\"快速入门\">快速入门</h2>\n<ul>\n<li><code>async</code> 是函数声明的关键字</li>\n<li><code>await</code> 用于 promises 处理过程中</li>\n<li><code>await</code> 必须用在 <code>async</code> 声明的函数内部，虽然 Chrome 已经支持“顶级的”的 <code>await</code></li>\n<li><code>async</code> 函数返回 promises 对象，不关心函数的返回值是什么</li>\n<li><code>async/await</code> 和 promises 的底层实现是一样的</li>\n<li>大多数浏览器和 Nodejs 已经可用</li>\n</ul>\n<h2 id=\"async-和-await-的好处\"><code>async</code> 和 <code>await</code> 的好处</h2>\n<ul>\n<li>代码更加清晰简洁</li>\n<li>更少的回调，调试更加简单</li>\n<li>容易从 promises 中的 <code>then / catch</code> 转换</li>\n<li>代码看起来自上而下，更少的缩进。</li>\n</ul>\n<h2 id=\"async-和-await-简介\"><code>async</code> 和 <code>await</code> 简介</h2>\n<p>从实例入手要更简单，我们先来看一个简单的 <code>async/await</code> 的使用方法：</p>\n<pre><code class=\"language-js\">// 使用 async 定义函数，然后 await 才能使用\nasync function fetchContent() {\n  // Instead of using fetch().then, use await\n  let content = await fetch('/');\n  let text = await content.text();\n  \n  // async 函数内，text 是响应值\n  console.log(text);\n\n  // Resolve this async function with the text\n  return text;\n}\n\n// Use the async function\nvar promise = fetchContent().then(...);\n</code></pre>\n<p>首先使用 <code>async</code> 声明函数；声明之后，<code>await</code> 可以用在该函数内部。<code>await</code> 关键字后面跟 promise：<a href=\"https://davidwalsh.name/fetch\" target=\"_blank\" rel=\"noopener\"><code>fetch API</code></a>。异步任务（在这个例子是 <code>fetch</code>）执行之后，一直在执行完成才继续下一个任务（并没有产生阻塞）。最后这个函数处理了返回值并且返回了一个 promises 对象。</p>\n<p>代码自上而下，告别回调，异步处理变的更加简单！</p>\n<h2 id=\"转换-promise-为-await\">转换 Promise 为 <code>await</code></h2>\n<p>当时间允许，你一定很想将你的 promise 的代码升级到 <code>await</code>，让我们看下该怎么做：</p>\n<pre><code class=\"language-js\">// Before: callback city!\nfetch('/users.json')\n  .then(response =&gt; response.json())\n  .then(json =&gt; {\n    console.log(json);\n  })\n  .catch(e =&gt; { console.log('error!'); })\n\n// After: no more callbacks!\nasync function getJson() {\n  try {\n    let response = await fetch('/users.json');\n    let json = await response.json();\n    console.log(json);\n  }\n  catch(e) {\n    console.log('Error!', e);\n  }\n}\n</code></pre>\n<p>从使用多个 <code>then</code> 到 <code>await</code> 十分简单，但你的代码的维护性变得很高。</p>\n<h2 id=\"async-await-模式\"><code>async</code> / <code>await</code> 模式</h2>\n<p>声明 <code>async</code> 函数有以下方式：</p>\n<h3 id=\"匿名-async-函数\">匿名 Async 函数</h3>\n<pre><code class=\"language-js\">let main = (async function() {\n  let value = await fetch('/');\n})();\n</code></pre>\n<h3 id=\"async-函数声明\">Async 函数声明</h3>\n<pre><code class=\"language-js\">async function main() {\n  let value = await fetch('/');\n};\n</code></pre>\n<h3 id=\"async-函数赋值\">Async 函数赋值</h3>\n<pre><code class=\"language-js\">let main = async function() {\n  let value = await fetch('/');\n};\n\n// Arrow functions too!\nlet main = async () =&gt; {\n  let value = await fetch('/');\n};\n</code></pre>\n<h3 id=\"async-函数作为参数\">Async 函数作为参数</h3>\n<pre><code class=\"language-js\">document.body.addEventListener('click', async function() {\n  let value = await fetch('/');\n});\n</code></pre>\n<h3 id=\"对象和类方法\">对象和类方法</h3>\n<pre><code class=\"language-js\">// Object property\nlet obj = {\n  async method() {\n    let value = await fetch('/');\n  }\n};\n\n// Class methods\nclass MyClass {\n  async myMethod() {\n    let value = await fetch('/');\n  }\n}\n</code></pre>\n<p>正如你看到的，增加 <code>async</code> 函数十分简单，而且能很好的适用各种函数创建的流程。</p>\n<h2 id=\"错误处理\">错误处理</h2>\n<p>传统的 promises 允许使用 <code>catch</code> 回调处理 rejection，当你使用 <code>await</code>，最好使用 <code>try/catch</code>：</p>\n<pre><code class=\"language-js\">try {\n  let x = await myAsyncFunction();\n}\ncatch(e) {\n // Error!\n}\n</code></pre>\n<p>老式的 <code>try/catch</code> 不如 promises 的 <code>catch</code> 优雅，但在这里，它很给力！</p>\n<h2 id=\"并行\">并行</h2>\n<p>Google 的Jake Archibald在<a href=\"https://developers.google.com/web/fundamentals/getting-started/primers/async-functions\" target=\"_blank\" rel=\"noopener\">Async functions document</a>中提出了一个完美的观点：不要用 <code>await</code> 使得任务变的太序列化。也就是说对于可以同时执行的任务，先触发任务然后再使用 <code>await</code>，而不是直接使用 <code>await</code> 使得任务像堆栈式一样的存储。</p>\n<pre><code class=\"language-js\">// Will take 1000ms total!\nasync function series() {\n  await wait(500);\n  await wait(500);\n  return &quot;done!&quot;;\n}\n\n// Would take only 500ms total!\nasync function parallel() {\n  const wait1 = wait(500);\n  const wait2 = wait(500);\n  await wait1;\n  await wait2;\n  return &quot;done!&quot;;\n}\n</code></pre>\n<p>第一个代码块反面例子，第二个 <code>await</code> 需要等待第一个 <code>await</code> 执行完毕后才执行，第二个代码块是一个更好的方法，同时触发了两个任务，然后才使用 <code>await</code>；这样做可以使得多个异步操作同时执行！</p>\n<h2 id=\"promise-all-等价方式\"><code>Promise.all</code> 等价方式</h2>\n<p>Primises API 中我最爱的 API 之一就是 <code>Promise.all</code>：当多有任务完成后才会触发回调。<code>async / await</code> 中没有等价的操作，但是<a href=\"https://medium.com/@bluepnume/learn-about-promises-before-you-start-using-async-await-eb148164a9c8\" target=\"_blank\" rel=\"noopener\">这篇文章</a>提供了一个很好的解决方案：</p>\n<pre><code class=\"language-js\">let [foo, bar] = await Promise.all([getFoo(), getBar()]);\n</code></pre>\n<p>请记住，<code>async / await</code>和 promises 在底层实现上是一致的，所以我们可以简单的等待（await）所有的 promises 任务结束!</p>\n<p>现在大多数浏览器都可以使用 <code>async</code> 和 <code>await</code>，Nodejs 一样可用，老版本的Nodejs可以使用 <a href=\"https://babeljs.io/docs/plugins/transform-async-to-generator/\" target=\"_blank\" rel=\"noopener\">transform-async-to-generator</a> 这个 babel 插件来使用 <code>async</code> 和 <code>await</code>。Promises 依然很棒，但 <code>async</code> 和 <code>await</code> 使得它可维护性更好。</p>\n"},{"layout":"post","title":"妃英理养的猫，叫五郎","banner":"assets/img/conan.jpg","_content":"\n这还是我第一次在电影院看剧场版的名侦探柯南。晚8点50场，8点半买票。\n\n![img](/posts/assets/img/611541861556_.pic_hd.jpg)\n\n上座率很低，8点47进场，只有我一人，最后，也没超过十个人。\n\n可能大家忙着双十一备战？😂\n\n电影开始前的椰树汁广告，也是震惊到了我：（夜间，谨慎开车\n\n我就不放图了，一个穿白色紧身T恤的巨ru MM拿着椰树汁，说：又白又嫩，我从小喝到大。\n\n真的，以前的阅读理解都弱爆了。\n\n\n虽然之前已经有资源，并且已经看完了。不过熟悉的旋律，熟悉的片头，大银幕上还是有不一样的感觉。\n\n整片风格朝着好莱坞动作大片靠拢，爆炸、飙车。用知乎的话说，无视物理定律的奇幻大片。没有了以前大片的推理，但其实很适合在银幕上看。\n\n吐槽的就不多说了，知乎上大多数差评，不过我看的很爽。（很肤浅哈哈\n\n不过我觉得有些细节很有意思。\n\n名侦探柯南这么多年，也是与时俱进的，主角们的用的手机从以前的小屏幕到现在的全触屏，用的电脑也从大头机变成了薄薄的笔记本。这部电影也是，互联网、物联网、无人机。\n\nNOR匿名浏览器，我猜是借鉴TOR？下面是 TOR 的百度百科介绍。\n\n> Tor（The Onion Router）是第二代洋葱路由（onion routing）的一种实现，用户通过Tor可以在因特网上进行匿名交流。最初该项目由美国海军研究实验室（US Naval Research Laboratory）赞助。2004年的后期，Tor成为电子前哨基金会（Electronic Frontier Foundation，EFF）的一个项目。2005年后期，EFF不再赞助Tor项目，但他们继续维持Tor的官方网站。\n\n安室透最后那句：我的恋人，是我的国家。也真的是酥爆炸了。\n\n最后，真正萌到我是：律师橘境子问妃英理养的猫的名字，柯南说叫五郎。😂\n\n最后，毛利小五郎一把搂住妃英理，说你不准离开，妃英理女士小脸一红。\n\n这是这部剧场版小五郎叔叔除了当肉鸡之外戏份最重的一幕了。\n\n虽然剧场版一直被吐槽，但出了新剧集，我总是忍不住第一时间去看，名侦探是我追过的为数不多的动漫。\n\n柯南的执着、勇敢，和小兰发生任何事情都彼此信任的爱情，都是我缺少的我没有的，每次看，都会因为其中的情节动容。\n\n在这里，仿佛能够看到一个更好的世界。\n\n\n","source":"_posts/conan.md","raw":"\nlayout: post\ntitle:  妃英理养的猫，叫五郎\nbanner: assets/img/conan.jpg\ntags: life\n---\n\n这还是我第一次在电影院看剧场版的名侦探柯南。晚8点50场，8点半买票。\n\n![img](/posts/assets/img/611541861556_.pic_hd.jpg)\n\n上座率很低，8点47进场，只有我一人，最后，也没超过十个人。\n\n可能大家忙着双十一备战？😂\n\n电影开始前的椰树汁广告，也是震惊到了我：（夜间，谨慎开车\n\n我就不放图了，一个穿白色紧身T恤的巨ru MM拿着椰树汁，说：又白又嫩，我从小喝到大。\n\n真的，以前的阅读理解都弱爆了。\n\n\n虽然之前已经有资源，并且已经看完了。不过熟悉的旋律，熟悉的片头，大银幕上还是有不一样的感觉。\n\n整片风格朝着好莱坞动作大片靠拢，爆炸、飙车。用知乎的话说，无视物理定律的奇幻大片。没有了以前大片的推理，但其实很适合在银幕上看。\n\n吐槽的就不多说了，知乎上大多数差评，不过我看的很爽。（很肤浅哈哈\n\n不过我觉得有些细节很有意思。\n\n名侦探柯南这么多年，也是与时俱进的，主角们的用的手机从以前的小屏幕到现在的全触屏，用的电脑也从大头机变成了薄薄的笔记本。这部电影也是，互联网、物联网、无人机。\n\nNOR匿名浏览器，我猜是借鉴TOR？下面是 TOR 的百度百科介绍。\n\n> Tor（The Onion Router）是第二代洋葱路由（onion routing）的一种实现，用户通过Tor可以在因特网上进行匿名交流。最初该项目由美国海军研究实验室（US Naval Research Laboratory）赞助。2004年的后期，Tor成为电子前哨基金会（Electronic Frontier Foundation，EFF）的一个项目。2005年后期，EFF不再赞助Tor项目，但他们继续维持Tor的官方网站。\n\n安室透最后那句：我的恋人，是我的国家。也真的是酥爆炸了。\n\n最后，真正萌到我是：律师橘境子问妃英理养的猫的名字，柯南说叫五郎。😂\n\n最后，毛利小五郎一把搂住妃英理，说你不准离开，妃英理女士小脸一红。\n\n这是这部剧场版小五郎叔叔除了当肉鸡之外戏份最重的一幕了。\n\n虽然剧场版一直被吐槽，但出了新剧集，我总是忍不住第一时间去看，名侦探是我追过的为数不多的动漫。\n\n柯南的执着、勇敢，和小兰发生任何事情都彼此信任的爱情，都是我缺少的我没有的，每次看，都会因为其中的情节动容。\n\n在这里，仿佛能够看到一个更好的世界。\n\n\n","slug":"conan","published":1,"date":"2019-01-17T13:00:11.000Z","updated":"2019-01-17T13:00:11.000Z","comments":1,"photos":[],"link":"","_id":"cjr1en2mt0003ha9s0nwyxuy5","content":"<p>这还是我第一次在电影院看剧场版的名侦探柯南。晚8点50场，8点半买票。</p>\n<p><img src=\"/posts/assets/img/611541861556_.pic_hd.jpg\" alt=\"img\"></p>\n<p>上座率很低，8点47进场，只有我一人，最后，也没超过十个人。</p>\n<p>可能大家忙着双十一备战？😂</p>\n<p>电影开始前的椰树汁广告，也是震惊到了我：（夜间，谨慎开车</p>\n<p>我就不放图了，一个穿白色紧身T恤的巨ru MM拿着椰树汁，说：又白又嫩，我从小喝到大。</p>\n<p>真的，以前的阅读理解都弱爆了。</p>\n<p>虽然之前已经有资源，并且已经看完了。不过熟悉的旋律，熟悉的片头，大银幕上还是有不一样的感觉。</p>\n<p>整片风格朝着好莱坞动作大片靠拢，爆炸、飙车。用知乎的话说，无视物理定律的奇幻大片。没有了以前大片的推理，但其实很适合在银幕上看。</p>\n<p>吐槽的就不多说了，知乎上大多数差评，不过我看的很爽。（很肤浅哈哈</p>\n<p>不过我觉得有些细节很有意思。</p>\n<p>名侦探柯南这么多年，也是与时俱进的，主角们的用的手机从以前的小屏幕到现在的全触屏，用的电脑也从大头机变成了薄薄的笔记本。这部电影也是，互联网、物联网、无人机。</p>\n<p>NOR匿名浏览器，我猜是借鉴TOR？下面是 TOR 的百度百科介绍。</p>\n<blockquote>\n<p>Tor（The Onion Router）是第二代洋葱路由（onion routing）的一种实现，用户通过Tor可以在因特网上进行匿名交流。最初该项目由美国海军研究实验室（US Naval Research Laboratory）赞助。2004年的后期，Tor成为电子前哨基金会（Electronic Frontier Foundation，EFF）的一个项目。2005年后期，EFF不再赞助Tor项目，但他们继续维持Tor的官方网站。</p>\n</blockquote>\n<p>安室透最后那句：我的恋人，是我的国家。也真的是酥爆炸了。</p>\n<p>最后，真正萌到我是：律师橘境子问妃英理养的猫的名字，柯南说叫五郎。😂</p>\n<p>最后，毛利小五郎一把搂住妃英理，说你不准离开，妃英理女士小脸一红。</p>\n<p>这是这部剧场版小五郎叔叔除了当肉鸡之外戏份最重的一幕了。</p>\n<p>虽然剧场版一直被吐槽，但出了新剧集，我总是忍不住第一时间去看，名侦探是我追过的为数不多的动漫。</p>\n<p>柯南的执着、勇敢，和小兰发生任何事情都彼此信任的爱情，都是我缺少的我没有的，每次看，都会因为其中的情节动容。</p>\n<p>在这里，仿佛能够看到一个更好的世界。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这还是我第一次在电影院看剧场版的名侦探柯南。晚8点50场，8点半买票。</p>\n<p><img src=\"/posts/assets/img/611541861556_.pic_hd.jpg\" alt=\"img\"></p>\n<p>上座率很低，8点47进场，只有我一人，最后，也没超过十个人。</p>\n<p>可能大家忙着双十一备战？😂</p>\n<p>电影开始前的椰树汁广告，也是震惊到了我：（夜间，谨慎开车</p>\n<p>我就不放图了，一个穿白色紧身T恤的巨ru MM拿着椰树汁，说：又白又嫩，我从小喝到大。</p>\n<p>真的，以前的阅读理解都弱爆了。</p>\n<p>虽然之前已经有资源，并且已经看完了。不过熟悉的旋律，熟悉的片头，大银幕上还是有不一样的感觉。</p>\n<p>整片风格朝着好莱坞动作大片靠拢，爆炸、飙车。用知乎的话说，无视物理定律的奇幻大片。没有了以前大片的推理，但其实很适合在银幕上看。</p>\n<p>吐槽的就不多说了，知乎上大多数差评，不过我看的很爽。（很肤浅哈哈</p>\n<p>不过我觉得有些细节很有意思。</p>\n<p>名侦探柯南这么多年，也是与时俱进的，主角们的用的手机从以前的小屏幕到现在的全触屏，用的电脑也从大头机变成了薄薄的笔记本。这部电影也是，互联网、物联网、无人机。</p>\n<p>NOR匿名浏览器，我猜是借鉴TOR？下面是 TOR 的百度百科介绍。</p>\n<blockquote>\n<p>Tor（The Onion Router）是第二代洋葱路由（onion routing）的一种实现，用户通过Tor可以在因特网上进行匿名交流。最初该项目由美国海军研究实验室（US Naval Research Laboratory）赞助。2004年的后期，Tor成为电子前哨基金会（Electronic Frontier Foundation，EFF）的一个项目。2005年后期，EFF不再赞助Tor项目，但他们继续维持Tor的官方网站。</p>\n</blockquote>\n<p>安室透最后那句：我的恋人，是我的国家。也真的是酥爆炸了。</p>\n<p>最后，真正萌到我是：律师橘境子问妃英理养的猫的名字，柯南说叫五郎。😂</p>\n<p>最后，毛利小五郎一把搂住妃英理，说你不准离开，妃英理女士小脸一红。</p>\n<p>这是这部剧场版小五郎叔叔除了当肉鸡之外戏份最重的一幕了。</p>\n<p>虽然剧场版一直被吐槽，但出了新剧集，我总是忍不住第一时间去看，名侦探是我追过的为数不多的动漫。</p>\n<p>柯南的执着、勇敢，和小兰发生任何事情都彼此信任的爱情，都是我缺少的我没有的，每次看，都会因为其中的情节动容。</p>\n<p>在这里，仿佛能够看到一个更好的世界。</p>\n"},{"layout":"post","title":"跨域读写 Cookie","banner":"assets/img/cookie.jpeg","_content":"\n因为 CORS（HTTP访问控制）的出现，跨域请求变的简单了很多，只需要服务器设置几个 response header 就可以轻松实现跨域访问。\n\n```js\n// nodejs express 简单实现\napp.get('/cors_url', function(req, res) {\n    res.set({\n        'Access-Control-Allow-Origin': 'http://admin.ts.163.com:8184',\n        'Access-Control-Allow-Methods': '*',\n        'Access-Control-Allow-Headers': '*'\n    })\n\n    res.json({\n        code: 200,\n        msg: 'hello'\n    })\n})\n```\n\n在这样设置之后，请求可以正常发出和响应，但你会发现，此时并没有带上服务器域名下的 cookie。比如，在你使用网易邮箱登录了之后，你的浏览器中就会出现 domain 为 `.163.com` 的 cookie。如果我们在另一个域名（比如 my.com）调用了 x1.163.com 域名下的接口，此时 request header 并不会带上 `.163.com` cookie。\n\nCORS 是可以做到这一点的，前后端进行相应的设置后，就可以发送 cookie。\n\n首先 ajax 中，在 send 方法前，设置 `xhr.withCredentials = true`，就可以向服务器发送 cookie。这时候如果发起请求，会得到一个错误：\n\n> XMLHttpRequest cannot load http://x1.163.com:9003/cors_url?id=123456. The value of the 'Access-Control-Allow-Credentials' header in the response is '' which must be 'true' when the request's credentials mode is 'include'. Origin 'http://you.com:9005' is therefore not allowed access. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute.\n\n服务器也要进行相应的设置：\n\n```js\n// nodejs express 简单实现\napp.get('/cors_url', function(req, res) {\n    res.set({\n        'Access-Control-Allow-Origin': 'http://admin.ts.163.com:8184',\n        'Access-Control-Allow-Methods': '*',\n        'Access-Control-Allow-Headers': '*',\n        'Access-Control-Allow-Credentials': true // 增加 Access-Control-Allow-Credentials \n    })\n\n    res.json({\n        code: 200,\n        msg: 'hello'\n    })\n})\n```\n\n\n此时发送请求， request header 多了 cookie 这个字段，同时服务器响应头中也可以通过 Set-Cookie 设置服务器域名下的 cookie。\n\n![cors-header](/posts/assets/img/cors/header.jpg)\n\n对于 IE8 和 IE9，浏览器提供了 `window.XDomainRequest` 对象，方法和 XMLHttpRequest 类似。\n\n参考：\n\n* [HTTP访问控制（CORS）](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS#附带身份凭证的请求)\n* [跨域资源共享 CORS 详解](http://www.ruanyifeng.com/blog/2016/04/cors.html)\n* [XDomainRequest object](https://msdn.microsoft.com/en-us/library/cc288060%28VS.85%29.aspx)\n\n\n\n\n\n\n\n\n\n","source":"_posts/cors-cookie.md","raw":"\nlayout: post\ntitle: 跨域读写 Cookie\nbanner: assets/img/cookie.jpeg\ntags:\n- JavaScript\n- XHR\n---\n\n因为 CORS（HTTP访问控制）的出现，跨域请求变的简单了很多，只需要服务器设置几个 response header 就可以轻松实现跨域访问。\n\n```js\n// nodejs express 简单实现\napp.get('/cors_url', function(req, res) {\n    res.set({\n        'Access-Control-Allow-Origin': 'http://admin.ts.163.com:8184',\n        'Access-Control-Allow-Methods': '*',\n        'Access-Control-Allow-Headers': '*'\n    })\n\n    res.json({\n        code: 200,\n        msg: 'hello'\n    })\n})\n```\n\n在这样设置之后，请求可以正常发出和响应，但你会发现，此时并没有带上服务器域名下的 cookie。比如，在你使用网易邮箱登录了之后，你的浏览器中就会出现 domain 为 `.163.com` 的 cookie。如果我们在另一个域名（比如 my.com）调用了 x1.163.com 域名下的接口，此时 request header 并不会带上 `.163.com` cookie。\n\nCORS 是可以做到这一点的，前后端进行相应的设置后，就可以发送 cookie。\n\n首先 ajax 中，在 send 方法前，设置 `xhr.withCredentials = true`，就可以向服务器发送 cookie。这时候如果发起请求，会得到一个错误：\n\n> XMLHttpRequest cannot load http://x1.163.com:9003/cors_url?id=123456. The value of the 'Access-Control-Allow-Credentials' header in the response is '' which must be 'true' when the request's credentials mode is 'include'. Origin 'http://you.com:9005' is therefore not allowed access. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute.\n\n服务器也要进行相应的设置：\n\n```js\n// nodejs express 简单实现\napp.get('/cors_url', function(req, res) {\n    res.set({\n        'Access-Control-Allow-Origin': 'http://admin.ts.163.com:8184',\n        'Access-Control-Allow-Methods': '*',\n        'Access-Control-Allow-Headers': '*',\n        'Access-Control-Allow-Credentials': true // 增加 Access-Control-Allow-Credentials \n    })\n\n    res.json({\n        code: 200,\n        msg: 'hello'\n    })\n})\n```\n\n\n此时发送请求， request header 多了 cookie 这个字段，同时服务器响应头中也可以通过 Set-Cookie 设置服务器域名下的 cookie。\n\n![cors-header](/posts/assets/img/cors/header.jpg)\n\n对于 IE8 和 IE9，浏览器提供了 `window.XDomainRequest` 对象，方法和 XMLHttpRequest 类似。\n\n参考：\n\n* [HTTP访问控制（CORS）](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS#附带身份凭证的请求)\n* [跨域资源共享 CORS 详解](http://www.ruanyifeng.com/blog/2016/04/cors.html)\n* [XDomainRequest object](https://msdn.microsoft.com/en-us/library/cc288060%28VS.85%29.aspx)\n\n\n\n\n\n\n\n\n\n","slug":"cors-cookie","published":1,"date":"2019-01-17T13:00:11.000Z","updated":"2019-01-17T13:00:11.000Z","comments":1,"photos":[],"link":"","_id":"cjr1en2mu0004ha9sx4efxnc8","content":"<p>因为 CORS（HTTP访问控制）的出现，跨域请求变的简单了很多，只需要服务器设置几个 response header 就可以轻松实现跨域访问。</p>\n<pre><code class=\"language-js\">// nodejs express 简单实现\napp.get('/cors_url', function(req, res) {\n    res.set({\n        'Access-Control-Allow-Origin': 'http://admin.ts.163.com:8184',\n        'Access-Control-Allow-Methods': '*',\n        'Access-Control-Allow-Headers': '*'\n    })\n\n    res.json({\n        code: 200,\n        msg: 'hello'\n    })\n})\n</code></pre>\n<p>在这样设置之后，请求可以正常发出和响应，但你会发现，此时并没有带上服务器域名下的 cookie。比如，在你使用网易邮箱登录了之后，你的浏览器中就会出现 domain 为 <code>.163.com</code> 的 cookie。如果我们在另一个域名（比如 <a href=\"http://my.com\" target=\"_blank\" rel=\"noopener\">my.com</a>）调用了 <a href=\"http://x1.163.com\" target=\"_blank\" rel=\"noopener\">x1.163.com</a> 域名下的接口，此时 request header 并不会带上 <code>.163.com</code> cookie。</p>\n<p>CORS 是可以做到这一点的，前后端进行相应的设置后，就可以发送 cookie。</p>\n<p>首先 ajax 中，在 send 方法前，设置 <code>xhr.withCredentials = true</code>，就可以向服务器发送 cookie。这时候如果发起请求，会得到一个错误：</p>\n<blockquote>\n<p>XMLHttpRequest cannot load <a href=\"http://x1.163.com:9003/cors_url?id=123456\" target=\"_blank\" rel=\"noopener\">http://x1.163.com:9003/cors_url?id=123456</a>. The value of the ‘Access-Control-Allow-Credentials’ header in the response is ‘’ which must be ‘true’ when the request’s credentials mode is ‘include’. Origin ‘<a href=\"http://you.com:9005\" target=\"_blank\" rel=\"noopener\">http://you.com:9005</a>’ is therefore not allowed access. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute.</p>\n</blockquote>\n<p>服务器也要进行相应的设置：</p>\n<pre><code class=\"language-js\">// nodejs express 简单实现\napp.get('/cors_url', function(req, res) {\n    res.set({\n        'Access-Control-Allow-Origin': 'http://admin.ts.163.com:8184',\n        'Access-Control-Allow-Methods': '*',\n        'Access-Control-Allow-Headers': '*',\n        'Access-Control-Allow-Credentials': true // 增加 Access-Control-Allow-Credentials \n    })\n\n    res.json({\n        code: 200,\n        msg: 'hello'\n    })\n})\n</code></pre>\n<p>此时发送请求， request header 多了 cookie 这个字段，同时服务器响应头中也可以通过 Set-Cookie 设置服务器域名下的 cookie。</p>\n<p><img src=\"/posts/assets/img/cors/header.jpg\" alt=\"cors-header\"></p>\n<p>对于 IE8 和 IE9，浏览器提供了 <code>window.XDomainRequest</code> 对象，方法和 XMLHttpRequest 类似。</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS#%E9%99%84%E5%B8%A6%E8%BA%AB%E4%BB%BD%E5%87%AD%E8%AF%81%E7%9A%84%E8%AF%B7%E6%B1%82\" target=\"_blank\" rel=\"noopener\">HTTP访问控制（CORS）</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2016/04/cors.html\" target=\"_blank\" rel=\"noopener\">跨域资源共享 CORS 详解</a></li>\n<li><a href=\"https://msdn.microsoft.com/en-us/library/cc288060%28VS.85%29.aspx\" target=\"_blank\" rel=\"noopener\">XDomainRequest object</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>因为 CORS（HTTP访问控制）的出现，跨域请求变的简单了很多，只需要服务器设置几个 response header 就可以轻松实现跨域访问。</p>\n<pre><code class=\"language-js\">// nodejs express 简单实现\napp.get('/cors_url', function(req, res) {\n    res.set({\n        'Access-Control-Allow-Origin': 'http://admin.ts.163.com:8184',\n        'Access-Control-Allow-Methods': '*',\n        'Access-Control-Allow-Headers': '*'\n    })\n\n    res.json({\n        code: 200,\n        msg: 'hello'\n    })\n})\n</code></pre>\n<p>在这样设置之后，请求可以正常发出和响应，但你会发现，此时并没有带上服务器域名下的 cookie。比如，在你使用网易邮箱登录了之后，你的浏览器中就会出现 domain 为 <code>.163.com</code> 的 cookie。如果我们在另一个域名（比如 <a href=\"http://my.com\" target=\"_blank\" rel=\"noopener\">my.com</a>）调用了 <a href=\"http://x1.163.com\" target=\"_blank\" rel=\"noopener\">x1.163.com</a> 域名下的接口，此时 request header 并不会带上 <code>.163.com</code> cookie。</p>\n<p>CORS 是可以做到这一点的，前后端进行相应的设置后，就可以发送 cookie。</p>\n<p>首先 ajax 中，在 send 方法前，设置 <code>xhr.withCredentials = true</code>，就可以向服务器发送 cookie。这时候如果发起请求，会得到一个错误：</p>\n<blockquote>\n<p>XMLHttpRequest cannot load <a href=\"http://x1.163.com:9003/cors_url?id=123456\" target=\"_blank\" rel=\"noopener\">http://x1.163.com:9003/cors_url?id=123456</a>. The value of the ‘Access-Control-Allow-Credentials’ header in the response is ‘’ which must be ‘true’ when the request’s credentials mode is ‘include’. Origin ‘<a href=\"http://you.com:9005\" target=\"_blank\" rel=\"noopener\">http://you.com:9005</a>’ is therefore not allowed access. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute.</p>\n</blockquote>\n<p>服务器也要进行相应的设置：</p>\n<pre><code class=\"language-js\">// nodejs express 简单实现\napp.get('/cors_url', function(req, res) {\n    res.set({\n        'Access-Control-Allow-Origin': 'http://admin.ts.163.com:8184',\n        'Access-Control-Allow-Methods': '*',\n        'Access-Control-Allow-Headers': '*',\n        'Access-Control-Allow-Credentials': true // 增加 Access-Control-Allow-Credentials \n    })\n\n    res.json({\n        code: 200,\n        msg: 'hello'\n    })\n})\n</code></pre>\n<p>此时发送请求， request header 多了 cookie 这个字段，同时服务器响应头中也可以通过 Set-Cookie 设置服务器域名下的 cookie。</p>\n<p><img src=\"/posts/assets/img/cors/header.jpg\" alt=\"cors-header\"></p>\n<p>对于 IE8 和 IE9，浏览器提供了 <code>window.XDomainRequest</code> 对象，方法和 XMLHttpRequest 类似。</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS#%E9%99%84%E5%B8%A6%E8%BA%AB%E4%BB%BD%E5%87%AD%E8%AF%81%E7%9A%84%E8%AF%B7%E6%B1%82\" target=\"_blank\" rel=\"noopener\">HTTP访问控制（CORS）</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2016/04/cors.html\" target=\"_blank\" rel=\"noopener\">跨域资源共享 CORS 详解</a></li>\n<li><a href=\"https://msdn.microsoft.com/en-us/library/cc288060%28VS.85%29.aspx\" target=\"_blank\" rel=\"noopener\">XDomainRequest object</a></li>\n</ul>\n"},{"layout":"post","title":"关于跨域","banner":"assets/img/cross-domain.jpg","_content":"\n跨域在 Web 开发中很常见，但浏览器并不想让你方便的跨域，必须要满足一定条件才可以。网上挺多的文章说这个事，有些文章讲的比较全面比较细致，比如[JavaScript跨域总结与解决办法](http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html)。本文呢不再去一一详述，只讲述自己工作中涉及到的以及自己的一些看法。\n\n## JSONP\n\njQuery 让很多的初学者（包括当年的我）以为 jsonp 是 ajax 的一种。jsonp 其实是利用了 JS 资源可以跨域的特性（和利用 `img.src` 类似）。\n\n前端动态创建 script 标签，发起一个 get 请求，和服务端约定好 callback 参数就是一个全局方法。当结果返回之后，就会执行这个全局方法，这里是 `jsonpCallback`。\n\n```js\nfunction jsonpCallback(data) {\n    console.log(data)\n}\n\nvar script = document.createElement('script')\nscript.src = 'http://localhost:9003/jsonp?callback=jsonpCallback'\ndocument.body.appendChild(script)\n```\n\n服务端代码：\n\n```js\napp.get('/jsonp', function(req, res) {\n    var callback = req.query.callback\n    res.send(callback + '(' + JSON.stringify({\n        code: 200,\n        msg: 'hello'\n    }) + ')')\n})\n```\n\njsonp 好处是支持性特别好，但只支持 get 请求。不过都到现在这个时代了，肯定要用 CORS 了。\n\n## HTTP访问控制(CORS)\n\n这个是从服务端控制可以跨域访问的域名，更加灵活。\n\n```js\napp.get('/cors_url', function(req, res) {\n\n    res.set({\n        'Access-Control-Allow-Origin': 'http://you.com:9005',\n        'Access-Control-Allow-Methods': '*',\n        'Access-Control-Allow-Headers': '*',\n        'Access-Control-Allow-Credentials': true\n    })\n\n    res.json({\n        code: 200,\n        msg: 'hello'\n    })\n})\n```\n\n并且还可以附带身份信息 cookies，更多可以看之前的文章：[跨域读写 Cookie](/2017/06/03/cors-cookie.html)。\n\n## iframe\n\niframe 作为前端唯一可以加载外部网页的标签，在跨域界有着不可取代的作用。\n\n### 根命名相同，子域名不同\n\n这时候需要设置父子页面的 document.domain 为统一根域名即可\n\n```js\ndocument.domain = 'rootDomain'\n```\n\n### 跨域读写存储\n\n比如 a.com 有些数据 sessionStorage 中，而这些数据在 a.com.hk 中使用，这时候需要 a.com 写入到 sessionStorage 后，把数据也写入到 b.com 的 sessionStorage 中。很明显 a.com 下不能直接写，这时候在 a.com 前一个 b.com 的 iframe，a.com 和 b.com 互相通知即可。\n\n互相通知直接使用 `window.postMessage`，IE8+都是支持的。\n\n```js\n// a.com\n// <iframe src=\"http://b.com/static/b.html\"></iframe>\n// 向 iframe 发送消息\nwindow.onload = function() {\n    // 切记要在 onload 之后\n    window.frames[0].postMessage('hello2', 'http://b.com');\n}\n\n// 接收 iframe 消息\nwindow.addEventListener('message', function(evt) {\n    sessionStorage.setItem('cors', evt.data)\n}, false);\n\n// ------------------\n\n// b.com\n// 接收消息\nwindow.addEventListener('message', function(evt) {\n    sessionStorage.setItem('cors', evt.data)\n}, false);\n\n// 向父窗口发送消息\nwindow.onload = function() {\n    parent.postMessage('hello1', 'http://a.com')\n}\n```\n\n## 总结\n\n对于异步请求，坚决的拥抱 CORS。跨域消息传输坚决的拥抱 postMessage。iframe 这个古老的标签依然充满力量。\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/cross-domain.md","raw":"\nlayout: post\ntitle: 关于跨域\nbanner: assets/img/cross-domain.jpg\ntags: \n- JavaScript\n- XHR\n---\n\n跨域在 Web 开发中很常见，但浏览器并不想让你方便的跨域，必须要满足一定条件才可以。网上挺多的文章说这个事，有些文章讲的比较全面比较细致，比如[JavaScript跨域总结与解决办法](http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html)。本文呢不再去一一详述，只讲述自己工作中涉及到的以及自己的一些看法。\n\n## JSONP\n\njQuery 让很多的初学者（包括当年的我）以为 jsonp 是 ajax 的一种。jsonp 其实是利用了 JS 资源可以跨域的特性（和利用 `img.src` 类似）。\n\n前端动态创建 script 标签，发起一个 get 请求，和服务端约定好 callback 参数就是一个全局方法。当结果返回之后，就会执行这个全局方法，这里是 `jsonpCallback`。\n\n```js\nfunction jsonpCallback(data) {\n    console.log(data)\n}\n\nvar script = document.createElement('script')\nscript.src = 'http://localhost:9003/jsonp?callback=jsonpCallback'\ndocument.body.appendChild(script)\n```\n\n服务端代码：\n\n```js\napp.get('/jsonp', function(req, res) {\n    var callback = req.query.callback\n    res.send(callback + '(' + JSON.stringify({\n        code: 200,\n        msg: 'hello'\n    }) + ')')\n})\n```\n\njsonp 好处是支持性特别好，但只支持 get 请求。不过都到现在这个时代了，肯定要用 CORS 了。\n\n## HTTP访问控制(CORS)\n\n这个是从服务端控制可以跨域访问的域名，更加灵活。\n\n```js\napp.get('/cors_url', function(req, res) {\n\n    res.set({\n        'Access-Control-Allow-Origin': 'http://you.com:9005',\n        'Access-Control-Allow-Methods': '*',\n        'Access-Control-Allow-Headers': '*',\n        'Access-Control-Allow-Credentials': true\n    })\n\n    res.json({\n        code: 200,\n        msg: 'hello'\n    })\n})\n```\n\n并且还可以附带身份信息 cookies，更多可以看之前的文章：[跨域读写 Cookie](/2017/06/03/cors-cookie.html)。\n\n## iframe\n\niframe 作为前端唯一可以加载外部网页的标签，在跨域界有着不可取代的作用。\n\n### 根命名相同，子域名不同\n\n这时候需要设置父子页面的 document.domain 为统一根域名即可\n\n```js\ndocument.domain = 'rootDomain'\n```\n\n### 跨域读写存储\n\n比如 a.com 有些数据 sessionStorage 中，而这些数据在 a.com.hk 中使用，这时候需要 a.com 写入到 sessionStorage 后，把数据也写入到 b.com 的 sessionStorage 中。很明显 a.com 下不能直接写，这时候在 a.com 前一个 b.com 的 iframe，a.com 和 b.com 互相通知即可。\n\n互相通知直接使用 `window.postMessage`，IE8+都是支持的。\n\n```js\n// a.com\n// <iframe src=\"http://b.com/static/b.html\"></iframe>\n// 向 iframe 发送消息\nwindow.onload = function() {\n    // 切记要在 onload 之后\n    window.frames[0].postMessage('hello2', 'http://b.com');\n}\n\n// 接收 iframe 消息\nwindow.addEventListener('message', function(evt) {\n    sessionStorage.setItem('cors', evt.data)\n}, false);\n\n// ------------------\n\n// b.com\n// 接收消息\nwindow.addEventListener('message', function(evt) {\n    sessionStorage.setItem('cors', evt.data)\n}, false);\n\n// 向父窗口发送消息\nwindow.onload = function() {\n    parent.postMessage('hello1', 'http://a.com')\n}\n```\n\n## 总结\n\n对于异步请求，坚决的拥抱 CORS。跨域消息传输坚决的拥抱 postMessage。iframe 这个古老的标签依然充满力量。\n\n\n\n\n\n\n\n\n\n\n","slug":"cross-domain","published":1,"date":"2019-01-17T13:00:11.000Z","updated":"2019-01-17T13:00:11.000Z","comments":1,"photos":[],"link":"","_id":"cjr1en2mv0005ha9sxd871iqj","content":"<p>跨域在 Web 开发中很常见，但浏览器并不想让你方便的跨域，必须要满足一定条件才可以。网上挺多的文章说这个事，有些文章讲的比较全面比较细致，比如<a href=\"http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html\" target=\"_blank\" rel=\"noopener\">JavaScript跨域总结与解决办法</a>。本文呢不再去一一详述，只讲述自己工作中涉及到的以及自己的一些看法。</p>\n<h2 id=\"jsonp\">JSONP</h2>\n<p>jQuery 让很多的初学者（包括当年的我）以为 jsonp 是 ajax 的一种。jsonp 其实是利用了 JS 资源可以跨域的特性（和利用 <code>img.src</code> 类似）。</p>\n<p>前端动态创建 script 标签，发起一个 get 请求，和服务端约定好 callback 参数就是一个全局方法。当结果返回之后，就会执行这个全局方法，这里是 <code>jsonpCallback</code>。</p>\n<pre><code class=\"language-js\">function jsonpCallback(data) {\n    console.log(data)\n}\n\nvar script = document.createElement('script')\nscript.src = 'http://localhost:9003/jsonp?callback=jsonpCallback'\ndocument.body.appendChild(script)\n</code></pre>\n<p>服务端代码：</p>\n<pre><code class=\"language-js\">app.get('/jsonp', function(req, res) {\n    var callback = req.query.callback\n    res.send(callback + '(' + JSON.stringify({\n        code: 200,\n        msg: 'hello'\n    }) + ')')\n})\n</code></pre>\n<p>jsonp 好处是支持性特别好，但只支持 get 请求。不过都到现在这个时代了，肯定要用 CORS 了。</p>\n<h2 id=\"http访问控制-cors\">HTTP访问控制(CORS)</h2>\n<p>这个是从服务端控制可以跨域访问的域名，更加灵活。</p>\n<pre><code class=\"language-js\">app.get('/cors_url', function(req, res) {\n\n    res.set({\n        'Access-Control-Allow-Origin': 'http://you.com:9005',\n        'Access-Control-Allow-Methods': '*',\n        'Access-Control-Allow-Headers': '*',\n        'Access-Control-Allow-Credentials': true\n    })\n\n    res.json({\n        code: 200,\n        msg: 'hello'\n    })\n})\n</code></pre>\n<p>并且还可以附带身份信息 cookies，更多可以看之前的文章：<a href=\"/2017/06/03/cors-cookie.html\">跨域读写 Cookie</a>。</p>\n<h2 id=\"iframe\">iframe</h2>\n<p>iframe 作为前端唯一可以加载外部网页的标签，在跨域界有着不可取代的作用。</p>\n<h3 id=\"根命名相同-子域名不同\">根命名相同，子域名不同</h3>\n<p>这时候需要设置父子页面的 document.domain 为统一根域名即可</p>\n<pre><code class=\"language-js\">document.domain = 'rootDomain'\n</code></pre>\n<h3 id=\"跨域读写存储\">跨域读写存储</h3>\n<p>比如 <a href=\"http://a.com\" target=\"_blank\" rel=\"noopener\">a.com</a> 有些数据 sessionStorage 中，而这些数据在 <a href=\"http://a.com.hk\" target=\"_blank\" rel=\"noopener\">a.com.hk</a> 中使用，这时候需要 <a href=\"http://a.com\" target=\"_blank\" rel=\"noopener\">a.com</a> 写入到 sessionStorage 后，把数据也写入到 <a href=\"http://b.com\" target=\"_blank\" rel=\"noopener\">b.com</a> 的 sessionStorage 中。很明显 <a href=\"http://a.com\" target=\"_blank\" rel=\"noopener\">a.com</a> 下不能直接写，这时候在 <a href=\"http://a.com\" target=\"_blank\" rel=\"noopener\">a.com</a> 前一个 <a href=\"http://b.com\" target=\"_blank\" rel=\"noopener\">b.com</a> 的 iframe，<a href=\"http://a.com\" target=\"_blank\" rel=\"noopener\">a.com</a> 和 <a href=\"http://b.com\" target=\"_blank\" rel=\"noopener\">b.com</a> 互相通知即可。</p>\n<p>互相通知直接使用 <code>window.postMessage</code>，IE8+都是支持的。</p>\n<pre><code class=\"language-js\">// a.com\n// &lt;iframe src=&quot;http://b.com/static/b.html&quot;&gt;&lt;/iframe&gt;\n// 向 iframe 发送消息\nwindow.onload = function() {\n    // 切记要在 onload 之后\n    window.frames[0].postMessage('hello2', 'http://b.com');\n}\n\n// 接收 iframe 消息\nwindow.addEventListener('message', function(evt) {\n    sessionStorage.setItem('cors', evt.data)\n}, false);\n\n// ------------------\n\n// b.com\n// 接收消息\nwindow.addEventListener('message', function(evt) {\n    sessionStorage.setItem('cors', evt.data)\n}, false);\n\n// 向父窗口发送消息\nwindow.onload = function() {\n    parent.postMessage('hello1', 'http://a.com')\n}\n</code></pre>\n<h2 id=\"总结\">总结</h2>\n<p>对于异步请求，坚决的拥抱 CORS。跨域消息传输坚决的拥抱 postMessage。iframe 这个古老的标签依然充满力量。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>跨域在 Web 开发中很常见，但浏览器并不想让你方便的跨域，必须要满足一定条件才可以。网上挺多的文章说这个事，有些文章讲的比较全面比较细致，比如<a href=\"http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html\" target=\"_blank\" rel=\"noopener\">JavaScript跨域总结与解决办法</a>。本文呢不再去一一详述，只讲述自己工作中涉及到的以及自己的一些看法。</p>\n<h2 id=\"jsonp\">JSONP</h2>\n<p>jQuery 让很多的初学者（包括当年的我）以为 jsonp 是 ajax 的一种。jsonp 其实是利用了 JS 资源可以跨域的特性（和利用 <code>img.src</code> 类似）。</p>\n<p>前端动态创建 script 标签，发起一个 get 请求，和服务端约定好 callback 参数就是一个全局方法。当结果返回之后，就会执行这个全局方法，这里是 <code>jsonpCallback</code>。</p>\n<pre><code class=\"language-js\">function jsonpCallback(data) {\n    console.log(data)\n}\n\nvar script = document.createElement('script')\nscript.src = 'http://localhost:9003/jsonp?callback=jsonpCallback'\ndocument.body.appendChild(script)\n</code></pre>\n<p>服务端代码：</p>\n<pre><code class=\"language-js\">app.get('/jsonp', function(req, res) {\n    var callback = req.query.callback\n    res.send(callback + '(' + JSON.stringify({\n        code: 200,\n        msg: 'hello'\n    }) + ')')\n})\n</code></pre>\n<p>jsonp 好处是支持性特别好，但只支持 get 请求。不过都到现在这个时代了，肯定要用 CORS 了。</p>\n<h2 id=\"http访问控制-cors\">HTTP访问控制(CORS)</h2>\n<p>这个是从服务端控制可以跨域访问的域名，更加灵活。</p>\n<pre><code class=\"language-js\">app.get('/cors_url', function(req, res) {\n\n    res.set({\n        'Access-Control-Allow-Origin': 'http://you.com:9005',\n        'Access-Control-Allow-Methods': '*',\n        'Access-Control-Allow-Headers': '*',\n        'Access-Control-Allow-Credentials': true\n    })\n\n    res.json({\n        code: 200,\n        msg: 'hello'\n    })\n})\n</code></pre>\n<p>并且还可以附带身份信息 cookies，更多可以看之前的文章：<a href=\"/2017/06/03/cors-cookie.html\">跨域读写 Cookie</a>。</p>\n<h2 id=\"iframe\">iframe</h2>\n<p>iframe 作为前端唯一可以加载外部网页的标签，在跨域界有着不可取代的作用。</p>\n<h3 id=\"根命名相同-子域名不同\">根命名相同，子域名不同</h3>\n<p>这时候需要设置父子页面的 document.domain 为统一根域名即可</p>\n<pre><code class=\"language-js\">document.domain = 'rootDomain'\n</code></pre>\n<h3 id=\"跨域读写存储\">跨域读写存储</h3>\n<p>比如 <a href=\"http://a.com\" target=\"_blank\" rel=\"noopener\">a.com</a> 有些数据 sessionStorage 中，而这些数据在 <a href=\"http://a.com.hk\" target=\"_blank\" rel=\"noopener\">a.com.hk</a> 中使用，这时候需要 <a href=\"http://a.com\" target=\"_blank\" rel=\"noopener\">a.com</a> 写入到 sessionStorage 后，把数据也写入到 <a href=\"http://b.com\" target=\"_blank\" rel=\"noopener\">b.com</a> 的 sessionStorage 中。很明显 <a href=\"http://a.com\" target=\"_blank\" rel=\"noopener\">a.com</a> 下不能直接写，这时候在 <a href=\"http://a.com\" target=\"_blank\" rel=\"noopener\">a.com</a> 前一个 <a href=\"http://b.com\" target=\"_blank\" rel=\"noopener\">b.com</a> 的 iframe，<a href=\"http://a.com\" target=\"_blank\" rel=\"noopener\">a.com</a> 和 <a href=\"http://b.com\" target=\"_blank\" rel=\"noopener\">b.com</a> 互相通知即可。</p>\n<p>互相通知直接使用 <code>window.postMessage</code>，IE8+都是支持的。</p>\n<pre><code class=\"language-js\">// a.com\n// &lt;iframe src=&quot;http://b.com/static/b.html&quot;&gt;&lt;/iframe&gt;\n// 向 iframe 发送消息\nwindow.onload = function() {\n    // 切记要在 onload 之后\n    window.frames[0].postMessage('hello2', 'http://b.com');\n}\n\n// 接收 iframe 消息\nwindow.addEventListener('message', function(evt) {\n    sessionStorage.setItem('cors', evt.data)\n}, false);\n\n// ------------------\n\n// b.com\n// 接收消息\nwindow.addEventListener('message', function(evt) {\n    sessionStorage.setItem('cors', evt.data)\n}, false);\n\n// 向父窗口发送消息\nwindow.onload = function() {\n    parent.postMessage('hello1', 'http://a.com')\n}\n</code></pre>\n<h2 id=\"总结\">总结</h2>\n<p>对于异步请求，坚决的拥抱 CORS。跨域消息传输坚决的拥抱 postMessage。iframe 这个古老的标签依然充满力量。</p>\n"},{"layout":"post","title":"Nodejs 微信公众号开发","banner":"assets/img/egg-wechat-mp.jpg","_content":"\n时至今日，微信公众号与前端息息相关，很难想象还有什么项目不搭微信这个车。本文对 Nodejs 微信公众号开发进行简单的介绍。\n\n**下面讲到基本都是认证过的公众号，请在测试时确认。**\n**代码使用 eggjs。**\n\n## 网页授权\n\n> 微信网页授权是通过OAuth2.0机制实现的\n\n现在基本所有的应用授权都是基于 OAuth2.0 实现的，大致流程如下图：\n\n![img](/posts/assets/img/20180910-164119.jpg)\n\n具体可以参考阮一峰的文章：[理解 OAuth2.0](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)。\n\n微信内基本流程和上图基本一致，文档：[https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1421140842](https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1421140842)。\n\n需要注意的是，这里获取的 `access_token` 只是用过网页授权之用，如果要做其他事情，则需要 `基础 access_token`。\n\n> 其他微信接口，需要通过基础支持中的“获取access_token”接口来获取到的普通access_token调用\n\n## 模板消息\n\n> 模板消息仅用于公众号向用户发送重要的服务通知，只能用于符合其要求的服务场景中，如信用卡刷卡通知，商品购买成功通知等。\n\n## JSSDK\n\n> 微信JS-SDK是微信公众平台 面向网页开发者提供的基于微信内的网页开发工具包。\n\n前端最常搭交道的就是这货了。\n\n一般前端对如果使用 wx 提供的 API 已经比较熟悉了，我们主要说下 wx.config 的几个参数是如何生成的。\n\n* 获取通用 access_token\n* 获取JS-SDK 票据：jsapi_ticket\n* 根据签名算法获取签名 signature\n\n获取签名需要上述三个步骤，jsapi_ticket 接口获取即可，签名有一个不太复杂算法：\n\n* 准备签名字段\n* 字典序排序&拼接字符串\n* 对排序字符串sha1，得到签名\n\n参与签名的字段有：jsapi_ticket、nonceStr、timestamp、url，这里注意下 nonceStr 在下面拼接字符串的时候变成了 noncestr，timestamp 使用的是精确到秒的时间戳。\n\n```js\nasync getSignature(ticket, noncestr, timestamp, url) {\n    const { ctx } = this;\n    const str = `jsapi_ticket=${ticket}&noncestr=${noncestr}&timestamp=${timestamp}&url=${url}`;\n    return ctx.helper.sha1(str);\n}\n```\n\n## 开发者模式\n\n开发者模式可以让开发者更好的控制微信公众号，不过有些不方便的是，你需要写代码控制原本可以手动配置的自定义菜单。原理大致如下图：\n\n![img](/posts/assets/img/20180910-165529.jpg)\n\n其他可以看文档的[入门指引](https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1472017492_58YV5)，很详细了。\n\n\n\n\n\n\n\n\n","source":"_posts/eggjs-wechat-mp.md","raw":"\nlayout: post\ntitle: Nodejs 微信公众号开发\nbanner: assets/img/egg-wechat-mp.jpg\ntags: nodejs\n---\n\n时至今日，微信公众号与前端息息相关，很难想象还有什么项目不搭微信这个车。本文对 Nodejs 微信公众号开发进行简单的介绍。\n\n**下面讲到基本都是认证过的公众号，请在测试时确认。**\n**代码使用 eggjs。**\n\n## 网页授权\n\n> 微信网页授权是通过OAuth2.0机制实现的\n\n现在基本所有的应用授权都是基于 OAuth2.0 实现的，大致流程如下图：\n\n![img](/posts/assets/img/20180910-164119.jpg)\n\n具体可以参考阮一峰的文章：[理解 OAuth2.0](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)。\n\n微信内基本流程和上图基本一致，文档：[https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1421140842](https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1421140842)。\n\n需要注意的是，这里获取的 `access_token` 只是用过网页授权之用，如果要做其他事情，则需要 `基础 access_token`。\n\n> 其他微信接口，需要通过基础支持中的“获取access_token”接口来获取到的普通access_token调用\n\n## 模板消息\n\n> 模板消息仅用于公众号向用户发送重要的服务通知，只能用于符合其要求的服务场景中，如信用卡刷卡通知，商品购买成功通知等。\n\n## JSSDK\n\n> 微信JS-SDK是微信公众平台 面向网页开发者提供的基于微信内的网页开发工具包。\n\n前端最常搭交道的就是这货了。\n\n一般前端对如果使用 wx 提供的 API 已经比较熟悉了，我们主要说下 wx.config 的几个参数是如何生成的。\n\n* 获取通用 access_token\n* 获取JS-SDK 票据：jsapi_ticket\n* 根据签名算法获取签名 signature\n\n获取签名需要上述三个步骤，jsapi_ticket 接口获取即可，签名有一个不太复杂算法：\n\n* 准备签名字段\n* 字典序排序&拼接字符串\n* 对排序字符串sha1，得到签名\n\n参与签名的字段有：jsapi_ticket、nonceStr、timestamp、url，这里注意下 nonceStr 在下面拼接字符串的时候变成了 noncestr，timestamp 使用的是精确到秒的时间戳。\n\n```js\nasync getSignature(ticket, noncestr, timestamp, url) {\n    const { ctx } = this;\n    const str = `jsapi_ticket=${ticket}&noncestr=${noncestr}&timestamp=${timestamp}&url=${url}`;\n    return ctx.helper.sha1(str);\n}\n```\n\n## 开发者模式\n\n开发者模式可以让开发者更好的控制微信公众号，不过有些不方便的是，你需要写代码控制原本可以手动配置的自定义菜单。原理大致如下图：\n\n![img](/posts/assets/img/20180910-165529.jpg)\n\n其他可以看文档的[入门指引](https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1472017492_58YV5)，很详细了。\n\n\n\n\n\n\n\n\n","slug":"eggjs-wechat-mp","published":1,"date":"2019-01-17T13:00:11.000Z","updated":"2019-01-17T13:00:11.000Z","comments":1,"photos":[],"link":"","_id":"cjr1en2mw0008ha9syl1fqrl7","content":"<p>时至今日，微信公众号与前端息息相关，很难想象还有什么项目不搭微信这个车。本文对 Nodejs 微信公众号开发进行简单的介绍。</p>\n<p><strong>下面讲到基本都是认证过的公众号，请在测试时确认。</strong><br>\n<strong>代码使用 eggjs。</strong></p>\n<h2 id=\"网页授权\">网页授权</h2>\n<blockquote>\n<p>微信网页授权是通过OAuth2.0机制实现的</p>\n</blockquote>\n<p>现在基本所有的应用授权都是基于 OAuth2.0 实现的，大致流程如下图：</p>\n<p><img src=\"/posts/assets/img/20180910-164119.jpg\" alt=\"img\"></p>\n<p>具体可以参考阮一峰的文章：<a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\" target=\"_blank\" rel=\"noopener\">理解 OAuth2.0</a>。</p>\n<p>微信内基本流程和上图基本一致，文档：<a href=\"https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140842\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140842</a>。</p>\n<p>需要注意的是，这里获取的 <code>access_token</code> 只是用过网页授权之用，如果要做其他事情，则需要 <code>基础 access_token</code>。</p>\n<blockquote>\n<p>其他微信接口，需要通过基础支持中的“获取access_token”接口来获取到的普通access_token调用</p>\n</blockquote>\n<h2 id=\"模板消息\">模板消息</h2>\n<blockquote>\n<p>模板消息仅用于公众号向用户发送重要的服务通知，只能用于符合其要求的服务场景中，如信用卡刷卡通知，商品购买成功通知等。</p>\n</blockquote>\n<h2 id=\"jssdk\">JSSDK</h2>\n<blockquote>\n<p>微信JS-SDK是微信公众平台 面向网页开发者提供的基于微信内的网页开发工具包。</p>\n</blockquote>\n<p>前端最常搭交道的就是这货了。</p>\n<p>一般前端对如果使用 wx 提供的 API 已经比较熟悉了，我们主要说下 wx.config 的几个参数是如何生成的。</p>\n<ul>\n<li>获取通用 access_token</li>\n<li>获取JS-SDK 票据：jsapi_ticket</li>\n<li>根据签名算法获取签名 signature</li>\n</ul>\n<p>获取签名需要上述三个步骤，jsapi_ticket 接口获取即可，签名有一个不太复杂算法：</p>\n<ul>\n<li>准备签名字段</li>\n<li>字典序排序&amp;拼接字符串</li>\n<li>对排序字符串sha1，得到签名</li>\n</ul>\n<p>参与签名的字段有：jsapi_ticket、nonceStr、timestamp、url，这里注意下 nonceStr 在下面拼接字符串的时候变成了 noncestr，timestamp 使用的是精确到秒的时间戳。</p>\n<pre><code class=\"language-js\">async getSignature(ticket, noncestr, timestamp, url) {\n    const { ctx } = this;\n    const str = `jsapi_ticket=${ticket}&amp;noncestr=${noncestr}&amp;timestamp=${timestamp}&amp;url=${url}`;\n    return ctx.helper.sha1(str);\n}\n</code></pre>\n<h2 id=\"开发者模式\">开发者模式</h2>\n<p>开发者模式可以让开发者更好的控制微信公众号，不过有些不方便的是，你需要写代码控制原本可以手动配置的自定义菜单。原理大致如下图：</p>\n<p><img src=\"/posts/assets/img/20180910-165529.jpg\" alt=\"img\"></p>\n<p>其他可以看文档的<a href=\"https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1472017492_58YV5\" target=\"_blank\" rel=\"noopener\">入门指引</a>，很详细了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>时至今日，微信公众号与前端息息相关，很难想象还有什么项目不搭微信这个车。本文对 Nodejs 微信公众号开发进行简单的介绍。</p>\n<p><strong>下面讲到基本都是认证过的公众号，请在测试时确认。</strong><br>\n<strong>代码使用 eggjs。</strong></p>\n<h2 id=\"网页授权\">网页授权</h2>\n<blockquote>\n<p>微信网页授权是通过OAuth2.0机制实现的</p>\n</blockquote>\n<p>现在基本所有的应用授权都是基于 OAuth2.0 实现的，大致流程如下图：</p>\n<p><img src=\"/posts/assets/img/20180910-164119.jpg\" alt=\"img\"></p>\n<p>具体可以参考阮一峰的文章：<a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\" target=\"_blank\" rel=\"noopener\">理解 OAuth2.0</a>。</p>\n<p>微信内基本流程和上图基本一致，文档：<a href=\"https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140842\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140842</a>。</p>\n<p>需要注意的是，这里获取的 <code>access_token</code> 只是用过网页授权之用，如果要做其他事情，则需要 <code>基础 access_token</code>。</p>\n<blockquote>\n<p>其他微信接口，需要通过基础支持中的“获取access_token”接口来获取到的普通access_token调用</p>\n</blockquote>\n<h2 id=\"模板消息\">模板消息</h2>\n<blockquote>\n<p>模板消息仅用于公众号向用户发送重要的服务通知，只能用于符合其要求的服务场景中，如信用卡刷卡通知，商品购买成功通知等。</p>\n</blockquote>\n<h2 id=\"jssdk\">JSSDK</h2>\n<blockquote>\n<p>微信JS-SDK是微信公众平台 面向网页开发者提供的基于微信内的网页开发工具包。</p>\n</blockquote>\n<p>前端最常搭交道的就是这货了。</p>\n<p>一般前端对如果使用 wx 提供的 API 已经比较熟悉了，我们主要说下 wx.config 的几个参数是如何生成的。</p>\n<ul>\n<li>获取通用 access_token</li>\n<li>获取JS-SDK 票据：jsapi_ticket</li>\n<li>根据签名算法获取签名 signature</li>\n</ul>\n<p>获取签名需要上述三个步骤，jsapi_ticket 接口获取即可，签名有一个不太复杂算法：</p>\n<ul>\n<li>准备签名字段</li>\n<li>字典序排序&amp;拼接字符串</li>\n<li>对排序字符串sha1，得到签名</li>\n</ul>\n<p>参与签名的字段有：jsapi_ticket、nonceStr、timestamp、url，这里注意下 nonceStr 在下面拼接字符串的时候变成了 noncestr，timestamp 使用的是精确到秒的时间戳。</p>\n<pre><code class=\"language-js\">async getSignature(ticket, noncestr, timestamp, url) {\n    const { ctx } = this;\n    const str = `jsapi_ticket=${ticket}&amp;noncestr=${noncestr}&amp;timestamp=${timestamp}&amp;url=${url}`;\n    return ctx.helper.sha1(str);\n}\n</code></pre>\n<h2 id=\"开发者模式\">开发者模式</h2>\n<p>开发者模式可以让开发者更好的控制微信公众号，不过有些不方便的是，你需要写代码控制原本可以手动配置的自定义菜单。原理大致如下图：</p>\n<p><img src=\"/posts/assets/img/20180910-165529.jpg\" alt=\"img\"></p>\n<p>其他可以看文档的<a href=\"https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1472017492_58YV5\" target=\"_blank\" rel=\"noopener\">入门指引</a>，很详细了。</p>\n"},{"layout":"post","title":"基于 Gulp 实现前端 Server","banner":"assets/img/gms_h.jpg","_content":"\nWeb开发是一个前后端合作的工作，但在开发的前期，双方约定好接口和数据后，就进入了各自的开发，这时候前端就需要有自己的开发环境，能够与最后和后端联调时后端提供的服务器能力接近，并且能够简化前端的工作流程，自动化完成相关任务。gulp就是这样一个工具，允许我们编写一系列的task，只需一个命令即可运行监听我们想执行的动作，并且gulp是基于编程的，给了我们更多自己动手的可能。\n\n那我们具体需要怎样的一套环境呢：\n* 根据 mock 数据和我们编写的模板输出html文件\n* 开启服务器调试，服务器具有输出接口的能力\n* css 预处理、字体图标制作等其他任务\n* 当测试设备过多时，在文件改动时能够自动刷新以方便查看页面\n\n这样，我们就可以不必依赖后端的环境和数据，在约定接口后各自开发，直到联调。除非有接口变动，基本不会出错，bug率大大降低。可以腾出更多的时间和大家交(shui)流(qun)技(dou)术(meizi)。\n\n## 后端模板支持\n\n虽然现在是 ajax 的天下了，不过有些数据还是通过页面同步输出的，这里我们使用的使用的是 FreeMarker 模板。前端是不能直接解析这些模板文件，所以调试起来就很麻烦。以前看过好多人先写  html 后缀的文件，然后造假的节点放到页面中，开始调样式，调试好后再改造成为后端模板文件。这样做效率很低，很难保证不会在复制粘贴中出错。\n\n所以需要找到编译的工具：[FMPP - FreeMarker-based file PreProcessor](http://fmpp.sourceforge.net/manual.html)，基于Freemarker的文件预处理器，就像我们用的CSS预处理器一样。通过他摆脱后端环境的束缚。总的来说: HTML = FTL + DATA. FMPP 就是通过数据和模板生成 html 文件, 和后端渲染输出是一个道理，可以做到和后端环境无差别。\n\n*注：使用前先下载并加入环境变量*\n\n## 异步接口支持\n\n之前结合FMPP只是解决了同步接口的问题，那对于异步接口，我们如何mock数据进行调试呢。这里引入了优秀而且简单的 [express]( http://expressjs.com/4x/api.html), 借助 express 强大的路由来实现前端模拟异步接口的功能。\n\n同时可以引入gulp-nodemon插件，在你修改了异步接口后，不必重启gulp，服务器会自动重启。\n\n## 其他 gulp 任务\n\ngulp 提供了许多有用的插件，可以串联起来完成很复杂的操作。我这里只写了mcss 和 iconfont 两个任务。\n\n## 如何使用\n\n### 填写配置\n\n```js\n\n/**\n * gulp-mock-server config\n */\n\nmodule.exports = {\n    // freemarker模板设置\n    // src 模板根路径\n    // mock mock数据路径\n    // dist 模板编译后的html路径\n    freemarker: {\n        src: './template',\n        mock: './_mock',\n        dist: './_dist'\n    },\n\n    // 路由和模板的映射\n    // 路由|模板名、数据（tdd）和编译后的html一一对应\n    // /user/list <-> /template/user/list.ftl <-> /mock/sync/user/list.tdd <-> /dist/user/list.html\n    router: {\n        '/': '/index.ftl',\n        '/index': '/index.ftl',\n        '/user/info': '/user/info.ftl'\n    },\n\n    // express服务器设置\n    server: {\n        root: __dirname,\n        port: 8088,\n        livereload: ['./src/javascript/**/*.js', './src/css/**/*.css']\n    },\n\n    // 样式\n    style: {\n        src: './src/mcss/',\n        dist: './src/css/'\n    },\n\n    // 图标字体\n    iconfont: {\n        src: './res/svg/*.svg',\n        dist: './res/fonts/',\n        cssTpl: './res/fonts/_icontpl.mcss',\n        cssName: 'iconfont.mcss',\n        fontName: 'myfont',\n        fontClass: 'myicon'\n    },\n\n    //...\n}\n```\n\n在这里重点关注 `router` 配置，为了和后端环境保证一致，需要配置和后端约定好的路由和路由对应的模板地址。当启动 express 服务器时，直接访问路由，就会去找对应的模板渲染的 html。\n\n如果有自己的扩展任务也建议将配置项配置在这里，然后在 `_gms/parseConfig.js` 中解析，完成其他任务。\n\n在填写完配置后，首先运行 `gulp init`，会根据 `freemarker` 项生成项目初始目录。\n\n### 运行 gulp 命令 \n\n```bash\ngulp \n```\n\n运行效果大致如图：\n\n![gms](/posts/assets/img/gms.jpg)\n\n\n## 总结\n\n这里只是实现了最简单的前端 Server 的功能，其实还有事情可做，比如接口管理、接口测试、文档管理、数据 Mock等等。现在有很多高大上的 Mock Server 了，比如网易的 [NEI](https://nei.netease.com/)。\n\n不过基于 Gulp 实现，可以很好的结合前端的一些自动化任务在里面，关注接口的同时也能同时处理其他事情，而且也很容易扩展，可以使用其他的后端模板，也可以使用其他插件来扩展前端任务。\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/gms.md","raw":"\nlayout: post\ntitle: 基于 Gulp 实现前端 Server\nbanner: assets/img/gms_h.jpg\ntags: gulp\n---\n\nWeb开发是一个前后端合作的工作，但在开发的前期，双方约定好接口和数据后，就进入了各自的开发，这时候前端就需要有自己的开发环境，能够与最后和后端联调时后端提供的服务器能力接近，并且能够简化前端的工作流程，自动化完成相关任务。gulp就是这样一个工具，允许我们编写一系列的task，只需一个命令即可运行监听我们想执行的动作，并且gulp是基于编程的，给了我们更多自己动手的可能。\n\n那我们具体需要怎样的一套环境呢：\n* 根据 mock 数据和我们编写的模板输出html文件\n* 开启服务器调试，服务器具有输出接口的能力\n* css 预处理、字体图标制作等其他任务\n* 当测试设备过多时，在文件改动时能够自动刷新以方便查看页面\n\n这样，我们就可以不必依赖后端的环境和数据，在约定接口后各自开发，直到联调。除非有接口变动，基本不会出错，bug率大大降低。可以腾出更多的时间和大家交(shui)流(qun)技(dou)术(meizi)。\n\n## 后端模板支持\n\n虽然现在是 ajax 的天下了，不过有些数据还是通过页面同步输出的，这里我们使用的使用的是 FreeMarker 模板。前端是不能直接解析这些模板文件，所以调试起来就很麻烦。以前看过好多人先写  html 后缀的文件，然后造假的节点放到页面中，开始调样式，调试好后再改造成为后端模板文件。这样做效率很低，很难保证不会在复制粘贴中出错。\n\n所以需要找到编译的工具：[FMPP - FreeMarker-based file PreProcessor](http://fmpp.sourceforge.net/manual.html)，基于Freemarker的文件预处理器，就像我们用的CSS预处理器一样。通过他摆脱后端环境的束缚。总的来说: HTML = FTL + DATA. FMPP 就是通过数据和模板生成 html 文件, 和后端渲染输出是一个道理，可以做到和后端环境无差别。\n\n*注：使用前先下载并加入环境变量*\n\n## 异步接口支持\n\n之前结合FMPP只是解决了同步接口的问题，那对于异步接口，我们如何mock数据进行调试呢。这里引入了优秀而且简单的 [express]( http://expressjs.com/4x/api.html), 借助 express 强大的路由来实现前端模拟异步接口的功能。\n\n同时可以引入gulp-nodemon插件，在你修改了异步接口后，不必重启gulp，服务器会自动重启。\n\n## 其他 gulp 任务\n\ngulp 提供了许多有用的插件，可以串联起来完成很复杂的操作。我这里只写了mcss 和 iconfont 两个任务。\n\n## 如何使用\n\n### 填写配置\n\n```js\n\n/**\n * gulp-mock-server config\n */\n\nmodule.exports = {\n    // freemarker模板设置\n    // src 模板根路径\n    // mock mock数据路径\n    // dist 模板编译后的html路径\n    freemarker: {\n        src: './template',\n        mock: './_mock',\n        dist: './_dist'\n    },\n\n    // 路由和模板的映射\n    // 路由|模板名、数据（tdd）和编译后的html一一对应\n    // /user/list <-> /template/user/list.ftl <-> /mock/sync/user/list.tdd <-> /dist/user/list.html\n    router: {\n        '/': '/index.ftl',\n        '/index': '/index.ftl',\n        '/user/info': '/user/info.ftl'\n    },\n\n    // express服务器设置\n    server: {\n        root: __dirname,\n        port: 8088,\n        livereload: ['./src/javascript/**/*.js', './src/css/**/*.css']\n    },\n\n    // 样式\n    style: {\n        src: './src/mcss/',\n        dist: './src/css/'\n    },\n\n    // 图标字体\n    iconfont: {\n        src: './res/svg/*.svg',\n        dist: './res/fonts/',\n        cssTpl: './res/fonts/_icontpl.mcss',\n        cssName: 'iconfont.mcss',\n        fontName: 'myfont',\n        fontClass: 'myicon'\n    },\n\n    //...\n}\n```\n\n在这里重点关注 `router` 配置，为了和后端环境保证一致，需要配置和后端约定好的路由和路由对应的模板地址。当启动 express 服务器时，直接访问路由，就会去找对应的模板渲染的 html。\n\n如果有自己的扩展任务也建议将配置项配置在这里，然后在 `_gms/parseConfig.js` 中解析，完成其他任务。\n\n在填写完配置后，首先运行 `gulp init`，会根据 `freemarker` 项生成项目初始目录。\n\n### 运行 gulp 命令 \n\n```bash\ngulp \n```\n\n运行效果大致如图：\n\n![gms](/posts/assets/img/gms.jpg)\n\n\n## 总结\n\n这里只是实现了最简单的前端 Server 的功能，其实还有事情可做，比如接口管理、接口测试、文档管理、数据 Mock等等。现在有很多高大上的 Mock Server 了，比如网易的 [NEI](https://nei.netease.com/)。\n\n不过基于 Gulp 实现，可以很好的结合前端的一些自动化任务在里面，关注接口的同时也能同时处理其他事情，而且也很容易扩展，可以使用其他的后端模板，也可以使用其他插件来扩展前端任务。\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"gms","published":1,"date":"2019-01-17T13:00:11.000Z","updated":"2019-01-17T13:00:11.000Z","comments":1,"photos":[],"link":"","_id":"cjr1en2my0009ha9sik46dgz4","content":"<p>Web开发是一个前后端合作的工作，但在开发的前期，双方约定好接口和数据后，就进入了各自的开发，这时候前端就需要有自己的开发环境，能够与最后和后端联调时后端提供的服务器能力接近，并且能够简化前端的工作流程，自动化完成相关任务。gulp就是这样一个工具，允许我们编写一系列的task，只需一个命令即可运行监听我们想执行的动作，并且gulp是基于编程的，给了我们更多自己动手的可能。</p>\n<p>那我们具体需要怎样的一套环境呢：</p>\n<ul>\n<li>根据 mock 数据和我们编写的模板输出html文件</li>\n<li>开启服务器调试，服务器具有输出接口的能力</li>\n<li>css 预处理、字体图标制作等其他任务</li>\n<li>当测试设备过多时，在文件改动时能够自动刷新以方便查看页面</li>\n</ul>\n<p>这样，我们就可以不必依赖后端的环境和数据，在约定接口后各自开发，直到联调。除非有接口变动，基本不会出错，bug率大大降低。可以腾出更多的时间和大家交(shui)流(qun)技(dou)术(meizi)。</p>\n<h2 id=\"后端模板支持\">后端模板支持</h2>\n<p>虽然现在是 ajax 的天下了，不过有些数据还是通过页面同步输出的，这里我们使用的使用的是 FreeMarker 模板。前端是不能直接解析这些模板文件，所以调试起来就很麻烦。以前看过好多人先写  html 后缀的文件，然后造假的节点放到页面中，开始调样式，调试好后再改造成为后端模板文件。这样做效率很低，很难保证不会在复制粘贴中出错。</p>\n<p>所以需要找到编译的工具：<a href=\"http://fmpp.sourceforge.net/manual.html\" target=\"_blank\" rel=\"noopener\">FMPP - FreeMarker-based file PreProcessor</a>，基于Freemarker的文件预处理器，就像我们用的CSS预处理器一样。通过他摆脱后端环境的束缚。总的来说: HTML = FTL + DATA. FMPP 就是通过数据和模板生成 html 文件, 和后端渲染输出是一个道理，可以做到和后端环境无差别。</p>\n<p><em>注：使用前先下载并加入环境变量</em></p>\n<h2 id=\"异步接口支持\">异步接口支持</h2>\n<p>之前结合FMPP只是解决了同步接口的问题，那对于异步接口，我们如何mock数据进行调试呢。这里引入了优秀而且简单的 <a href=\"http://expressjs.com/4x/api.html\" target=\"_blank\" rel=\"noopener\">express</a>, 借助 express 强大的路由来实现前端模拟异步接口的功能。</p>\n<p>同时可以引入gulp-nodemon插件，在你修改了异步接口后，不必重启gulp，服务器会自动重启。</p>\n<h2 id=\"其他-gulp-任务\">其他 gulp 任务</h2>\n<p>gulp 提供了许多有用的插件，可以串联起来完成很复杂的操作。我这里只写了mcss 和 iconfont 两个任务。</p>\n<h2 id=\"如何使用\">如何使用</h2>\n<h3 id=\"填写配置\">填写配置</h3>\n<pre><code class=\"language-js\">\n/**\n * gulp-mock-server config\n */\n\nmodule.exports = {\n    // freemarker模板设置\n    // src 模板根路径\n    // mock mock数据路径\n    // dist 模板编译后的html路径\n    freemarker: {\n        src: './template',\n        mock: './_mock',\n        dist: './_dist'\n    },\n\n    // 路由和模板的映射\n    // 路由|模板名、数据（tdd）和编译后的html一一对应\n    // /user/list &lt;-&gt; /template/user/list.ftl &lt;-&gt; /mock/sync/user/list.tdd &lt;-&gt; /dist/user/list.html\n    router: {\n        '/': '/index.ftl',\n        '/index': '/index.ftl',\n        '/user/info': '/user/info.ftl'\n    },\n\n    // express服务器设置\n    server: {\n        root: __dirname,\n        port: 8088,\n        livereload: ['./src/javascript/**/*.js', './src/css/**/*.css']\n    },\n\n    // 样式\n    style: {\n        src: './src/mcss/',\n        dist: './src/css/'\n    },\n\n    // 图标字体\n    iconfont: {\n        src: './res/svg/*.svg',\n        dist: './res/fonts/',\n        cssTpl: './res/fonts/_icontpl.mcss',\n        cssName: 'iconfont.mcss',\n        fontName: 'myfont',\n        fontClass: 'myicon'\n    },\n\n    //...\n}\n</code></pre>\n<p>在这里重点关注 <code>router</code> 配置，为了和后端环境保证一致，需要配置和后端约定好的路由和路由对应的模板地址。当启动 express 服务器时，直接访问路由，就会去找对应的模板渲染的 html。</p>\n<p>如果有自己的扩展任务也建议将配置项配置在这里，然后在 <code>_gms/parseConfig.js</code> 中解析，完成其他任务。</p>\n<p>在填写完配置后，首先运行 <code>gulp init</code>，会根据 <code>freemarker</code> 项生成项目初始目录。</p>\n<h3 id=\"运行-gulp-命令\">运行 gulp 命令</h3>\n<pre><code class=\"language-bash\">gulp \n</code></pre>\n<p>运行效果大致如图：</p>\n<p><img src=\"/posts/assets/img/gms.jpg\" alt=\"gms\"></p>\n<h2 id=\"总结\">总结</h2>\n<p>这里只是实现了最简单的前端 Server 的功能，其实还有事情可做，比如接口管理、接口测试、文档管理、数据 Mock等等。现在有很多高大上的 Mock Server 了，比如网易的 <a href=\"https://nei.netease.com/\" target=\"_blank\" rel=\"noopener\">NEI</a>。</p>\n<p>不过基于 Gulp 实现，可以很好的结合前端的一些自动化任务在里面，关注接口的同时也能同时处理其他事情，而且也很容易扩展，可以使用其他的后端模板，也可以使用其他插件来扩展前端任务。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Web开发是一个前后端合作的工作，但在开发的前期，双方约定好接口和数据后，就进入了各自的开发，这时候前端就需要有自己的开发环境，能够与最后和后端联调时后端提供的服务器能力接近，并且能够简化前端的工作流程，自动化完成相关任务。gulp就是这样一个工具，允许我们编写一系列的task，只需一个命令即可运行监听我们想执行的动作，并且gulp是基于编程的，给了我们更多自己动手的可能。</p>\n<p>那我们具体需要怎样的一套环境呢：</p>\n<ul>\n<li>根据 mock 数据和我们编写的模板输出html文件</li>\n<li>开启服务器调试，服务器具有输出接口的能力</li>\n<li>css 预处理、字体图标制作等其他任务</li>\n<li>当测试设备过多时，在文件改动时能够自动刷新以方便查看页面</li>\n</ul>\n<p>这样，我们就可以不必依赖后端的环境和数据，在约定接口后各自开发，直到联调。除非有接口变动，基本不会出错，bug率大大降低。可以腾出更多的时间和大家交(shui)流(qun)技(dou)术(meizi)。</p>\n<h2 id=\"后端模板支持\">后端模板支持</h2>\n<p>虽然现在是 ajax 的天下了，不过有些数据还是通过页面同步输出的，这里我们使用的使用的是 FreeMarker 模板。前端是不能直接解析这些模板文件，所以调试起来就很麻烦。以前看过好多人先写  html 后缀的文件，然后造假的节点放到页面中，开始调样式，调试好后再改造成为后端模板文件。这样做效率很低，很难保证不会在复制粘贴中出错。</p>\n<p>所以需要找到编译的工具：<a href=\"http://fmpp.sourceforge.net/manual.html\" target=\"_blank\" rel=\"noopener\">FMPP - FreeMarker-based file PreProcessor</a>，基于Freemarker的文件预处理器，就像我们用的CSS预处理器一样。通过他摆脱后端环境的束缚。总的来说: HTML = FTL + DATA. FMPP 就是通过数据和模板生成 html 文件, 和后端渲染输出是一个道理，可以做到和后端环境无差别。</p>\n<p><em>注：使用前先下载并加入环境变量</em></p>\n<h2 id=\"异步接口支持\">异步接口支持</h2>\n<p>之前结合FMPP只是解决了同步接口的问题，那对于异步接口，我们如何mock数据进行调试呢。这里引入了优秀而且简单的 <a href=\"http://expressjs.com/4x/api.html\" target=\"_blank\" rel=\"noopener\">express</a>, 借助 express 强大的路由来实现前端模拟异步接口的功能。</p>\n<p>同时可以引入gulp-nodemon插件，在你修改了异步接口后，不必重启gulp，服务器会自动重启。</p>\n<h2 id=\"其他-gulp-任务\">其他 gulp 任务</h2>\n<p>gulp 提供了许多有用的插件，可以串联起来完成很复杂的操作。我这里只写了mcss 和 iconfont 两个任务。</p>\n<h2 id=\"如何使用\">如何使用</h2>\n<h3 id=\"填写配置\">填写配置</h3>\n<pre><code class=\"language-js\">\n/**\n * gulp-mock-server config\n */\n\nmodule.exports = {\n    // freemarker模板设置\n    // src 模板根路径\n    // mock mock数据路径\n    // dist 模板编译后的html路径\n    freemarker: {\n        src: './template',\n        mock: './_mock',\n        dist: './_dist'\n    },\n\n    // 路由和模板的映射\n    // 路由|模板名、数据（tdd）和编译后的html一一对应\n    // /user/list &lt;-&gt; /template/user/list.ftl &lt;-&gt; /mock/sync/user/list.tdd &lt;-&gt; /dist/user/list.html\n    router: {\n        '/': '/index.ftl',\n        '/index': '/index.ftl',\n        '/user/info': '/user/info.ftl'\n    },\n\n    // express服务器设置\n    server: {\n        root: __dirname,\n        port: 8088,\n        livereload: ['./src/javascript/**/*.js', './src/css/**/*.css']\n    },\n\n    // 样式\n    style: {\n        src: './src/mcss/',\n        dist: './src/css/'\n    },\n\n    // 图标字体\n    iconfont: {\n        src: './res/svg/*.svg',\n        dist: './res/fonts/',\n        cssTpl: './res/fonts/_icontpl.mcss',\n        cssName: 'iconfont.mcss',\n        fontName: 'myfont',\n        fontClass: 'myicon'\n    },\n\n    //...\n}\n</code></pre>\n<p>在这里重点关注 <code>router</code> 配置，为了和后端环境保证一致，需要配置和后端约定好的路由和路由对应的模板地址。当启动 express 服务器时，直接访问路由，就会去找对应的模板渲染的 html。</p>\n<p>如果有自己的扩展任务也建议将配置项配置在这里，然后在 <code>_gms/parseConfig.js</code> 中解析，完成其他任务。</p>\n<p>在填写完配置后，首先运行 <code>gulp init</code>，会根据 <code>freemarker</code> 项生成项目初始目录。</p>\n<h3 id=\"运行-gulp-命令\">运行 gulp 命令</h3>\n<pre><code class=\"language-bash\">gulp \n</code></pre>\n<p>运行效果大致如图：</p>\n<p><img src=\"/posts/assets/img/gms.jpg\" alt=\"gms\"></p>\n<h2 id=\"总结\">总结</h2>\n<p>这里只是实现了最简单的前端 Server 的功能，其实还有事情可做，比如接口管理、接口测试、文档管理、数据 Mock等等。现在有很多高大上的 Mock Server 了，比如网易的 <a href=\"https://nei.netease.com/\" target=\"_blank\" rel=\"noopener\">NEI</a>。</p>\n<p>不过基于 Gulp 实现，可以很好的结合前端的一些自动化任务在里面，关注接口的同时也能同时处理其他事情，而且也很容易扩展，可以使用其他的后端模板，也可以使用其他插件来扩展前端任务。</p>\n"},{"layout":"post","title":"JavaScript 中的 this","banner":"assets/img/javascript-this.jpeg","date":"2017-09-21T12:04:00.000Z","_content":"\nJavaScript中 的 this 是一个很神奇的存在，要确定 this 到底指向的谁并不简单，最近拜读了你不知道的 JavaScript，书中完整了讨论了各种情况。\n\n**this** 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。**this** 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。\n\n当一个函数被调用时，会创建一个活动记录(有时候也称为执行上下文)。这个记录会包含函数在哪里被调用(调用栈)、函数的调用方法、传入的参数等信息。this 就是记录的其中一个属性，会在函数执行的过程中用到。\n\n所以说对于 **this** 来说，在哪里被调用和如何被调用会起到决定性的作用。\n\n## 默认情况\n\n默认情况下，函数在全局被调用，此时的 this 默认指向 window（global)。严格模式下 this 绑定到 undefined。此时的严格模式特指函数内的严格模式，与调用处是否严格模式无关。\n\n```js\nfunction foo() { \n    console.log( this.a );\n}\nvar a = 2; \nfoo(); // 2\n\n// 严格模式下\nfunction foo() { \n    \"use strict\";\n    console.log( this.a );\n}\nvar a = 2;\nfoo(); // TypeError: this is undefined\n```\n\n\n## 隐式绑定\n\n此时需要考虑函数调用位置的上下文对象。\n\n```js\nfunction foo() { \n    console.log( this.a );\n}\nvar obj = { \n    a: 2,\n    foo: foo \n};\n// 使用 obj 上下文来引用函数\nobj.foo(); // 2\n```\n\n对象属性引用链中只有最顶层或者说最后一层会影响调用位置：\n\n```js\n\nfunction foo() { \n    console.log( this.a );\n}\nvar obj2 = { \n    a: 42,\n    foo: foo \n};\nvar obj1 = { \n    a: 2,\n    obj2: obj2 \n};\n// 使用 obj2 上下文来引用函数\nobj1.obj2.foo(); // 42\n```\n\n\n### 绑定丢失\n\n```js\nfunction foo() { \n    console.log( this.a );\n}\nvar obj = { \n    a: 2,\n    foo: foo \n};\n\n// 虽然 bar 是 obj.foo 的一个引用，但是实际上，它引用的是 foo 函数本身，因此此时的 bar() \n// 其实是一个不带任何修饰的函数调用，因此应用了默认绑定。\nvar bar = obj.foo; // 函数别名!\nvar a = \"oops, global\"; // a 是全局对象的属性 \nbar(); // \"oops, global\"\n```\n\n另外一种情况是回调函数，不论是自己创建还是 JS 内置的像 setTimeout 这些方法，所以我们常常使用 `var _this = this` 来获得 this 的引用。\n\n```js\n\n// 回调函数常常会改变 this\nfunction foo() { \n    console.log( this.a );\n}\nfunction doFoo(fn) {\n    // fn 其实引用的是 foo \n    fn(); // <-- 调用位置!\n}\nvar obj = { \n    a: 2,\n    foo: foo \n};\nvar a = \"oops, global\"; // a 是全局对象的属性 \ndoFoo( obj.foo ); // \"oops, global\"\n\n// 内置函数\n\nfunction foo() { \n    console.log( this.a );\n}\n\nvar obj = { \n    a: 2,\n    foo: foo \n};\nvar a = \"oops, global\"; // a 是全局对象的属性 \nsetTimeout( obj.foo, 100 ); // \"oops, global\"\n```\n\n## 显示绑定\n\n显式绑定即通过 **call** 或者 **apply** 改变 this 的指向。\n\n```js\nfunction foo() { \n    console.log( this.a );\n}\nvar obj = { \n    a:2\n};\nfoo.call( obj ); // 2\n```\n\n## 硬绑定\n\n硬绑定即：`Function.prototype.bind`，在函数 bind 之后，此后再 apply、call、bind 都不会改变绑定。\n\n比如 Array.prototype.forEach 等函数最后一个参数即绑定 this。\n\n## new 绑定\n\n```js\nfunction foo(a) { \n   this.a = a;\n}\nvar bar = new foo(2); \nconsole.log( bar.a ); // 2\n```\n\n几种绑定的优先级：**new 绑定 > 硬绑定 > 显示绑定 > 隐式绑定**。\n\n## 间接绑定\n\n一种比较特殊的情况：`(p.foo = o.foo)`这个赋值操作返回的是对 foo 的引用，执行的是默认绑定。\n\n```js\nfunction foo() { \n    console.log( this.a );\n}\n\nvar a = 2; \nvar o = { a: 3, foo: foo }; \nvar p = { a: 4 };\no.foo(); // 3\n(p.foo = o.foo)(); // 2\np.foo() // 4\n```\n\n## ES6 的箭头函数\n\n箭头函数是一种不同的 this 的机制，根据外层的作用域确定 this 指向，取代 `var self = this`的写法，和 bind 一样，此后再次调用 call、apply、bind this 指向不会改变。\n\n```js\nfunction foo() { \n    setTimeout(() => {\n    // 这里的 this 在此法上继承自 foo()\n        console.log( this.a );\n    }, 100);\n}\nvar obj = { \n    a: 2\n};\nfoo.call( obj ); // 2\n```\n\n\n\n\n\n\n\n","source":"_posts/javaScript-this.md","raw":"\nlayout: post\ntitle: JavaScript 中的 this\nbanner: assets/img/javascript-this.jpeg\ndate: 2017-9-21 20:04\ntags:\n- javascript\n---\n\nJavaScript中 的 this 是一个很神奇的存在，要确定 this 到底指向的谁并不简单，最近拜读了你不知道的 JavaScript，书中完整了讨论了各种情况。\n\n**this** 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。**this** 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。\n\n当一个函数被调用时，会创建一个活动记录(有时候也称为执行上下文)。这个记录会包含函数在哪里被调用(调用栈)、函数的调用方法、传入的参数等信息。this 就是记录的其中一个属性，会在函数执行的过程中用到。\n\n所以说对于 **this** 来说，在哪里被调用和如何被调用会起到决定性的作用。\n\n## 默认情况\n\n默认情况下，函数在全局被调用，此时的 this 默认指向 window（global)。严格模式下 this 绑定到 undefined。此时的严格模式特指函数内的严格模式，与调用处是否严格模式无关。\n\n```js\nfunction foo() { \n    console.log( this.a );\n}\nvar a = 2; \nfoo(); // 2\n\n// 严格模式下\nfunction foo() { \n    \"use strict\";\n    console.log( this.a );\n}\nvar a = 2;\nfoo(); // TypeError: this is undefined\n```\n\n\n## 隐式绑定\n\n此时需要考虑函数调用位置的上下文对象。\n\n```js\nfunction foo() { \n    console.log( this.a );\n}\nvar obj = { \n    a: 2,\n    foo: foo \n};\n// 使用 obj 上下文来引用函数\nobj.foo(); // 2\n```\n\n对象属性引用链中只有最顶层或者说最后一层会影响调用位置：\n\n```js\n\nfunction foo() { \n    console.log( this.a );\n}\nvar obj2 = { \n    a: 42,\n    foo: foo \n};\nvar obj1 = { \n    a: 2,\n    obj2: obj2 \n};\n// 使用 obj2 上下文来引用函数\nobj1.obj2.foo(); // 42\n```\n\n\n### 绑定丢失\n\n```js\nfunction foo() { \n    console.log( this.a );\n}\nvar obj = { \n    a: 2,\n    foo: foo \n};\n\n// 虽然 bar 是 obj.foo 的一个引用，但是实际上，它引用的是 foo 函数本身，因此此时的 bar() \n// 其实是一个不带任何修饰的函数调用，因此应用了默认绑定。\nvar bar = obj.foo; // 函数别名!\nvar a = \"oops, global\"; // a 是全局对象的属性 \nbar(); // \"oops, global\"\n```\n\n另外一种情况是回调函数，不论是自己创建还是 JS 内置的像 setTimeout 这些方法，所以我们常常使用 `var _this = this` 来获得 this 的引用。\n\n```js\n\n// 回调函数常常会改变 this\nfunction foo() { \n    console.log( this.a );\n}\nfunction doFoo(fn) {\n    // fn 其实引用的是 foo \n    fn(); // <-- 调用位置!\n}\nvar obj = { \n    a: 2,\n    foo: foo \n};\nvar a = \"oops, global\"; // a 是全局对象的属性 \ndoFoo( obj.foo ); // \"oops, global\"\n\n// 内置函数\n\nfunction foo() { \n    console.log( this.a );\n}\n\nvar obj = { \n    a: 2,\n    foo: foo \n};\nvar a = \"oops, global\"; // a 是全局对象的属性 \nsetTimeout( obj.foo, 100 ); // \"oops, global\"\n```\n\n## 显示绑定\n\n显式绑定即通过 **call** 或者 **apply** 改变 this 的指向。\n\n```js\nfunction foo() { \n    console.log( this.a );\n}\nvar obj = { \n    a:2\n};\nfoo.call( obj ); // 2\n```\n\n## 硬绑定\n\n硬绑定即：`Function.prototype.bind`，在函数 bind 之后，此后再 apply、call、bind 都不会改变绑定。\n\n比如 Array.prototype.forEach 等函数最后一个参数即绑定 this。\n\n## new 绑定\n\n```js\nfunction foo(a) { \n   this.a = a;\n}\nvar bar = new foo(2); \nconsole.log( bar.a ); // 2\n```\n\n几种绑定的优先级：**new 绑定 > 硬绑定 > 显示绑定 > 隐式绑定**。\n\n## 间接绑定\n\n一种比较特殊的情况：`(p.foo = o.foo)`这个赋值操作返回的是对 foo 的引用，执行的是默认绑定。\n\n```js\nfunction foo() { \n    console.log( this.a );\n}\n\nvar a = 2; \nvar o = { a: 3, foo: foo }; \nvar p = { a: 4 };\no.foo(); // 3\n(p.foo = o.foo)(); // 2\np.foo() // 4\n```\n\n## ES6 的箭头函数\n\n箭头函数是一种不同的 this 的机制，根据外层的作用域确定 this 指向，取代 `var self = this`的写法，和 bind 一样，此后再次调用 call、apply、bind this 指向不会改变。\n\n```js\nfunction foo() { \n    setTimeout(() => {\n    // 这里的 this 在此法上继承自 foo()\n        console.log( this.a );\n    }, 100);\n}\nvar obj = { \n    a: 2\n};\nfoo.call( obj ); // 2\n```\n\n\n\n\n\n\n\n","slug":"javaScript-this","published":1,"updated":"2019-01-17T13:00:11.000Z","comments":1,"photos":[],"link":"","_id":"cjr1en2mz000bha9sy4wo8mhk","content":"<p>JavaScript中 的 this 是一个很神奇的存在，要确定 this 到底指向的谁并不简单，最近拜读了你不知道的 JavaScript，书中完整了讨论了各种情况。</p>\n<p><strong>this</strong> 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。<strong>this</strong> 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。</p>\n<p>当一个函数被调用时，会创建一个活动记录(有时候也称为执行上下文)。这个记录会包含函数在哪里被调用(调用栈)、函数的调用方法、传入的参数等信息。this 就是记录的其中一个属性，会在函数执行的过程中用到。</p>\n<p>所以说对于 <strong>this</strong> 来说，在哪里被调用和如何被调用会起到决定性的作用。</p>\n<h2 id=\"默认情况\">默认情况</h2>\n<p>默认情况下，函数在全局被调用，此时的 this 默认指向 window（global)。严格模式下 this 绑定到 undefined。此时的严格模式特指函数内的严格模式，与调用处是否严格模式无关。</p>\n<pre><code class=\"language-js\">function foo() { \n    console.log( this.a );\n}\nvar a = 2; \nfoo(); // 2\n\n// 严格模式下\nfunction foo() { \n    &quot;use strict&quot;;\n    console.log( this.a );\n}\nvar a = 2;\nfoo(); // TypeError: this is undefined\n</code></pre>\n<h2 id=\"隐式绑定\">隐式绑定</h2>\n<p>此时需要考虑函数调用位置的上下文对象。</p>\n<pre><code class=\"language-js\">function foo() { \n    console.log( this.a );\n}\nvar obj = { \n    a: 2,\n    foo: foo \n};\n// 使用 obj 上下文来引用函数\nobj.foo(); // 2\n</code></pre>\n<p>对象属性引用链中只有最顶层或者说最后一层会影响调用位置：</p>\n<pre><code class=\"language-js\">\nfunction foo() { \n    console.log( this.a );\n}\nvar obj2 = { \n    a: 42,\n    foo: foo \n};\nvar obj1 = { \n    a: 2,\n    obj2: obj2 \n};\n// 使用 obj2 上下文来引用函数\nobj1.obj2.foo(); // 42\n</code></pre>\n<h3 id=\"绑定丢失\">绑定丢失</h3>\n<pre><code class=\"language-js\">function foo() { \n    console.log( this.a );\n}\nvar obj = { \n    a: 2,\n    foo: foo \n};\n\n// 虽然 bar 是 obj.foo 的一个引用，但是实际上，它引用的是 foo 函数本身，因此此时的 bar() \n// 其实是一个不带任何修饰的函数调用，因此应用了默认绑定。\nvar bar = obj.foo; // 函数别名!\nvar a = &quot;oops, global&quot;; // a 是全局对象的属性 \nbar(); // &quot;oops, global&quot;\n</code></pre>\n<p>另外一种情况是回调函数，不论是自己创建还是 JS 内置的像 setTimeout 这些方法，所以我们常常使用 <code>var _this = this</code> 来获得 this 的引用。</p>\n<pre><code class=\"language-js\">\n// 回调函数常常会改变 this\nfunction foo() { \n    console.log( this.a );\n}\nfunction doFoo(fn) {\n    // fn 其实引用的是 foo \n    fn(); // &lt;-- 调用位置!\n}\nvar obj = { \n    a: 2,\n    foo: foo \n};\nvar a = &quot;oops, global&quot;; // a 是全局对象的属性 \ndoFoo( obj.foo ); // &quot;oops, global&quot;\n\n// 内置函数\n\nfunction foo() { \n    console.log( this.a );\n}\n\nvar obj = { \n    a: 2,\n    foo: foo \n};\nvar a = &quot;oops, global&quot;; // a 是全局对象的属性 \nsetTimeout( obj.foo, 100 ); // &quot;oops, global&quot;\n</code></pre>\n<h2 id=\"显示绑定\">显示绑定</h2>\n<p>显式绑定即通过 <strong>call</strong> 或者 <strong>apply</strong> 改变 this 的指向。</p>\n<pre><code class=\"language-js\">function foo() { \n    console.log( this.a );\n}\nvar obj = { \n    a:2\n};\nfoo.call( obj ); // 2\n</code></pre>\n<h2 id=\"硬绑定\">硬绑定</h2>\n<p>硬绑定即：<code>Function.prototype.bind</code>，在函数 bind 之后，此后再 apply、call、bind 都不会改变绑定。</p>\n<p>比如 Array.prototype.forEach 等函数最后一个参数即绑定 this。</p>\n<h2 id=\"new-绑定\">new 绑定</h2>\n<pre><code class=\"language-js\">function foo(a) { \n   this.a = a;\n}\nvar bar = new foo(2); \nconsole.log( bar.a ); // 2\n</code></pre>\n<p>几种绑定的优先级：<strong>new 绑定 &gt; 硬绑定 &gt; 显示绑定 &gt; 隐式绑定</strong>。</p>\n<h2 id=\"间接绑定\">间接绑定</h2>\n<p>一种比较特殊的情况：<code>(p.foo = o.foo)</code>这个赋值操作返回的是对 foo 的引用，执行的是默认绑定。</p>\n<pre><code class=\"language-js\">function foo() { \n    console.log( this.a );\n}\n\nvar a = 2; \nvar o = { a: 3, foo: foo }; \nvar p = { a: 4 };\no.foo(); // 3\n(p.foo = o.foo)(); // 2\np.foo() // 4\n</code></pre>\n<h2 id=\"es6-的箭头函数\">ES6 的箭头函数</h2>\n<p>箭头函数是一种不同的 this 的机制，根据外层的作用域确定 this 指向，取代 <code>var self = this</code>的写法，和 bind 一样，此后再次调用 call、apply、bind this 指向不会改变。</p>\n<pre><code class=\"language-js\">function foo() { \n    setTimeout(() =&gt; {\n    // 这里的 this 在此法上继承自 foo()\n        console.log( this.a );\n    }, 100);\n}\nvar obj = { \n    a: 2\n};\nfoo.call( obj ); // 2\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>JavaScript中 的 this 是一个很神奇的存在，要确定 this 到底指向的谁并不简单，最近拜读了你不知道的 JavaScript，书中完整了讨论了各种情况。</p>\n<p><strong>this</strong> 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。<strong>this</strong> 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。</p>\n<p>当一个函数被调用时，会创建一个活动记录(有时候也称为执行上下文)。这个记录会包含函数在哪里被调用(调用栈)、函数的调用方法、传入的参数等信息。this 就是记录的其中一个属性，会在函数执行的过程中用到。</p>\n<p>所以说对于 <strong>this</strong> 来说，在哪里被调用和如何被调用会起到决定性的作用。</p>\n<h2 id=\"默认情况\">默认情况</h2>\n<p>默认情况下，函数在全局被调用，此时的 this 默认指向 window（global)。严格模式下 this 绑定到 undefined。此时的严格模式特指函数内的严格模式，与调用处是否严格模式无关。</p>\n<pre><code class=\"language-js\">function foo() { \n    console.log( this.a );\n}\nvar a = 2; \nfoo(); // 2\n\n// 严格模式下\nfunction foo() { \n    &quot;use strict&quot;;\n    console.log( this.a );\n}\nvar a = 2;\nfoo(); // TypeError: this is undefined\n</code></pre>\n<h2 id=\"隐式绑定\">隐式绑定</h2>\n<p>此时需要考虑函数调用位置的上下文对象。</p>\n<pre><code class=\"language-js\">function foo() { \n    console.log( this.a );\n}\nvar obj = { \n    a: 2,\n    foo: foo \n};\n// 使用 obj 上下文来引用函数\nobj.foo(); // 2\n</code></pre>\n<p>对象属性引用链中只有最顶层或者说最后一层会影响调用位置：</p>\n<pre><code class=\"language-js\">\nfunction foo() { \n    console.log( this.a );\n}\nvar obj2 = { \n    a: 42,\n    foo: foo \n};\nvar obj1 = { \n    a: 2,\n    obj2: obj2 \n};\n// 使用 obj2 上下文来引用函数\nobj1.obj2.foo(); // 42\n</code></pre>\n<h3 id=\"绑定丢失\">绑定丢失</h3>\n<pre><code class=\"language-js\">function foo() { \n    console.log( this.a );\n}\nvar obj = { \n    a: 2,\n    foo: foo \n};\n\n// 虽然 bar 是 obj.foo 的一个引用，但是实际上，它引用的是 foo 函数本身，因此此时的 bar() \n// 其实是一个不带任何修饰的函数调用，因此应用了默认绑定。\nvar bar = obj.foo; // 函数别名!\nvar a = &quot;oops, global&quot;; // a 是全局对象的属性 \nbar(); // &quot;oops, global&quot;\n</code></pre>\n<p>另外一种情况是回调函数，不论是自己创建还是 JS 内置的像 setTimeout 这些方法，所以我们常常使用 <code>var _this = this</code> 来获得 this 的引用。</p>\n<pre><code class=\"language-js\">\n// 回调函数常常会改变 this\nfunction foo() { \n    console.log( this.a );\n}\nfunction doFoo(fn) {\n    // fn 其实引用的是 foo \n    fn(); // &lt;-- 调用位置!\n}\nvar obj = { \n    a: 2,\n    foo: foo \n};\nvar a = &quot;oops, global&quot;; // a 是全局对象的属性 \ndoFoo( obj.foo ); // &quot;oops, global&quot;\n\n// 内置函数\n\nfunction foo() { \n    console.log( this.a );\n}\n\nvar obj = { \n    a: 2,\n    foo: foo \n};\nvar a = &quot;oops, global&quot;; // a 是全局对象的属性 \nsetTimeout( obj.foo, 100 ); // &quot;oops, global&quot;\n</code></pre>\n<h2 id=\"显示绑定\">显示绑定</h2>\n<p>显式绑定即通过 <strong>call</strong> 或者 <strong>apply</strong> 改变 this 的指向。</p>\n<pre><code class=\"language-js\">function foo() { \n    console.log( this.a );\n}\nvar obj = { \n    a:2\n};\nfoo.call( obj ); // 2\n</code></pre>\n<h2 id=\"硬绑定\">硬绑定</h2>\n<p>硬绑定即：<code>Function.prototype.bind</code>，在函数 bind 之后，此后再 apply、call、bind 都不会改变绑定。</p>\n<p>比如 Array.prototype.forEach 等函数最后一个参数即绑定 this。</p>\n<h2 id=\"new-绑定\">new 绑定</h2>\n<pre><code class=\"language-js\">function foo(a) { \n   this.a = a;\n}\nvar bar = new foo(2); \nconsole.log( bar.a ); // 2\n</code></pre>\n<p>几种绑定的优先级：<strong>new 绑定 &gt; 硬绑定 &gt; 显示绑定 &gt; 隐式绑定</strong>。</p>\n<h2 id=\"间接绑定\">间接绑定</h2>\n<p>一种比较特殊的情况：<code>(p.foo = o.foo)</code>这个赋值操作返回的是对 foo 的引用，执行的是默认绑定。</p>\n<pre><code class=\"language-js\">function foo() { \n    console.log( this.a );\n}\n\nvar a = 2; \nvar o = { a: 3, foo: foo }; \nvar p = { a: 4 };\no.foo(); // 3\n(p.foo = o.foo)(); // 2\np.foo() // 4\n</code></pre>\n<h2 id=\"es6-的箭头函数\">ES6 的箭头函数</h2>\n<p>箭头函数是一种不同的 this 的机制，根据外层的作用域确定 this 指向，取代 <code>var self = this</code>的写法，和 bind 一样，此后再次调用 call、apply、bind this 指向不会改变。</p>\n<pre><code class=\"language-js\">function foo() { \n    setTimeout(() =&gt; {\n    // 这里的 this 在此法上继承自 foo()\n        console.log( this.a );\n    }, 100);\n}\nvar obj = { \n    a: 2\n};\nfoo.call( obj ); // 2\n</code></pre>\n"},{"layout":"post","title":"哈士奇 是如何 HOOK 你的 Git 的","banner":"assets/img/husky.jpg","_content":"\n哈士奇，蠢萌蠢萌的，我们常常用它来做 Git hook，哈哈哈。\n\n## Git Hook\n\nGit hook 是在 Git 仓库中特定动作（commit、push 等）发生时自动运行的脚本。在初始化仓库时，Git 会自动在仓库根目录下的 `.git/hooks` 创建一些示例的 hook 脚本：\n\n```bash\napplypatch-msg.sample       pre-push.sample\ncommit-msg.sample           pre-rebase.sample\npost-update.sample          prepare-commit-msg.sample\npre-applypatch.sample       update.sample\npre-commit.sample\n```\n\n这些脚本后面带着 `.sample` 后缀，防止被执行，如果想启用他们，就去掉 `.sample` 后缀，根据需求修改脚本。\n\nHook 又分为客户端 hook 和服务端 hook，简单列一下比较常用的：\n\n客户端 hook：\n\n* pre-commit：钩子在键入提交信息前运行，它用于检查即将提交的快照。比如 lint 代码.\n* prepare-commit-msg：编辑提交者所看到的默认信息。\n* commit-msg：用户输入提交信息之后被调用。\n* post-commit：在整个提交过程完成后运行，它无法更改 git commit 的结果，所以这主要用于通知用途。\n* post-checkout：在 git checkout 成功运行后\n\n服务端 hook：\n\n* pre-receive：处理来自客户端的推送操作时，最先被调用的脚本是 pre-receive。\n* post-receive：在整个过程完结以后运行，可以用来更新其他系统服务或者通知用户。\n\n在 Git 相应动作发生时，就会触发对应的 hook，这些 hook 脚本就会执行，脚本以非0状态退出会放弃提交（或推送）。而且可以使用任何你喜欢的语言来编写 hook。比如打印 commit-msg 这个 hook 的参数：\n\n```bash\n# bash\n# #!/usr/bin/bash\necho \"$1\"\n# 输出 .git/COMMIT_EDITMSG\n```\n\n```js\n#!/usr/bin/env node\n\n// nodejs\n\nconsole.log(process.argv[2])\n```\n\n那比如我们要对 git commit msg 进行规范，必须以 issue 开头：\n\n```js\n#!/usr/bin/env node\n\nconst msgPath = process.argv[2]\nconst fs = require('fs')\nconst content = fs.writeFileSync(msgPath, 'utf-8')\nif(!content || content.indexOf('#issue') !== 0) {\n    console.log('>>> 错误信息')\n    console.log('提交信息需要包含 issue 信息')\n    process.exit(1);\n}\nprocess.exit(0);\n```\n\n服务端的 hook 可以做很多事情，自动触发单元测试，自动部署等。\n\n## husky\n\n那为什么我们需要 husky 呢？因为克隆某个版本库时，它的客户端钩子并不随同复制。同时，对于前端项目，如果能和 `npm script` 相结合的话，就再好不过了。\n\n相信很多团队都已经用过 husky了，配置也是很简单：\n\n```json\n{\n  \"husky\": {\n    \"hooks\": {\n      \"pre-commit\": \"npm test\",\n      \"pre-push\": \"npm test\",\n      \"...\": \"...\"\n    }\n  }\n}\n```\n\n## husky 原理\n\n1. install husky 时，husky 在 .git/hooks 下生成所有的客户端 hook，每个钩子的代码都一样：\n\n```sh\n# 以  commit-msg 为例\nscriptPath=\"node_modules/husky/run.js\"\n# $0 本身 .git/hooks/commit-msg\n# hookName = commit-msg\nhookName=`basename \"$0\"`  \n# gitParams = .git/COMMIT_EDITMSG\ngitParams=\"$*\" \n\nnode_modules/run-node/run-node \"$scriptPath\" $hookName \"$gitParams\"\n```\n\n作用就是找到对应的 hook，把 hook 的名称和 hook 传入脚本的参数，传入 husky 的一段nodejs 脚本并执行。\n\n2. husky 设置 HUSKY_GIT_PARAMS\n3. 从 package.json 获取 hookName 对应的 hooks 命令并执行\n\n```js\nif (command) {\n  console.log(`husky > ${hookName} (node ${process.version})`)\n  execa.shellSync(command, { cwd, env, stdio: 'inherit' })\n  return 0\n}\n```\n\n原理其实并不复杂，但构思十分巧妙。\n\n\n\n\n","source":"_posts/husky-git-hook.md","raw":"\nlayout: post\ntitle: 哈士奇 是如何 HOOK 你的 Git 的\nbanner: assets/img/husky.jpg\ntags:\n- Git\n---\n\n哈士奇，蠢萌蠢萌的，我们常常用它来做 Git hook，哈哈哈。\n\n## Git Hook\n\nGit hook 是在 Git 仓库中特定动作（commit、push 等）发生时自动运行的脚本。在初始化仓库时，Git 会自动在仓库根目录下的 `.git/hooks` 创建一些示例的 hook 脚本：\n\n```bash\napplypatch-msg.sample       pre-push.sample\ncommit-msg.sample           pre-rebase.sample\npost-update.sample          prepare-commit-msg.sample\npre-applypatch.sample       update.sample\npre-commit.sample\n```\n\n这些脚本后面带着 `.sample` 后缀，防止被执行，如果想启用他们，就去掉 `.sample` 后缀，根据需求修改脚本。\n\nHook 又分为客户端 hook 和服务端 hook，简单列一下比较常用的：\n\n客户端 hook：\n\n* pre-commit：钩子在键入提交信息前运行，它用于检查即将提交的快照。比如 lint 代码.\n* prepare-commit-msg：编辑提交者所看到的默认信息。\n* commit-msg：用户输入提交信息之后被调用。\n* post-commit：在整个提交过程完成后运行，它无法更改 git commit 的结果，所以这主要用于通知用途。\n* post-checkout：在 git checkout 成功运行后\n\n服务端 hook：\n\n* pre-receive：处理来自客户端的推送操作时，最先被调用的脚本是 pre-receive。\n* post-receive：在整个过程完结以后运行，可以用来更新其他系统服务或者通知用户。\n\n在 Git 相应动作发生时，就会触发对应的 hook，这些 hook 脚本就会执行，脚本以非0状态退出会放弃提交（或推送）。而且可以使用任何你喜欢的语言来编写 hook。比如打印 commit-msg 这个 hook 的参数：\n\n```bash\n# bash\n# #!/usr/bin/bash\necho \"$1\"\n# 输出 .git/COMMIT_EDITMSG\n```\n\n```js\n#!/usr/bin/env node\n\n// nodejs\n\nconsole.log(process.argv[2])\n```\n\n那比如我们要对 git commit msg 进行规范，必须以 issue 开头：\n\n```js\n#!/usr/bin/env node\n\nconst msgPath = process.argv[2]\nconst fs = require('fs')\nconst content = fs.writeFileSync(msgPath, 'utf-8')\nif(!content || content.indexOf('#issue') !== 0) {\n    console.log('>>> 错误信息')\n    console.log('提交信息需要包含 issue 信息')\n    process.exit(1);\n}\nprocess.exit(0);\n```\n\n服务端的 hook 可以做很多事情，自动触发单元测试，自动部署等。\n\n## husky\n\n那为什么我们需要 husky 呢？因为克隆某个版本库时，它的客户端钩子并不随同复制。同时，对于前端项目，如果能和 `npm script` 相结合的话，就再好不过了。\n\n相信很多团队都已经用过 husky了，配置也是很简单：\n\n```json\n{\n  \"husky\": {\n    \"hooks\": {\n      \"pre-commit\": \"npm test\",\n      \"pre-push\": \"npm test\",\n      \"...\": \"...\"\n    }\n  }\n}\n```\n\n## husky 原理\n\n1. install husky 时，husky 在 .git/hooks 下生成所有的客户端 hook，每个钩子的代码都一样：\n\n```sh\n# 以  commit-msg 为例\nscriptPath=\"node_modules/husky/run.js\"\n# $0 本身 .git/hooks/commit-msg\n# hookName = commit-msg\nhookName=`basename \"$0\"`  \n# gitParams = .git/COMMIT_EDITMSG\ngitParams=\"$*\" \n\nnode_modules/run-node/run-node \"$scriptPath\" $hookName \"$gitParams\"\n```\n\n作用就是找到对应的 hook，把 hook 的名称和 hook 传入脚本的参数，传入 husky 的一段nodejs 脚本并执行。\n\n2. husky 设置 HUSKY_GIT_PARAMS\n3. 从 package.json 获取 hookName 对应的 hooks 命令并执行\n\n```js\nif (command) {\n  console.log(`husky > ${hookName} (node ${process.version})`)\n  execa.shellSync(command, { cwd, env, stdio: 'inherit' })\n  return 0\n}\n```\n\n原理其实并不复杂，但构思十分巧妙。\n\n\n\n\n","slug":"husky-git-hook","published":1,"date":"2019-01-17T13:00:11.000Z","updated":"2019-01-17T13:00:11.000Z","comments":1,"photos":[],"link":"","_id":"cjr1en2n1000dha9splcwmd2s","content":"<p>哈士奇，蠢萌蠢萌的，我们常常用它来做 Git hook，哈哈哈。</p>\n<h2 id=\"git-hook\">Git Hook</h2>\n<p>Git hook 是在 Git 仓库中特定动作（commit、push 等）发生时自动运行的脚本。在初始化仓库时，Git 会自动在仓库根目录下的 <code>.git/hooks</code> 创建一些示例的 hook 脚本：</p>\n<pre><code class=\"language-bash\">applypatch-msg.sample       pre-push.sample\ncommit-msg.sample           pre-rebase.sample\npost-update.sample          prepare-commit-msg.sample\npre-applypatch.sample       update.sample\npre-commit.sample\n</code></pre>\n<p>这些脚本后面带着 <code>.sample</code> 后缀，防止被执行，如果想启用他们，就去掉 <code>.sample</code> 后缀，根据需求修改脚本。</p>\n<p>Hook 又分为客户端 hook 和服务端 hook，简单列一下比较常用的：</p>\n<p>客户端 hook：</p>\n<ul>\n<li>pre-commit：钩子在键入提交信息前运行，它用于检查即将提交的快照。比如 lint 代码.</li>\n<li>prepare-commit-msg：编辑提交者所看到的默认信息。</li>\n<li>commit-msg：用户输入提交信息之后被调用。</li>\n<li>post-commit：在整个提交过程完成后运行，它无法更改 git commit 的结果，所以这主要用于通知用途。</li>\n<li>post-checkout：在 git checkout 成功运行后</li>\n</ul>\n<p>服务端 hook：</p>\n<ul>\n<li>pre-receive：处理来自客户端的推送操作时，最先被调用的脚本是 pre-receive。</li>\n<li>post-receive：在整个过程完结以后运行，可以用来更新其他系统服务或者通知用户。</li>\n</ul>\n<p>在 Git 相应动作发生时，就会触发对应的 hook，这些 hook 脚本就会执行，脚本以非0状态退出会放弃提交（或推送）。而且可以使用任何你喜欢的语言来编写 hook。比如打印 commit-msg 这个 hook 的参数：</p>\n<pre><code class=\"language-bash\"># bash\n# #!/usr/bin/bash\necho &quot;$1&quot;\n# 输出 .git/COMMIT_EDITMSG\n</code></pre>\n<pre><code class=\"language-js\">#!/usr/bin/env node\n\n// nodejs\n\nconsole.log(process.argv[2])\n</code></pre>\n<p>那比如我们要对 git commit msg 进行规范，必须以 issue 开头：</p>\n<pre><code class=\"language-js\">#!/usr/bin/env node\n\nconst msgPath = process.argv[2]\nconst fs = require('fs')\nconst content = fs.writeFileSync(msgPath, 'utf-8')\nif(!content || content.indexOf('#issue') !== 0) {\n    console.log('&gt;&gt;&gt; 错误信息')\n    console.log('提交信息需要包含 issue 信息')\n    process.exit(1);\n}\nprocess.exit(0);\n</code></pre>\n<p>服务端的 hook 可以做很多事情，自动触发单元测试，自动部署等。</p>\n<h2 id=\"husky\">husky</h2>\n<p>那为什么我们需要 husky 呢？因为克隆某个版本库时，它的客户端钩子并不随同复制。同时，对于前端项目，如果能和 <code>npm script</code> 相结合的话，就再好不过了。</p>\n<p>相信很多团队都已经用过 husky了，配置也是很简单：</p>\n<pre><code class=\"language-json\">{\n  &quot;husky&quot;: {\n    &quot;hooks&quot;: {\n      &quot;pre-commit&quot;: &quot;npm test&quot;,\n      &quot;pre-push&quot;: &quot;npm test&quot;,\n      &quot;...&quot;: &quot;...&quot;\n    }\n  }\n}\n</code></pre>\n<h2 id=\"husky-原理\">husky 原理</h2>\n<ol>\n<li>install husky 时，husky 在 .git/hooks 下生成所有的客户端 hook，每个钩子的代码都一样：</li>\n</ol>\n<pre><code class=\"language-sh\"># 以  commit-msg 为例\nscriptPath=&quot;node_modules/husky/run.js&quot;\n# $0 本身 .git/hooks/commit-msg\n# hookName = commit-msg\nhookName=`basename &quot;$0&quot;`  \n# gitParams = .git/COMMIT_EDITMSG\ngitParams=&quot;$*&quot; \n\nnode_modules/run-node/run-node &quot;$scriptPath&quot; $hookName &quot;$gitParams&quot;\n</code></pre>\n<p>作用就是找到对应的 hook，把 hook 的名称和 hook 传入脚本的参数，传入 husky 的一段nodejs 脚本并执行。</p>\n<ol start=\"2\">\n<li>husky 设置 HUSKY_GIT_PARAMS</li>\n<li>从 package.json 获取 hookName 对应的 hooks 命令并执行</li>\n</ol>\n<pre><code class=\"language-js\">if (command) {\n  console.log(`husky &gt; ${hookName} (node ${process.version})`)\n  execa.shellSync(command, { cwd, env, stdio: 'inherit' })\n  return 0\n}\n</code></pre>\n<p>原理其实并不复杂，但构思十分巧妙。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>哈士奇，蠢萌蠢萌的，我们常常用它来做 Git hook，哈哈哈。</p>\n<h2 id=\"git-hook\">Git Hook</h2>\n<p>Git hook 是在 Git 仓库中特定动作（commit、push 等）发生时自动运行的脚本。在初始化仓库时，Git 会自动在仓库根目录下的 <code>.git/hooks</code> 创建一些示例的 hook 脚本：</p>\n<pre><code class=\"language-bash\">applypatch-msg.sample       pre-push.sample\ncommit-msg.sample           pre-rebase.sample\npost-update.sample          prepare-commit-msg.sample\npre-applypatch.sample       update.sample\npre-commit.sample\n</code></pre>\n<p>这些脚本后面带着 <code>.sample</code> 后缀，防止被执行，如果想启用他们，就去掉 <code>.sample</code> 后缀，根据需求修改脚本。</p>\n<p>Hook 又分为客户端 hook 和服务端 hook，简单列一下比较常用的：</p>\n<p>客户端 hook：</p>\n<ul>\n<li>pre-commit：钩子在键入提交信息前运行，它用于检查即将提交的快照。比如 lint 代码.</li>\n<li>prepare-commit-msg：编辑提交者所看到的默认信息。</li>\n<li>commit-msg：用户输入提交信息之后被调用。</li>\n<li>post-commit：在整个提交过程完成后运行，它无法更改 git commit 的结果，所以这主要用于通知用途。</li>\n<li>post-checkout：在 git checkout 成功运行后</li>\n</ul>\n<p>服务端 hook：</p>\n<ul>\n<li>pre-receive：处理来自客户端的推送操作时，最先被调用的脚本是 pre-receive。</li>\n<li>post-receive：在整个过程完结以后运行，可以用来更新其他系统服务或者通知用户。</li>\n</ul>\n<p>在 Git 相应动作发生时，就会触发对应的 hook，这些 hook 脚本就会执行，脚本以非0状态退出会放弃提交（或推送）。而且可以使用任何你喜欢的语言来编写 hook。比如打印 commit-msg 这个 hook 的参数：</p>\n<pre><code class=\"language-bash\"># bash\n# #!/usr/bin/bash\necho &quot;$1&quot;\n# 输出 .git/COMMIT_EDITMSG\n</code></pre>\n<pre><code class=\"language-js\">#!/usr/bin/env node\n\n// nodejs\n\nconsole.log(process.argv[2])\n</code></pre>\n<p>那比如我们要对 git commit msg 进行规范，必须以 issue 开头：</p>\n<pre><code class=\"language-js\">#!/usr/bin/env node\n\nconst msgPath = process.argv[2]\nconst fs = require('fs')\nconst content = fs.writeFileSync(msgPath, 'utf-8')\nif(!content || content.indexOf('#issue') !== 0) {\n    console.log('&gt;&gt;&gt; 错误信息')\n    console.log('提交信息需要包含 issue 信息')\n    process.exit(1);\n}\nprocess.exit(0);\n</code></pre>\n<p>服务端的 hook 可以做很多事情，自动触发单元测试，自动部署等。</p>\n<h2 id=\"husky\">husky</h2>\n<p>那为什么我们需要 husky 呢？因为克隆某个版本库时，它的客户端钩子并不随同复制。同时，对于前端项目，如果能和 <code>npm script</code> 相结合的话，就再好不过了。</p>\n<p>相信很多团队都已经用过 husky了，配置也是很简单：</p>\n<pre><code class=\"language-json\">{\n  &quot;husky&quot;: {\n    &quot;hooks&quot;: {\n      &quot;pre-commit&quot;: &quot;npm test&quot;,\n      &quot;pre-push&quot;: &quot;npm test&quot;,\n      &quot;...&quot;: &quot;...&quot;\n    }\n  }\n}\n</code></pre>\n<h2 id=\"husky-原理\">husky 原理</h2>\n<ol>\n<li>install husky 时，husky 在 .git/hooks 下生成所有的客户端 hook，每个钩子的代码都一样：</li>\n</ol>\n<pre><code class=\"language-sh\"># 以  commit-msg 为例\nscriptPath=&quot;node_modules/husky/run.js&quot;\n# $0 本身 .git/hooks/commit-msg\n# hookName = commit-msg\nhookName=`basename &quot;$0&quot;`  \n# gitParams = .git/COMMIT_EDITMSG\ngitParams=&quot;$*&quot; \n\nnode_modules/run-node/run-node &quot;$scriptPath&quot; $hookName &quot;$gitParams&quot;\n</code></pre>\n<p>作用就是找到对应的 hook，把 hook 的名称和 hook 传入脚本的参数，传入 husky 的一段nodejs 脚本并执行。</p>\n<ol start=\"2\">\n<li>husky 设置 HUSKY_GIT_PARAMS</li>\n<li>从 package.json 获取 hookName 对应的 hooks 命令并执行</li>\n</ol>\n<pre><code class=\"language-js\">if (command) {\n  console.log(`husky &gt; ${hookName} (node ${process.version})`)\n  execa.shellSync(command, { cwd, env, stdio: 'inherit' })\n  return 0\n}\n</code></pre>\n<p>原理其实并不复杂，但构思十分巧妙。</p>\n"},{"layout":"post","title":"详解 Webpack（下）","banner":"assets/img/webpack.jpg","label":"译","_content":"\nJavaScript 模块打包工具已经出现有一段时间了。RequireJS 在2009年完成了第一次提交，然后 Browserify 随之出现，从那时候起相继出现了各种模块打包工具。在这些里面，webpack脱颖而出。如果你还不熟悉它，我希望这篇文章可以帮你开始使用这个强大的工具。\n\n本文承接[详解 Webpack（上）](/2017/03/13/a-detailed-introduction-to-webpack-1.html)\n\n## 使用插件\n\n插件为 webpack 提供了一些实用性的功能。你有充分的自由将它们加入到 webpack 的工作流中，不像 loaders，插件并不限制用于某些文件。它们可以注入到任何地方，所以能做的就更多。很难去解释清插件到底能做什么，所以我只是告诉一个[名为 webpack-plugin npm 包的列表](https://www.npmjs.com/search?q=webpack-plugin)，应该能够很好的说明这一点。\n\n在本教程中，我们仅接触两个插件（另一个稍后使用）。这篇文章到这里已经很长了，那我们就继续来一个插件的 demo。第一个我们要使用的插件是 [HTML Webpack Plugin](https://github.com/ampedandwired/html-webpack-plugin)，这个插件可以创建一个 HTML - 我们终于可以使用这个 web 应用了！\n\n在使用这个插件之前，先更新一下 `scripts`，安装一个简单的 web 服务器来测试我们的页面。首先安装：`npm i -D http-server`，然后，然后我们修改 `execute` 为 `server`，并相应的更新 `start` 脚本：\n\n```json\n\"scripts\": {\n  \"prebuild\": \"del-cli dist -f\",\n  \"build\": \"webpack\",\n  \"server\": \"http-server ./dist\",\n  \"start\": \"npm run build -s && npm run server -s\"\n},\n```\n\nwebpack 构建完毕后，`npm start` 也会创建一个 web 服务器，你可以 访问`localhost:8080` 查看页面。当然，首先我们要先使用这个插件创建一个页面，安装插件：`npm i -D html-webpack-plugin`。\n\n安装完成后，我们需要修改 `webpack.config.js`：\n\n```js\nvar HtmlwebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n    entry: [\n        'babel-polyfill',\n        './src/main.js'\n    ],\n    output: {\n        path: './dist',\n        filename: 'bundle.js'\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.jsx?$/, loader: 'babel-loader', exclude: /node_modules/,\n                options: { plugins: ['transform-runtime'], presets: ['es2015'] }\n            },\n            { test: /\\.hbs$/, loader: 'handlebars-loader' }\n        ]\n    },\n    plugins: [\n        new HtmlwebpackPlugin()\n    ]\n};\n```\n\n我们主要做了两处修改：在文件顶部引入了插件，并在配置对象中添加 `plugins` 属性，传入了插件的实例。\n\n现在，我们没有给插件传入任何选项，所以它会生成标准的模板，虽然没有包含什么，但已经包含了我们打包的脚本。如果你运行 `npm start`，你在浏览器中会看见一个空白页，不过如果你打开控制台，就会看到有 HTML 输出。\n\n我们要将模板和 HTML 文件输出到页面而不仅仅是控制台中，普通人会从页面中看到一些东西（而不是空白页），首先在 `src` 目录下新建 `index.html` 文件，默认他会使用 EJS 作为模板引擎，不过你也可以插件使用[其他的模板引擎](https://github.com/ampedandwired/html-webpack-plugin/blob/master/docs/template-option.md)。我们将使用默认的 EJS 模板，下面是文件的内容：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title><%= htmlWebpackPlugin.options.title %></title>\n</head>\n<body>\n    <h2>This is my Index.html Template</h2>\n    <div id=\"app-container\"></div>\n</body>\n</html>\n```\n\n你会注意到一些点：\n\n* 我们可以使用插件的一个选项设置 HTML 标题。\n* 不必手动设置该添加的脚本。因为它会默认在 `body` 底部添加脚本。\n* 这里有一个 `div` 和 `id`，现在我们就要使用它们。\n\n有了模板后，至少现在不再是一个空白页面。更新 `main.js`，将 HTML 添加到 `div`，而不是打印到控制台中。在 `main.js` 最后添加一行：\n\n```js\ndocument.getElementById(\"app-container\").innerHTML = template({numbers});\n```\n\n同时也要更新 webpack 的配置，给插件传递几个选项，现在你的配置文件变成这样：\n\n```js\nvar HtmlwebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n    entry: [\n        'babel-polyfill',\n        './src/main.js'\n    ],\n    output: {\n        path: './dist',\n        filename: 'bundle.js'\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.jsx?$/, loader: 'babel-loader', exclude: /node_modules/,\n                options: { plugins: ['transform-runtime'], presets: ['es2015'] }\n            },\n            { test: /\\.hbs$/, loader: 'handlebars-loader' }\n        ]\n    },\n    plugins: [\n        new HtmlwebpackPlugin({\n            title: 'Intro to webpack',\n            template: 'src/index.html'\n        })\n    ]\n};\n```\n\n`template` 选项声明了在模板的所在位置，`title`选项是传递给模板的标题，现在运行 `npm start`，你会在浏览器看到以下内容：\n\n![index-html-template-opt.png](https://www.smashingmagazine.com/wp-content/uploads/2017/02/index-html-template-opt.png)\n\n到这里我们完成了 `example5` 分支的所有工作。每个插件都有不同的选项和配置，有太多的插件，它们能做各种各样的事情。最后它们都会添加到 webpack 配置项 `plugins` 数组里。这里有很多方法去处理如何生成 HTML 页面，去填充页面内容，以及给页面添加带 hash 值得文件名（*译者注：应该是带 hash值的脚本文件或者 css 文件*）\n\n在 `example6` 分支里，我通过一个插件增加了压缩 JavaScript 文件的功能，除非你想用 UglifyJS 做一些改变，要不你无需做其他事情。如果不喜欢 UglifyJS 的默认配置，修改 webpack.config.js 中插件的配置，如果默认配置符合你的心意，那么你就运行 `webpack -p`命令，`-p` 是 `production`  的缩写，也就相当于使用 `--optimize-minimize` 和 `--optimize-occurence-order` 参数。第一个参数代表压缩 JavaScript，第二个参数优化打包文件中各个模块的加载顺序，使得文件更小运行速度更快。这个仓库已经挺久了，那会我还不知道 `-p` 这个参数，所以我决定示例保持原样，能给你一点启发。另外一个你能用到的参数是 `-d`，这样 webpack 在执行时会展示更多的调试信息，并会生成不带额外信息的 sourcemaps。如果这些对你都很简单，你可以在了解更多 [命令行简写](http://webpack.github.io/docs/cli.html) 的知识。\n\n## 懒加载\n\n我最喜欢的 RequireJS 的一点是可以懒加载模块。一个超大的 JavaScript 文件可以减少请求数，但是也导致用户没有使用到的代码也被下载了下来。\n\nWebpack 有一种方法可以将文件分割成多个懒加载的块，甚至你都不需要在配置文件中做什么配置。你只需要写点代码，Webpack 会处理剩下的事情。Webpack 提供了两种方法，一种基于 CommonJS，一种基于 AMD。使用 CommonJS 的话，看起来是这样：\n\n```js\nrequire.ensure([\"module-a\", \"module-b\"], function(require) {\n    var a = require(\"module-a\");\n    var b = require(\"module-b\");\n    // …\n});\n```\n\n使用 `require.ensure`，保证模块是可用的（但不执行它），传入模块的数组和一个回调。为了在回调中真正的使用这个回调，你需要使用回调的参数 `require` 显式的引入这些模块。\n\n个人感觉，这种使用方法不太好，让我们看一下 AMD 的版本：\n\n```js\nrequire([\"module-a\", \"module-b\"], function(a, b) {\n    // …\n});\n```\n\nAMD 版本中，使用 `require` 方法传入模块的数组和一个回调。回调的参数指向这些模块，而且和数组的顺序一致。\n\nWebpack2 也支持 `System.import`，使用 promises 而不是回调。这是一个很有用的改进，虽然你如果你真的想用 promise，这也不是难事。不过注意，`System.import` 已经废弃，因为已经有了新的 `import()` 规范。在 Babel（或者TypeScript）使用会抛出语法错误。你可以使用 [ babel-plugin-dynamic-import-webpack](https://www.npmjs.com/package/babel-plugin-dynamic-import-webpack)，但它会将 `System.import` 转换为 `require.ensure`，而不仅仅帮助 Babel 查看合法的 `import` 参数，这样 Webpack 就可以处理了。AMD 和 `require.ensure` 短时间不会消失，`System.import` 至少要到 Webpack3 才会支持，所以尽情的事情你喜欢的方式。（*译者注：这段有点懵逼*）\n\n让我们增加一点代码，等待几秒钟，懒加载 handlebar 模板并将结果输出到页面上。我们移除掉文件顶部的 `import`，然后用 `setTimeout` 包起来，使用 AMD 方式 `require` 这段模板：\n\n```js\nimport { map } from 'lodash';\n\nlet numbers = map([1,2,3,4,5,6], n => n*n);\n\nsetTimeout( () => {\n    require(['./numberlist.hbs'], template => {\n        document.getElementById(\"app-container\").innerHTML = template({numbers});\n    })\n}, 2000);\n```\n\n现在运行 `npm start`，你会看到生成了另外一个资源，应该是 `1.bundle.js`。打开浏览器的开发者工具，切到 Network 面板，你会看到两秒后，一个新的文件加载进来，并执行。这并不难实现，但是却减少了文件的体积，增强了用户体验。\n\n注意：这些子模块包括他们的所有依赖，都被包含在他们的父模块中。（你可以有多个入口，懒加载不同的模块，这样不同的模块就被加载进了各个父模块中）。（*译者注： 翻译待加强*）\n\n## 创建 Vendor Chunk\n\n让我们继续讨论一些优化点：vendor chunks。你可以定义一些单独的文件，用来保存一些通用的或者第三方的代码，这些代码通常不怎么变化。这样用户就可以先缓存这些文件。当你更新应用的时候，就不必再重新下载这些代码了。\n\n为了做到这一点，我们需要使用 webpack 自带的一个插件：`CommonsChunkPlugin`。这是 webpack 自带的插件，所有我们不用额外安装什么。只要编辑配置文件即可：\n\n```js\nvar HtmlwebpackPlugin = require('html-webpack-plugin');\nvar UglifyJsPlugin = require('webpack/lib/optimize/UglifyJsPlugin');\nvar CommonsChunkPlugin = require('webpack/lib/optimize/CommonsChunkPlugin');\n\nmodule.exports = {\n    entry: {\n        vendor: ['babel-polyfill', 'lodash'],\n        main: './src/main.js'\n    },\n    output: {\n        path: './dist',\n        filename: 'bundle.js'\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.jsx?$/, loader: 'babel-loader', exclude: /node_modules/,\n                options: { plugins: ['transform-runtime'], presets: ['es2015'] }\n            },\n            { test: /\\.hbs$/, loader: 'handlebars-loader' }\n        ]\n    },\n    plugins: [\n        new HtmlwebpackPlugin({\n            title: 'Intro to webpack',\n            template: 'src/index.html'\n        }),\n        new UglifyJsPlugin({\n            beautify: false,\n            mangle: { screw_ie8 : true },\n            compress: { screw_ie8: true, warnings: false },\n            comments: false\n        }),\n        new CommonsChunkPlugin({\n            name: \"vendor\",\n            filename: \"vendor.bundle.js\"\n        })\n    ]\n};\n```\n\n在第三行，我们引入了这个插件，`entry` 入口，我们使用对象字面量来声明多入口文件，`vendor` 入口标识那些被包含进 vendor chunks 的文件 - 这里我们包含了 polyfill 和 lodash，我们把应用的代码放进 `main.js` 内。然后只要在 plugins 入口增加 `CommonsChunkPlugin` 插件，在插件中声明 `vendor` 出口并且 vendor chunks 的代码命名为 `vendor.bundle.js`。\n\n通过声明 vendor chunks，这个插件会把这个 chunks 的所有依赖从入口文件抽离出来放到 vendor chunks 中。如果你声明 vendor 的名字，它会根据入口的依赖文件生成一个单独的文件。\n\n当你运行 webpack 后，你会看到生成了三个 JavaScript 文件：`bundle.js`、`1.bundle.js`、`vendor.bundle.js`。如果你喜欢的话，可以再次运行 `npm start` 在浏览器中查看结果。看起来 webpack 是在应用的主代码中处理 vendor chunks 的加载，真的很有用！\n\n这就是 `example8` 的所有内容，也是本教程的所有内容。我讲到了很多，但也只是 webpack 的一小部分而已。webpack 包括了更加简单的 CSS 模块、缓存（cache-busting）hash、图片优化等等很多很多，每一点都可以长篇大论。我不能给你展示所有的知识点，而且等我写完了，好多都已经过时了！所以尝试一下 webpack，让我知道提高了你的工作效率！\n\n上帝保佑，happy coding！\n\n---\n\n文章是在太长，分成上下两部分。\n原文地址：[A Detailed Introduction To Webpack](https://www.smashingmagazine.com/2017/02/a-detailed-introduction-to-webpack/)\n\n---\n\n翻译水平实在有限 ~ 如果有疑惑可以直接运行仓库例子 ~\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/a-detailed-introduction-to-webpack-2.md","raw":"\nlayout: post\ntitle: 详解 Webpack（下）\nbanner: assets/img/webpack.jpg\nlabel: 译\ntags: webpack\n---\n\nJavaScript 模块打包工具已经出现有一段时间了。RequireJS 在2009年完成了第一次提交，然后 Browserify 随之出现，从那时候起相继出现了各种模块打包工具。在这些里面，webpack脱颖而出。如果你还不熟悉它，我希望这篇文章可以帮你开始使用这个强大的工具。\n\n本文承接[详解 Webpack（上）](/2017/03/13/a-detailed-introduction-to-webpack-1.html)\n\n## 使用插件\n\n插件为 webpack 提供了一些实用性的功能。你有充分的自由将它们加入到 webpack 的工作流中，不像 loaders，插件并不限制用于某些文件。它们可以注入到任何地方，所以能做的就更多。很难去解释清插件到底能做什么，所以我只是告诉一个[名为 webpack-plugin npm 包的列表](https://www.npmjs.com/search?q=webpack-plugin)，应该能够很好的说明这一点。\n\n在本教程中，我们仅接触两个插件（另一个稍后使用）。这篇文章到这里已经很长了，那我们就继续来一个插件的 demo。第一个我们要使用的插件是 [HTML Webpack Plugin](https://github.com/ampedandwired/html-webpack-plugin)，这个插件可以创建一个 HTML - 我们终于可以使用这个 web 应用了！\n\n在使用这个插件之前，先更新一下 `scripts`，安装一个简单的 web 服务器来测试我们的页面。首先安装：`npm i -D http-server`，然后，然后我们修改 `execute` 为 `server`，并相应的更新 `start` 脚本：\n\n```json\n\"scripts\": {\n  \"prebuild\": \"del-cli dist -f\",\n  \"build\": \"webpack\",\n  \"server\": \"http-server ./dist\",\n  \"start\": \"npm run build -s && npm run server -s\"\n},\n```\n\nwebpack 构建完毕后，`npm start` 也会创建一个 web 服务器，你可以 访问`localhost:8080` 查看页面。当然，首先我们要先使用这个插件创建一个页面，安装插件：`npm i -D html-webpack-plugin`。\n\n安装完成后，我们需要修改 `webpack.config.js`：\n\n```js\nvar HtmlwebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n    entry: [\n        'babel-polyfill',\n        './src/main.js'\n    ],\n    output: {\n        path: './dist',\n        filename: 'bundle.js'\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.jsx?$/, loader: 'babel-loader', exclude: /node_modules/,\n                options: { plugins: ['transform-runtime'], presets: ['es2015'] }\n            },\n            { test: /\\.hbs$/, loader: 'handlebars-loader' }\n        ]\n    },\n    plugins: [\n        new HtmlwebpackPlugin()\n    ]\n};\n```\n\n我们主要做了两处修改：在文件顶部引入了插件，并在配置对象中添加 `plugins` 属性，传入了插件的实例。\n\n现在，我们没有给插件传入任何选项，所以它会生成标准的模板，虽然没有包含什么，但已经包含了我们打包的脚本。如果你运行 `npm start`，你在浏览器中会看见一个空白页，不过如果你打开控制台，就会看到有 HTML 输出。\n\n我们要将模板和 HTML 文件输出到页面而不仅仅是控制台中，普通人会从页面中看到一些东西（而不是空白页），首先在 `src` 目录下新建 `index.html` 文件，默认他会使用 EJS 作为模板引擎，不过你也可以插件使用[其他的模板引擎](https://github.com/ampedandwired/html-webpack-plugin/blob/master/docs/template-option.md)。我们将使用默认的 EJS 模板，下面是文件的内容：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title><%= htmlWebpackPlugin.options.title %></title>\n</head>\n<body>\n    <h2>This is my Index.html Template</h2>\n    <div id=\"app-container\"></div>\n</body>\n</html>\n```\n\n你会注意到一些点：\n\n* 我们可以使用插件的一个选项设置 HTML 标题。\n* 不必手动设置该添加的脚本。因为它会默认在 `body` 底部添加脚本。\n* 这里有一个 `div` 和 `id`，现在我们就要使用它们。\n\n有了模板后，至少现在不再是一个空白页面。更新 `main.js`，将 HTML 添加到 `div`，而不是打印到控制台中。在 `main.js` 最后添加一行：\n\n```js\ndocument.getElementById(\"app-container\").innerHTML = template({numbers});\n```\n\n同时也要更新 webpack 的配置，给插件传递几个选项，现在你的配置文件变成这样：\n\n```js\nvar HtmlwebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n    entry: [\n        'babel-polyfill',\n        './src/main.js'\n    ],\n    output: {\n        path: './dist',\n        filename: 'bundle.js'\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.jsx?$/, loader: 'babel-loader', exclude: /node_modules/,\n                options: { plugins: ['transform-runtime'], presets: ['es2015'] }\n            },\n            { test: /\\.hbs$/, loader: 'handlebars-loader' }\n        ]\n    },\n    plugins: [\n        new HtmlwebpackPlugin({\n            title: 'Intro to webpack',\n            template: 'src/index.html'\n        })\n    ]\n};\n```\n\n`template` 选项声明了在模板的所在位置，`title`选项是传递给模板的标题，现在运行 `npm start`，你会在浏览器看到以下内容：\n\n![index-html-template-opt.png](https://www.smashingmagazine.com/wp-content/uploads/2017/02/index-html-template-opt.png)\n\n到这里我们完成了 `example5` 分支的所有工作。每个插件都有不同的选项和配置，有太多的插件，它们能做各种各样的事情。最后它们都会添加到 webpack 配置项 `plugins` 数组里。这里有很多方法去处理如何生成 HTML 页面，去填充页面内容，以及给页面添加带 hash 值得文件名（*译者注：应该是带 hash值的脚本文件或者 css 文件*）\n\n在 `example6` 分支里，我通过一个插件增加了压缩 JavaScript 文件的功能，除非你想用 UglifyJS 做一些改变，要不你无需做其他事情。如果不喜欢 UglifyJS 的默认配置，修改 webpack.config.js 中插件的配置，如果默认配置符合你的心意，那么你就运行 `webpack -p`命令，`-p` 是 `production`  的缩写，也就相当于使用 `--optimize-minimize` 和 `--optimize-occurence-order` 参数。第一个参数代表压缩 JavaScript，第二个参数优化打包文件中各个模块的加载顺序，使得文件更小运行速度更快。这个仓库已经挺久了，那会我还不知道 `-p` 这个参数，所以我决定示例保持原样，能给你一点启发。另外一个你能用到的参数是 `-d`，这样 webpack 在执行时会展示更多的调试信息，并会生成不带额外信息的 sourcemaps。如果这些对你都很简单，你可以在了解更多 [命令行简写](http://webpack.github.io/docs/cli.html) 的知识。\n\n## 懒加载\n\n我最喜欢的 RequireJS 的一点是可以懒加载模块。一个超大的 JavaScript 文件可以减少请求数，但是也导致用户没有使用到的代码也被下载了下来。\n\nWebpack 有一种方法可以将文件分割成多个懒加载的块，甚至你都不需要在配置文件中做什么配置。你只需要写点代码，Webpack 会处理剩下的事情。Webpack 提供了两种方法，一种基于 CommonJS，一种基于 AMD。使用 CommonJS 的话，看起来是这样：\n\n```js\nrequire.ensure([\"module-a\", \"module-b\"], function(require) {\n    var a = require(\"module-a\");\n    var b = require(\"module-b\");\n    // …\n});\n```\n\n使用 `require.ensure`，保证模块是可用的（但不执行它），传入模块的数组和一个回调。为了在回调中真正的使用这个回调，你需要使用回调的参数 `require` 显式的引入这些模块。\n\n个人感觉，这种使用方法不太好，让我们看一下 AMD 的版本：\n\n```js\nrequire([\"module-a\", \"module-b\"], function(a, b) {\n    // …\n});\n```\n\nAMD 版本中，使用 `require` 方法传入模块的数组和一个回调。回调的参数指向这些模块，而且和数组的顺序一致。\n\nWebpack2 也支持 `System.import`，使用 promises 而不是回调。这是一个很有用的改进，虽然你如果你真的想用 promise，这也不是难事。不过注意，`System.import` 已经废弃，因为已经有了新的 `import()` 规范。在 Babel（或者TypeScript）使用会抛出语法错误。你可以使用 [ babel-plugin-dynamic-import-webpack](https://www.npmjs.com/package/babel-plugin-dynamic-import-webpack)，但它会将 `System.import` 转换为 `require.ensure`，而不仅仅帮助 Babel 查看合法的 `import` 参数，这样 Webpack 就可以处理了。AMD 和 `require.ensure` 短时间不会消失，`System.import` 至少要到 Webpack3 才会支持，所以尽情的事情你喜欢的方式。（*译者注：这段有点懵逼*）\n\n让我们增加一点代码，等待几秒钟，懒加载 handlebar 模板并将结果输出到页面上。我们移除掉文件顶部的 `import`，然后用 `setTimeout` 包起来，使用 AMD 方式 `require` 这段模板：\n\n```js\nimport { map } from 'lodash';\n\nlet numbers = map([1,2,3,4,5,6], n => n*n);\n\nsetTimeout( () => {\n    require(['./numberlist.hbs'], template => {\n        document.getElementById(\"app-container\").innerHTML = template({numbers});\n    })\n}, 2000);\n```\n\n现在运行 `npm start`，你会看到生成了另外一个资源，应该是 `1.bundle.js`。打开浏览器的开发者工具，切到 Network 面板，你会看到两秒后，一个新的文件加载进来，并执行。这并不难实现，但是却减少了文件的体积，增强了用户体验。\n\n注意：这些子模块包括他们的所有依赖，都被包含在他们的父模块中。（你可以有多个入口，懒加载不同的模块，这样不同的模块就被加载进了各个父模块中）。（*译者注： 翻译待加强*）\n\n## 创建 Vendor Chunk\n\n让我们继续讨论一些优化点：vendor chunks。你可以定义一些单独的文件，用来保存一些通用的或者第三方的代码，这些代码通常不怎么变化。这样用户就可以先缓存这些文件。当你更新应用的时候，就不必再重新下载这些代码了。\n\n为了做到这一点，我们需要使用 webpack 自带的一个插件：`CommonsChunkPlugin`。这是 webpack 自带的插件，所有我们不用额外安装什么。只要编辑配置文件即可：\n\n```js\nvar HtmlwebpackPlugin = require('html-webpack-plugin');\nvar UglifyJsPlugin = require('webpack/lib/optimize/UglifyJsPlugin');\nvar CommonsChunkPlugin = require('webpack/lib/optimize/CommonsChunkPlugin');\n\nmodule.exports = {\n    entry: {\n        vendor: ['babel-polyfill', 'lodash'],\n        main: './src/main.js'\n    },\n    output: {\n        path: './dist',\n        filename: 'bundle.js'\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.jsx?$/, loader: 'babel-loader', exclude: /node_modules/,\n                options: { plugins: ['transform-runtime'], presets: ['es2015'] }\n            },\n            { test: /\\.hbs$/, loader: 'handlebars-loader' }\n        ]\n    },\n    plugins: [\n        new HtmlwebpackPlugin({\n            title: 'Intro to webpack',\n            template: 'src/index.html'\n        }),\n        new UglifyJsPlugin({\n            beautify: false,\n            mangle: { screw_ie8 : true },\n            compress: { screw_ie8: true, warnings: false },\n            comments: false\n        }),\n        new CommonsChunkPlugin({\n            name: \"vendor\",\n            filename: \"vendor.bundle.js\"\n        })\n    ]\n};\n```\n\n在第三行，我们引入了这个插件，`entry` 入口，我们使用对象字面量来声明多入口文件，`vendor` 入口标识那些被包含进 vendor chunks 的文件 - 这里我们包含了 polyfill 和 lodash，我们把应用的代码放进 `main.js` 内。然后只要在 plugins 入口增加 `CommonsChunkPlugin` 插件，在插件中声明 `vendor` 出口并且 vendor chunks 的代码命名为 `vendor.bundle.js`。\n\n通过声明 vendor chunks，这个插件会把这个 chunks 的所有依赖从入口文件抽离出来放到 vendor chunks 中。如果你声明 vendor 的名字，它会根据入口的依赖文件生成一个单独的文件。\n\n当你运行 webpack 后，你会看到生成了三个 JavaScript 文件：`bundle.js`、`1.bundle.js`、`vendor.bundle.js`。如果你喜欢的话，可以再次运行 `npm start` 在浏览器中查看结果。看起来 webpack 是在应用的主代码中处理 vendor chunks 的加载，真的很有用！\n\n这就是 `example8` 的所有内容，也是本教程的所有内容。我讲到了很多，但也只是 webpack 的一小部分而已。webpack 包括了更加简单的 CSS 模块、缓存（cache-busting）hash、图片优化等等很多很多，每一点都可以长篇大论。我不能给你展示所有的知识点，而且等我写完了，好多都已经过时了！所以尝试一下 webpack，让我知道提高了你的工作效率！\n\n上帝保佑，happy coding！\n\n---\n\n文章是在太长，分成上下两部分。\n原文地址：[A Detailed Introduction To Webpack](https://www.smashingmagazine.com/2017/02/a-detailed-introduction-to-webpack/)\n\n---\n\n翻译水平实在有限 ~ 如果有疑惑可以直接运行仓库例子 ~\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"a-detailed-introduction-to-webpack-2","published":1,"date":"2019-01-17T13:00:11.000Z","updated":"2019-01-17T13:00:11.000Z","comments":1,"photos":[],"link":"","_id":"cjr1en2ns000uha9s1t2c6xkv","content":"<p>JavaScript 模块打包工具已经出现有一段时间了。RequireJS 在2009年完成了第一次提交，然后 Browserify 随之出现，从那时候起相继出现了各种模块打包工具。在这些里面，webpack脱颖而出。如果你还不熟悉它，我希望这篇文章可以帮你开始使用这个强大的工具。</p>\n<p>本文承接<a href=\"/2017/03/13/a-detailed-introduction-to-webpack-1.html\">详解 Webpack（上）</a></p>\n<h2 id=\"使用插件\">使用插件</h2>\n<p>插件为 webpack 提供了一些实用性的功能。你有充分的自由将它们加入到 webpack 的工作流中，不像 loaders，插件并不限制用于某些文件。它们可以注入到任何地方，所以能做的就更多。很难去解释清插件到底能做什么，所以我只是告诉一个<a href=\"https://www.npmjs.com/search?q=webpack-plugin\" target=\"_blank\" rel=\"noopener\">名为 webpack-plugin npm 包的列表</a>，应该能够很好的说明这一点。</p>\n<p>在本教程中，我们仅接触两个插件（另一个稍后使用）。这篇文章到这里已经很长了，那我们就继续来一个插件的 demo。第一个我们要使用的插件是 <a href=\"https://github.com/ampedandwired/html-webpack-plugin\" target=\"_blank\" rel=\"noopener\">HTML Webpack Plugin</a>，这个插件可以创建一个 HTML - 我们终于可以使用这个 web 应用了！</p>\n<p>在使用这个插件之前，先更新一下 <code>scripts</code>，安装一个简单的 web 服务器来测试我们的页面。首先安装：<code>npm i -D http-server</code>，然后，然后我们修改 <code>execute</code> 为 <code>server</code>，并相应的更新 <code>start</code> 脚本：</p>\n<pre><code class=\"language-json\">&quot;scripts&quot;: {\n  &quot;prebuild&quot;: &quot;del-cli dist -f&quot;,\n  &quot;build&quot;: &quot;webpack&quot;,\n  &quot;server&quot;: &quot;http-server ./dist&quot;,\n  &quot;start&quot;: &quot;npm run build -s &amp;&amp; npm run server -s&quot;\n},\n</code></pre>\n<p>webpack 构建完毕后，<code>npm start</code> 也会创建一个 web 服务器，你可以 访问<code>localhost:8080</code> 查看页面。当然，首先我们要先使用这个插件创建一个页面，安装插件：<code>npm i -D html-webpack-plugin</code>。</p>\n<p>安装完成后，我们需要修改 <code>webpack.config.js</code>：</p>\n<pre><code class=\"language-js\">var HtmlwebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n    entry: [\n        'babel-polyfill',\n        './src/main.js'\n    ],\n    output: {\n        path: './dist',\n        filename: 'bundle.js'\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.jsx?$/, loader: 'babel-loader', exclude: /node_modules/,\n                options: { plugins: ['transform-runtime'], presets: ['es2015'] }\n            },\n            { test: /\\.hbs$/, loader: 'handlebars-loader' }\n        ]\n    },\n    plugins: [\n        new HtmlwebpackPlugin()\n    ]\n};\n</code></pre>\n<p>我们主要做了两处修改：在文件顶部引入了插件，并在配置对象中添加 <code>plugins</code> 属性，传入了插件的实例。</p>\n<p>现在，我们没有给插件传入任何选项，所以它会生成标准的模板，虽然没有包含什么，但已经包含了我们打包的脚本。如果你运行 <code>npm start</code>，你在浏览器中会看见一个空白页，不过如果你打开控制台，就会看到有 HTML 输出。</p>\n<p>我们要将模板和 HTML 文件输出到页面而不仅仅是控制台中，普通人会从页面中看到一些东西（而不是空白页），首先在 <code>src</code> 目录下新建 <code>index.html</code> 文件，默认他会使用 EJS 作为模板引擎，不过你也可以插件使用<a href=\"https://github.com/ampedandwired/html-webpack-plugin/blob/master/docs/template-option.md\" target=\"_blank\" rel=\"noopener\">其他的模板引擎</a>。我们将使用默认的 EJS 模板，下面是文件的内容：</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h2&gt;This is my Index.html Template&lt;/h2&gt;\n    &lt;div id=&quot;app-container&quot;&gt;&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>你会注意到一些点：</p>\n<ul>\n<li>我们可以使用插件的一个选项设置 HTML 标题。</li>\n<li>不必手动设置该添加的脚本。因为它会默认在 <code>body</code> 底部添加脚本。</li>\n<li>这里有一个 <code>div</code> 和 <code>id</code>，现在我们就要使用它们。</li>\n</ul>\n<p>有了模板后，至少现在不再是一个空白页面。更新 <code>main.js</code>，将 HTML 添加到 <code>div</code>，而不是打印到控制台中。在 <code>main.js</code> 最后添加一行：</p>\n<pre><code class=\"language-js\">document.getElementById(&quot;app-container&quot;).innerHTML = template({numbers});\n</code></pre>\n<p>同时也要更新 webpack 的配置，给插件传递几个选项，现在你的配置文件变成这样：</p>\n<pre><code class=\"language-js\">var HtmlwebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n    entry: [\n        'babel-polyfill',\n        './src/main.js'\n    ],\n    output: {\n        path: './dist',\n        filename: 'bundle.js'\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.jsx?$/, loader: 'babel-loader', exclude: /node_modules/,\n                options: { plugins: ['transform-runtime'], presets: ['es2015'] }\n            },\n            { test: /\\.hbs$/, loader: 'handlebars-loader' }\n        ]\n    },\n    plugins: [\n        new HtmlwebpackPlugin({\n            title: 'Intro to webpack',\n            template: 'src/index.html'\n        })\n    ]\n};\n</code></pre>\n<p><code>template</code> 选项声明了在模板的所在位置，<code>title</code>选项是传递给模板的标题，现在运行 <code>npm start</code>，你会在浏览器看到以下内容：</p>\n<p><img src=\"https://www.smashingmagazine.com/wp-content/uploads/2017/02/index-html-template-opt.png\" alt=\"index-html-template-opt.png\"></p>\n<p>到这里我们完成了 <code>example5</code> 分支的所有工作。每个插件都有不同的选项和配置，有太多的插件，它们能做各种各样的事情。最后它们都会添加到 webpack 配置项 <code>plugins</code> 数组里。这里有很多方法去处理如何生成 HTML 页面，去填充页面内容，以及给页面添加带 hash 值得文件名（<em>译者注：应该是带 hash值的脚本文件或者 css 文件</em>）</p>\n<p>在 <code>example6</code> 分支里，我通过一个插件增加了压缩 JavaScript 文件的功能，除非你想用 UglifyJS 做一些改变，要不你无需做其他事情。如果不喜欢 UglifyJS 的默认配置，修改 webpack.config.js 中插件的配置，如果默认配置符合你的心意，那么你就运行 <code>webpack -p</code>命令，<code>-p</code> 是 <code>production</code>  的缩写，也就相当于使用 <code>--optimize-minimize</code> 和 <code>--optimize-occurence-order</code> 参数。第一个参数代表压缩 JavaScript，第二个参数优化打包文件中各个模块的加载顺序，使得文件更小运行速度更快。这个仓库已经挺久了，那会我还不知道 <code>-p</code> 这个参数，所以我决定示例保持原样，能给你一点启发。另外一个你能用到的参数是 <code>-d</code>，这样 webpack 在执行时会展示更多的调试信息，并会生成不带额外信息的 sourcemaps。如果这些对你都很简单，你可以在了解更多 <a href=\"http://webpack.github.io/docs/cli.html\" target=\"_blank\" rel=\"noopener\">命令行简写</a> 的知识。</p>\n<h2 id=\"懒加载\">懒加载</h2>\n<p>我最喜欢的 RequireJS 的一点是可以懒加载模块。一个超大的 JavaScript 文件可以减少请求数，但是也导致用户没有使用到的代码也被下载了下来。</p>\n<p>Webpack 有一种方法可以将文件分割成多个懒加载的块，甚至你都不需要在配置文件中做什么配置。你只需要写点代码，Webpack 会处理剩下的事情。Webpack 提供了两种方法，一种基于 CommonJS，一种基于 AMD。使用 CommonJS 的话，看起来是这样：</p>\n<pre><code class=\"language-js\">require.ensure([&quot;module-a&quot;, &quot;module-b&quot;], function(require) {\n    var a = require(&quot;module-a&quot;);\n    var b = require(&quot;module-b&quot;);\n    // …\n});\n</code></pre>\n<p>使用 <code>require.ensure</code>，保证模块是可用的（但不执行它），传入模块的数组和一个回调。为了在回调中真正的使用这个回调，你需要使用回调的参数 <code>require</code> 显式的引入这些模块。</p>\n<p>个人感觉，这种使用方法不太好，让我们看一下 AMD 的版本：</p>\n<pre><code class=\"language-js\">require([&quot;module-a&quot;, &quot;module-b&quot;], function(a, b) {\n    // …\n});\n</code></pre>\n<p>AMD 版本中，使用 <code>require</code> 方法传入模块的数组和一个回调。回调的参数指向这些模块，而且和数组的顺序一致。</p>\n<p>Webpack2 也支持 <code>System.import</code>，使用 promises 而不是回调。这是一个很有用的改进，虽然你如果你真的想用 promise，这也不是难事。不过注意，<code>System.import</code> 已经废弃，因为已经有了新的 <code>import()</code> 规范。在 Babel（或者TypeScript）使用会抛出语法错误。你可以使用 <a href=\"https://www.npmjs.com/package/babel-plugin-dynamic-import-webpack\" target=\"_blank\" rel=\"noopener\"> babel-plugin-dynamic-import-webpack</a>，但它会将 <code>System.import</code> 转换为 <code>require.ensure</code>，而不仅仅帮助 Babel 查看合法的 <code>import</code> 参数，这样 Webpack 就可以处理了。AMD 和 <code>require.ensure</code> 短时间不会消失，<code>System.import</code> 至少要到 Webpack3 才会支持，所以尽情的事情你喜欢的方式。（<em>译者注：这段有点懵逼</em>）</p>\n<p>让我们增加一点代码，等待几秒钟，懒加载 handlebar 模板并将结果输出到页面上。我们移除掉文件顶部的 <code>import</code>，然后用 <code>setTimeout</code> 包起来，使用 AMD 方式 <code>require</code> 这段模板：</p>\n<pre><code class=\"language-js\">import { map } from 'lodash';\n\nlet numbers = map([1,2,3,4,5,6], n =&gt; n*n);\n\nsetTimeout( () =&gt; {\n    require(['./numberlist.hbs'], template =&gt; {\n        document.getElementById(&quot;app-container&quot;).innerHTML = template({numbers});\n    })\n}, 2000);\n</code></pre>\n<p>现在运行 <code>npm start</code>，你会看到生成了另外一个资源，应该是 <code>1.bundle.js</code>。打开浏览器的开发者工具，切到 Network 面板，你会看到两秒后，一个新的文件加载进来，并执行。这并不难实现，但是却减少了文件的体积，增强了用户体验。</p>\n<p>注意：这些子模块包括他们的所有依赖，都被包含在他们的父模块中。（你可以有多个入口，懒加载不同的模块，这样不同的模块就被加载进了各个父模块中）。（<em>译者注： 翻译待加强</em>）</p>\n<h2 id=\"创建-vendor-chunk\">创建 Vendor Chunk</h2>\n<p>让我们继续讨论一些优化点：vendor chunks。你可以定义一些单独的文件，用来保存一些通用的或者第三方的代码，这些代码通常不怎么变化。这样用户就可以先缓存这些文件。当你更新应用的时候，就不必再重新下载这些代码了。</p>\n<p>为了做到这一点，我们需要使用 webpack 自带的一个插件：<code>CommonsChunkPlugin</code>。这是 webpack 自带的插件，所有我们不用额外安装什么。只要编辑配置文件即可：</p>\n<pre><code class=\"language-js\">var HtmlwebpackPlugin = require('html-webpack-plugin');\nvar UglifyJsPlugin = require('webpack/lib/optimize/UglifyJsPlugin');\nvar CommonsChunkPlugin = require('webpack/lib/optimize/CommonsChunkPlugin');\n\nmodule.exports = {\n    entry: {\n        vendor: ['babel-polyfill', 'lodash'],\n        main: './src/main.js'\n    },\n    output: {\n        path: './dist',\n        filename: 'bundle.js'\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.jsx?$/, loader: 'babel-loader', exclude: /node_modules/,\n                options: { plugins: ['transform-runtime'], presets: ['es2015'] }\n            },\n            { test: /\\.hbs$/, loader: 'handlebars-loader' }\n        ]\n    },\n    plugins: [\n        new HtmlwebpackPlugin({\n            title: 'Intro to webpack',\n            template: 'src/index.html'\n        }),\n        new UglifyJsPlugin({\n            beautify: false,\n            mangle: { screw_ie8 : true },\n            compress: { screw_ie8: true, warnings: false },\n            comments: false\n        }),\n        new CommonsChunkPlugin({\n            name: &quot;vendor&quot;,\n            filename: &quot;vendor.bundle.js&quot;\n        })\n    ]\n};\n</code></pre>\n<p>在第三行，我们引入了这个插件，<code>entry</code> 入口，我们使用对象字面量来声明多入口文件，<code>vendor</code> 入口标识那些被包含进 vendor chunks 的文件 - 这里我们包含了 polyfill 和 lodash，我们把应用的代码放进 <code>main.js</code> 内。然后只要在 plugins 入口增加 <code>CommonsChunkPlugin</code> 插件，在插件中声明 <code>vendor</code> 出口并且 vendor chunks 的代码命名为 <code>vendor.bundle.js</code>。</p>\n<p>通过声明 vendor chunks，这个插件会把这个 chunks 的所有依赖从入口文件抽离出来放到 vendor chunks 中。如果你声明 vendor 的名字，它会根据入口的依赖文件生成一个单独的文件。</p>\n<p>当你运行 webpack 后，你会看到生成了三个 JavaScript 文件：<code>bundle.js</code>、<code>1.bundle.js</code>、<code>vendor.bundle.js</code>。如果你喜欢的话，可以再次运行 <code>npm start</code> 在浏览器中查看结果。看起来 webpack 是在应用的主代码中处理 vendor chunks 的加载，真的很有用！</p>\n<p>这就是 <code>example8</code> 的所有内容，也是本教程的所有内容。我讲到了很多，但也只是 webpack 的一小部分而已。webpack 包括了更加简单的 CSS 模块、缓存（cache-busting）hash、图片优化等等很多很多，每一点都可以长篇大论。我不能给你展示所有的知识点，而且等我写完了，好多都已经过时了！所以尝试一下 webpack，让我知道提高了你的工作效率！</p>\n<p>上帝保佑，happy coding！</p>\n<hr>\n<p>文章是在太长，分成上下两部分。<br>\n原文地址：<a href=\"https://www.smashingmagazine.com/2017/02/a-detailed-introduction-to-webpack/\" target=\"_blank\" rel=\"noopener\">A Detailed Introduction To Webpack</a></p>\n<hr>\n<p>翻译水平实在有限 ~ 如果有疑惑可以直接运行仓库例子 ~</p>\n","site":{"data":{}},"excerpt":"","more":"<p>JavaScript 模块打包工具已经出现有一段时间了。RequireJS 在2009年完成了第一次提交，然后 Browserify 随之出现，从那时候起相继出现了各种模块打包工具。在这些里面，webpack脱颖而出。如果你还不熟悉它，我希望这篇文章可以帮你开始使用这个强大的工具。</p>\n<p>本文承接<a href=\"/2017/03/13/a-detailed-introduction-to-webpack-1.html\">详解 Webpack（上）</a></p>\n<h2 id=\"使用插件\">使用插件</h2>\n<p>插件为 webpack 提供了一些实用性的功能。你有充分的自由将它们加入到 webpack 的工作流中，不像 loaders，插件并不限制用于某些文件。它们可以注入到任何地方，所以能做的就更多。很难去解释清插件到底能做什么，所以我只是告诉一个<a href=\"https://www.npmjs.com/search?q=webpack-plugin\" target=\"_blank\" rel=\"noopener\">名为 webpack-plugin npm 包的列表</a>，应该能够很好的说明这一点。</p>\n<p>在本教程中，我们仅接触两个插件（另一个稍后使用）。这篇文章到这里已经很长了，那我们就继续来一个插件的 demo。第一个我们要使用的插件是 <a href=\"https://github.com/ampedandwired/html-webpack-plugin\" target=\"_blank\" rel=\"noopener\">HTML Webpack Plugin</a>，这个插件可以创建一个 HTML - 我们终于可以使用这个 web 应用了！</p>\n<p>在使用这个插件之前，先更新一下 <code>scripts</code>，安装一个简单的 web 服务器来测试我们的页面。首先安装：<code>npm i -D http-server</code>，然后，然后我们修改 <code>execute</code> 为 <code>server</code>，并相应的更新 <code>start</code> 脚本：</p>\n<pre><code class=\"language-json\">&quot;scripts&quot;: {\n  &quot;prebuild&quot;: &quot;del-cli dist -f&quot;,\n  &quot;build&quot;: &quot;webpack&quot;,\n  &quot;server&quot;: &quot;http-server ./dist&quot;,\n  &quot;start&quot;: &quot;npm run build -s &amp;&amp; npm run server -s&quot;\n},\n</code></pre>\n<p>webpack 构建完毕后，<code>npm start</code> 也会创建一个 web 服务器，你可以 访问<code>localhost:8080</code> 查看页面。当然，首先我们要先使用这个插件创建一个页面，安装插件：<code>npm i -D html-webpack-plugin</code>。</p>\n<p>安装完成后，我们需要修改 <code>webpack.config.js</code>：</p>\n<pre><code class=\"language-js\">var HtmlwebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n    entry: [\n        'babel-polyfill',\n        './src/main.js'\n    ],\n    output: {\n        path: './dist',\n        filename: 'bundle.js'\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.jsx?$/, loader: 'babel-loader', exclude: /node_modules/,\n                options: { plugins: ['transform-runtime'], presets: ['es2015'] }\n            },\n            { test: /\\.hbs$/, loader: 'handlebars-loader' }\n        ]\n    },\n    plugins: [\n        new HtmlwebpackPlugin()\n    ]\n};\n</code></pre>\n<p>我们主要做了两处修改：在文件顶部引入了插件，并在配置对象中添加 <code>plugins</code> 属性，传入了插件的实例。</p>\n<p>现在，我们没有给插件传入任何选项，所以它会生成标准的模板，虽然没有包含什么，但已经包含了我们打包的脚本。如果你运行 <code>npm start</code>，你在浏览器中会看见一个空白页，不过如果你打开控制台，就会看到有 HTML 输出。</p>\n<p>我们要将模板和 HTML 文件输出到页面而不仅仅是控制台中，普通人会从页面中看到一些东西（而不是空白页），首先在 <code>src</code> 目录下新建 <code>index.html</code> 文件，默认他会使用 EJS 作为模板引擎，不过你也可以插件使用<a href=\"https://github.com/ampedandwired/html-webpack-plugin/blob/master/docs/template-option.md\" target=\"_blank\" rel=\"noopener\">其他的模板引擎</a>。我们将使用默认的 EJS 模板，下面是文件的内容：</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h2&gt;This is my Index.html Template&lt;/h2&gt;\n    &lt;div id=&quot;app-container&quot;&gt;&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>你会注意到一些点：</p>\n<ul>\n<li>我们可以使用插件的一个选项设置 HTML 标题。</li>\n<li>不必手动设置该添加的脚本。因为它会默认在 <code>body</code> 底部添加脚本。</li>\n<li>这里有一个 <code>div</code> 和 <code>id</code>，现在我们就要使用它们。</li>\n</ul>\n<p>有了模板后，至少现在不再是一个空白页面。更新 <code>main.js</code>，将 HTML 添加到 <code>div</code>，而不是打印到控制台中。在 <code>main.js</code> 最后添加一行：</p>\n<pre><code class=\"language-js\">document.getElementById(&quot;app-container&quot;).innerHTML = template({numbers});\n</code></pre>\n<p>同时也要更新 webpack 的配置，给插件传递几个选项，现在你的配置文件变成这样：</p>\n<pre><code class=\"language-js\">var HtmlwebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n    entry: [\n        'babel-polyfill',\n        './src/main.js'\n    ],\n    output: {\n        path: './dist',\n        filename: 'bundle.js'\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.jsx?$/, loader: 'babel-loader', exclude: /node_modules/,\n                options: { plugins: ['transform-runtime'], presets: ['es2015'] }\n            },\n            { test: /\\.hbs$/, loader: 'handlebars-loader' }\n        ]\n    },\n    plugins: [\n        new HtmlwebpackPlugin({\n            title: 'Intro to webpack',\n            template: 'src/index.html'\n        })\n    ]\n};\n</code></pre>\n<p><code>template</code> 选项声明了在模板的所在位置，<code>title</code>选项是传递给模板的标题，现在运行 <code>npm start</code>，你会在浏览器看到以下内容：</p>\n<p><img src=\"https://www.smashingmagazine.com/wp-content/uploads/2017/02/index-html-template-opt.png\" alt=\"index-html-template-opt.png\"></p>\n<p>到这里我们完成了 <code>example5</code> 分支的所有工作。每个插件都有不同的选项和配置，有太多的插件，它们能做各种各样的事情。最后它们都会添加到 webpack 配置项 <code>plugins</code> 数组里。这里有很多方法去处理如何生成 HTML 页面，去填充页面内容，以及给页面添加带 hash 值得文件名（<em>译者注：应该是带 hash值的脚本文件或者 css 文件</em>）</p>\n<p>在 <code>example6</code> 分支里，我通过一个插件增加了压缩 JavaScript 文件的功能，除非你想用 UglifyJS 做一些改变，要不你无需做其他事情。如果不喜欢 UglifyJS 的默认配置，修改 webpack.config.js 中插件的配置，如果默认配置符合你的心意，那么你就运行 <code>webpack -p</code>命令，<code>-p</code> 是 <code>production</code>  的缩写，也就相当于使用 <code>--optimize-minimize</code> 和 <code>--optimize-occurence-order</code> 参数。第一个参数代表压缩 JavaScript，第二个参数优化打包文件中各个模块的加载顺序，使得文件更小运行速度更快。这个仓库已经挺久了，那会我还不知道 <code>-p</code> 这个参数，所以我决定示例保持原样，能给你一点启发。另外一个你能用到的参数是 <code>-d</code>，这样 webpack 在执行时会展示更多的调试信息，并会生成不带额外信息的 sourcemaps。如果这些对你都很简单，你可以在了解更多 <a href=\"http://webpack.github.io/docs/cli.html\" target=\"_blank\" rel=\"noopener\">命令行简写</a> 的知识。</p>\n<h2 id=\"懒加载\">懒加载</h2>\n<p>我最喜欢的 RequireJS 的一点是可以懒加载模块。一个超大的 JavaScript 文件可以减少请求数，但是也导致用户没有使用到的代码也被下载了下来。</p>\n<p>Webpack 有一种方法可以将文件分割成多个懒加载的块，甚至你都不需要在配置文件中做什么配置。你只需要写点代码，Webpack 会处理剩下的事情。Webpack 提供了两种方法，一种基于 CommonJS，一种基于 AMD。使用 CommonJS 的话，看起来是这样：</p>\n<pre><code class=\"language-js\">require.ensure([&quot;module-a&quot;, &quot;module-b&quot;], function(require) {\n    var a = require(&quot;module-a&quot;);\n    var b = require(&quot;module-b&quot;);\n    // …\n});\n</code></pre>\n<p>使用 <code>require.ensure</code>，保证模块是可用的（但不执行它），传入模块的数组和一个回调。为了在回调中真正的使用这个回调，你需要使用回调的参数 <code>require</code> 显式的引入这些模块。</p>\n<p>个人感觉，这种使用方法不太好，让我们看一下 AMD 的版本：</p>\n<pre><code class=\"language-js\">require([&quot;module-a&quot;, &quot;module-b&quot;], function(a, b) {\n    // …\n});\n</code></pre>\n<p>AMD 版本中，使用 <code>require</code> 方法传入模块的数组和一个回调。回调的参数指向这些模块，而且和数组的顺序一致。</p>\n<p>Webpack2 也支持 <code>System.import</code>，使用 promises 而不是回调。这是一个很有用的改进，虽然你如果你真的想用 promise，这也不是难事。不过注意，<code>System.import</code> 已经废弃，因为已经有了新的 <code>import()</code> 规范。在 Babel（或者TypeScript）使用会抛出语法错误。你可以使用 <a href=\"https://www.npmjs.com/package/babel-plugin-dynamic-import-webpack\" target=\"_blank\" rel=\"noopener\"> babel-plugin-dynamic-import-webpack</a>，但它会将 <code>System.import</code> 转换为 <code>require.ensure</code>，而不仅仅帮助 Babel 查看合法的 <code>import</code> 参数，这样 Webpack 就可以处理了。AMD 和 <code>require.ensure</code> 短时间不会消失，<code>System.import</code> 至少要到 Webpack3 才会支持，所以尽情的事情你喜欢的方式。（<em>译者注：这段有点懵逼</em>）</p>\n<p>让我们增加一点代码，等待几秒钟，懒加载 handlebar 模板并将结果输出到页面上。我们移除掉文件顶部的 <code>import</code>，然后用 <code>setTimeout</code> 包起来，使用 AMD 方式 <code>require</code> 这段模板：</p>\n<pre><code class=\"language-js\">import { map } from 'lodash';\n\nlet numbers = map([1,2,3,4,5,6], n =&gt; n*n);\n\nsetTimeout( () =&gt; {\n    require(['./numberlist.hbs'], template =&gt; {\n        document.getElementById(&quot;app-container&quot;).innerHTML = template({numbers});\n    })\n}, 2000);\n</code></pre>\n<p>现在运行 <code>npm start</code>，你会看到生成了另外一个资源，应该是 <code>1.bundle.js</code>。打开浏览器的开发者工具，切到 Network 面板，你会看到两秒后，一个新的文件加载进来，并执行。这并不难实现，但是却减少了文件的体积，增强了用户体验。</p>\n<p>注意：这些子模块包括他们的所有依赖，都被包含在他们的父模块中。（你可以有多个入口，懒加载不同的模块，这样不同的模块就被加载进了各个父模块中）。（<em>译者注： 翻译待加强</em>）</p>\n<h2 id=\"创建-vendor-chunk\">创建 Vendor Chunk</h2>\n<p>让我们继续讨论一些优化点：vendor chunks。你可以定义一些单独的文件，用来保存一些通用的或者第三方的代码，这些代码通常不怎么变化。这样用户就可以先缓存这些文件。当你更新应用的时候，就不必再重新下载这些代码了。</p>\n<p>为了做到这一点，我们需要使用 webpack 自带的一个插件：<code>CommonsChunkPlugin</code>。这是 webpack 自带的插件，所有我们不用额外安装什么。只要编辑配置文件即可：</p>\n<pre><code class=\"language-js\">var HtmlwebpackPlugin = require('html-webpack-plugin');\nvar UglifyJsPlugin = require('webpack/lib/optimize/UglifyJsPlugin');\nvar CommonsChunkPlugin = require('webpack/lib/optimize/CommonsChunkPlugin');\n\nmodule.exports = {\n    entry: {\n        vendor: ['babel-polyfill', 'lodash'],\n        main: './src/main.js'\n    },\n    output: {\n        path: './dist',\n        filename: 'bundle.js'\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.jsx?$/, loader: 'babel-loader', exclude: /node_modules/,\n                options: { plugins: ['transform-runtime'], presets: ['es2015'] }\n            },\n            { test: /\\.hbs$/, loader: 'handlebars-loader' }\n        ]\n    },\n    plugins: [\n        new HtmlwebpackPlugin({\n            title: 'Intro to webpack',\n            template: 'src/index.html'\n        }),\n        new UglifyJsPlugin({\n            beautify: false,\n            mangle: { screw_ie8 : true },\n            compress: { screw_ie8: true, warnings: false },\n            comments: false\n        }),\n        new CommonsChunkPlugin({\n            name: &quot;vendor&quot;,\n            filename: &quot;vendor.bundle.js&quot;\n        })\n    ]\n};\n</code></pre>\n<p>在第三行，我们引入了这个插件，<code>entry</code> 入口，我们使用对象字面量来声明多入口文件，<code>vendor</code> 入口标识那些被包含进 vendor chunks 的文件 - 这里我们包含了 polyfill 和 lodash，我们把应用的代码放进 <code>main.js</code> 内。然后只要在 plugins 入口增加 <code>CommonsChunkPlugin</code> 插件，在插件中声明 <code>vendor</code> 出口并且 vendor chunks 的代码命名为 <code>vendor.bundle.js</code>。</p>\n<p>通过声明 vendor chunks，这个插件会把这个 chunks 的所有依赖从入口文件抽离出来放到 vendor chunks 中。如果你声明 vendor 的名字，它会根据入口的依赖文件生成一个单独的文件。</p>\n<p>当你运行 webpack 后，你会看到生成了三个 JavaScript 文件：<code>bundle.js</code>、<code>1.bundle.js</code>、<code>vendor.bundle.js</code>。如果你喜欢的话，可以再次运行 <code>npm start</code> 在浏览器中查看结果。看起来 webpack 是在应用的主代码中处理 vendor chunks 的加载，真的很有用！</p>\n<p>这就是 <code>example8</code> 的所有内容，也是本教程的所有内容。我讲到了很多，但也只是 webpack 的一小部分而已。webpack 包括了更加简单的 CSS 模块、缓存（cache-busting）hash、图片优化等等很多很多，每一点都可以长篇大论。我不能给你展示所有的知识点，而且等我写完了，好多都已经过时了！所以尝试一下 webpack，让我知道提高了你的工作效率！</p>\n<p>上帝保佑，happy coding！</p>\n<hr>\n<p>文章是在太长，分成上下两部分。<br>\n原文地址：<a href=\"https://www.smashingmagazine.com/2017/02/a-detailed-introduction-to-webpack/\" target=\"_blank\" rel=\"noopener\">A Detailed Introduction To Webpack</a></p>\n<hr>\n<p>翻译水平实在有限 ~ 如果有疑惑可以直接运行仓库例子 ~</p>\n"},{"layout":"post","title":"我眼中的 Electron","banner":"assets/img/electron.jpg","_content":"\n\n这是去年年底写的关于 Electron 的总结，搬运到新的博客里面，做了微小的修改。\n\n---\n\n之前发过一个装逼的朋友圈：感谢 Electron，我现在有两个身份了：前端开发和 Mac 端开发。\n\n今年开始了一个全新的产品，但项目组并没有 Mac 的开发人员，然后我们前端就顺利的扛下了这面大旗，并且选择了火爆的 [Electron](http://electron.atom.io/)（4w+ star）。\n\n年底了，看大家在写各种各样的年终总结，想着我和 Electron 也打情骂俏了好几个月，也该写点东西。不过 Electron 已经够火了，能 google 到很多类似如何使用 Electron 开发桌面端应用的文章，比如[用Electron开发桌面应用](http://get.ftqq.com/7870.get)，也能找到[官方中文文档](https://github.com/electron/electron/tree/master/docs-translations/zh-CN)，虽然滞后了一点。所以我也就不再赘述怎样从头写一个 Electron 应用了，在阅读下面的内容之前，最好能先跟随官方的 [Quick Start](http://electron.atom.io/docs/tutorial/quick-start/) 走一遍。\n\n## 为什么选择 Electron\n\n> Electron提供了一个Nodejs的运行时，专注于构建桌面应用，同时使用web页面来作为应用的GUI，你可以将其看作是一个由JavaScript控制的迷你版的Chromium浏览器。\n\n够火自不必说，Electron 的作者和 NW.js（原 node-webkit）是同一人，大家可以去知乎围观[维护一个大型开源项目是怎样的体验？](https://www.zhihu.com/question/36292298/answer/102418523)这个问题下作者的回答（评论区提出该知乎问题下还有一个回答对此存有异议：https://www.zhihu.com/question/36292298/answer/136521303，大家自行分辨）。官方也有 [Electron 和 NW.js 的对比](http://electron.atom.io/docs/development/atom-shell-vs-node-webkit/)，相信作者在新的项目中有了新的思考，所以选择 Electron 是个对的选择，并且我们只需要开发 Mac 端（组内有 Windows 开发人员），没有对 XP 系统兼容的要求。\n\n也有考虑过像 [MacGap](https://github.com/MacGapProject) 这样的解决方案，不过 MacGap 是基于 webkit 内核的，并不支持 IndexedDB，而我们的项目依赖的第三方服务是依赖 IndexedDB 做为本地存储的。并且 Electron 更强大，比如新开 webview 加载第三方页面，并且可以预加载(preload) JavaScript来作为 jssdk 供 web 应用使用。\n\n所以 Electron，就是你了！\n\n## 主进程和渲染进程\n\n个人感觉，理解 Electron 最重要应该就是理解主进程（Main Process）和渲染进程（Render Process）了。理解了这两者，其他内容花费些时间查查API文档即可。\n\nElectron 中，入口是一个 js 文件（和 NW.js 不同，入口是 html 文件），运行这个入口文件（通常会是 package.json 里的 main 脚本）的进程称作主进程，在主进程使用 `BrowserWindow` 模块可以创建并管理 web 页面，也就是应用的 GUI。\n\n```js\nconst {BrowserWindow} = require('electron')\n// 主进程创建web页面\nlet someWindow = new BrowserWindow(winOpts)\n// 加载本地的文件\nsomeWindow.loadURL('file://' + __dirname + '/index.html')\n```\n\n在主进程创建的一个个web页面也都运行着自己的进程，即渲染进程，渲染进程各自独立，各自管理自己的页面，可以想象是浏览器一个个的 tab。\n\n## 进程间通信\n\n我们知道，Web 页面因为安全限制，不能直接访问原生的GUI资源（比如[dialog](http://electron.atom.io/docs/api/dialog/)、[电源监控](http://electron.atom.io/docs/api/power-monitor/)），Electron 中也是一样，渲染进程如果想要进行原生的GUI操作，就必须和主进程通讯，请求相应的GUI操作。\n\nElectron 提供了几种渲染进程和主进程通信的方式：\n\n一种是使用[ipcMain](https://github.com/electron/electron/blob/v1.1.3/docs/api/ipc-main.md)和[ipcRenderer](https://github.com/electron/electron/blob/v1.1.3/docs/api/ipc-renderer.md)模块，在渲染进程中使用ipcRender模块向主进程发送消息，主进程中ipcMain接收消息，进行操作，如果还需要反馈，则通知渲染进程，渲染进程根据接收的内容执行相应的操作：\n\n```js\n\n// 渲染进程中\nconst {ipcRenderer} = require('electron')\nipcRender.send('somemsg', data);\nipcRender.on('replaymsg', (evt, otherData) => {\n    console.log(otherData)\n})\n\n// 主进程中\nconst {ipcMain} = require('electron')\nipcMain.on('somemsg', (evt, data) => {\n    console.log(data)\n    evt.sender.send('replymsg', otherData);\n});\n\n// 同时Electron 也提供了同步的方式\n```\n\n**不过切忌用 ipc 传递大量的数据，会有很大的性能问题，严重会让你整个应用卡住。**\n\n第二种是直接在渲染进程使用[remote](http://electron.atom.io/docs/api/remote/)模块，remote 模块可以直接获取主进程中的模块。这种方式其实是第一种方式的简化。\n\n```js\n// 在渲染进程打开提示对话框\nconst {dialog} = require('electron').remote\ndialog.showMessageBox({ opts });\n```\n\n\n第三种是主进程向渲染进程发送消息\n\n```js\nthis.webviewWindow.webContents.send('ping');\n```\n\n第四种是渲染进程之间的通信\n\n如果数据不需要实时性，只是渲染进程之间数据的共享，那么使用官方的建议即可：[How to share data between web pages?](http://electron.atom.io/docs/faq/#how-to-share-data-between-web-pages)。如果要求实时性，需要在创建窗口时获取窗口的 id，在其他渲染进程中通过 id 获取窗口实例进行消息发送。\n\n```js\n// 主进程\n// 两个窗口互相获取对方的窗口 id, 并发送给渲染进程\nwin1.webContents.send('distributeIds',{\n    win2Id : win2.id\n});\nwin2.webContents.send('distributeIds',{\n    win1Id : win1.id\n});\n\n// 渲染进程\n// 通过 id 得到窗口\nremote.BrowserWindow.fromId(win2Id).webContents.send('someMsg', 'someThing');\n```\n\n## Nodejs集成\n\nElectron 内集成了 Nodejs，大大的方便了开发。Nodejs 在主进程和渲染进程中都可以使用，上面说到，渲染进程因为安全限制，不能直接操作原生 GUI。虽然如此，因为集成了 Nodejs，渲染进程也有了操作系统底层 API 的能力，Nodejs 中常用的 Path、fs、Crypto 等模块在 Electron 可以直接使用，方便我们处理链接、路径、文件MD5等，同时npm还有成千上万的模块供我们选择。\n\n尤其对于 Electron 不方便实现的功能，Nodejs 可能有奇效。我们应用中用户需要下载文件消息的文件，需要支持同事下载多个，并且需要给出进度，Electron 并没有提供一个好用的下载接口，所以我们使用 Nodejs 的 `http`、`fs` 模块结合 Electron 的 dialog 模块实现了文件下载，并且实现了下载进度以及下载超时错误提示。\n\n## HTML5增强\n\n不考虑兼容性应该是前端码农的梦想之一吧。Electron 使用 Chromium 来展示 web 页面，也就是我们开发只需要兼容 Chromium 浏览器即可，也就是说好多属性可以肆无忌惮的用：播放语音直接使用 HTML5 audio、大量数据存储使用数据库 IndexedDB、难搞的布局直接使用 Flexbox、方便的检测在线离线等等。\n\n同时 Electron 对一些 HTML5 的特性进行了增强：\n* 桌面通知，你可以直接使用 html5 的 notification，Electron会将其转化成为系统原生的桌面通知；\n* File 对象，在Web应用中我们能得到的一般是类似 `C:/fakePath/xxx.docx` 的假路径，Electron在 File 对象上增加了一个path属性，可以用来获取选择的文件在文件系统中的真实路径。\n* `a` 标签的 download 属性，在 Web 应用中 `a` 标签增加 download 属性会强制浏览器下载，Electron 中会直接调起系统下载框下载，如果没有特殊需求推荐这种方式。\n\n\n渲染进程调试和在浏览器中的调试完全一致。前面提到每个渲染进程完全独立，当你创建了多个web页面，每个页面都可以打开对应了调试工具，你可以和浏览器调试一样查看DOM、查看log、监听网络请求等等。\n同时 Electron 集成了 Nodejs，所以你在控制台或者断点时也能够调试 Nodejs 的 API，甚至因为渲染进程可以使用 remote 模块直接使用主进程的模块，你可以直接获取到这些数据以方便调试。\n\n## Electron 中的 Webview\n\n这次的新产品有一个需求，需要在客户端内加载 Webview 应用，并且要提供 jssdk 供 Web 应用使用，以获取更多的本地能力。其实 Electron 天然的优势可以加载外部应用的。但是要考虑的问题还是比较多的，比如要展示页面加载的进度、监听页面何时加载完成、页面 DOM 何时加载完成、服务端一些302重定向如何（比如一些跳转认证）处理、如何给 Web 应用提供 jssdk 等等。\n\nElectron 提供了一系列的事件来监听页面的加载，细化到了页面开始加载、页面加载完成、页面加载失败、DOM Ready、框架加载 (`did-frame-finish-load`)、重定向（`did-get-redirect-request`）等等，通过监听这些事件可以对页面状态进行处理。\n\n另外，如何给 Web 应用提供 jssdk 呢？我们需要依赖 [`BrowserWindow`](http://electron.atom.io/docs/api/browser-window/) 的一个配置项 - `preload`，preload 允许你指定一段脚本在页面加载之前载入，这段脚本你可以使用 Electron 和 Nodejs 的 API，即使你在配置中不允许使用 Nodejs。\n\n```js\n\n// preload 示例\nvar opts = {\n    autoHideMenuBar: true,\n    fullscreenable: false,\n    webPreferences: {\n        javascript: true,\n        plugins: true,\n        nodeIntegration: false, // 不集成 Nodejs\n        webSecurity: false,\n        preload: path.join(__dirname, 'preload/window_sdk.js') // 但预加载的 js 文件内仍可以使用 Nodejs 的 API\n    }\n}\n\nthis.webviewWindow = new BrowserWindow(opts);\n\n```\n\n预加载 js 文件与其他 js 并无二致，你只要根据你的业务，在 preload 的 js 中使用 remote 或者 ipc 通信给你的 Web 应用提供够用接口就好了。\n\n## 写在后面\n\nElectron 并不是很复杂，在写完不多的主进程代码后，其他的业务代码几乎和 Web 应用没什么区别，甚至可以将一个线上应用迅速的包装成为一个客户端应用，比如[electronic-wechat](https://github.com/geeeeeeeeek/electronic-wechat)、[worktile桌面端](https://worktile.com/)。\n不过坑不可避免（比如无法将 gif 写入剪切板等等），有时候也会感到很难像 Native 那样灵活，虽然如此，我还是很欣慰能有这样的工具，让我们前端可以做更多的事情。\n\n最后一点想说的是开发思维的转变，比如在客户端开发中本地数据库的存储十分常见，在前端 Web 开发中可能很少会接触到，比如我们这次就用 IndexedDB 本地存储了大量的数据。\n\n\n\n","source":"_posts/electron-in-my-view.md","raw":"\nlayout: post\ntitle: 我眼中的 Electron \nbanner: assets/img/electron.jpg\ntags: electron\n---\n\n\n这是去年年底写的关于 Electron 的总结，搬运到新的博客里面，做了微小的修改。\n\n---\n\n之前发过一个装逼的朋友圈：感谢 Electron，我现在有两个身份了：前端开发和 Mac 端开发。\n\n今年开始了一个全新的产品，但项目组并没有 Mac 的开发人员，然后我们前端就顺利的扛下了这面大旗，并且选择了火爆的 [Electron](http://electron.atom.io/)（4w+ star）。\n\n年底了，看大家在写各种各样的年终总结，想着我和 Electron 也打情骂俏了好几个月，也该写点东西。不过 Electron 已经够火了，能 google 到很多类似如何使用 Electron 开发桌面端应用的文章，比如[用Electron开发桌面应用](http://get.ftqq.com/7870.get)，也能找到[官方中文文档](https://github.com/electron/electron/tree/master/docs-translations/zh-CN)，虽然滞后了一点。所以我也就不再赘述怎样从头写一个 Electron 应用了，在阅读下面的内容之前，最好能先跟随官方的 [Quick Start](http://electron.atom.io/docs/tutorial/quick-start/) 走一遍。\n\n## 为什么选择 Electron\n\n> Electron提供了一个Nodejs的运行时，专注于构建桌面应用，同时使用web页面来作为应用的GUI，你可以将其看作是一个由JavaScript控制的迷你版的Chromium浏览器。\n\n够火自不必说，Electron 的作者和 NW.js（原 node-webkit）是同一人，大家可以去知乎围观[维护一个大型开源项目是怎样的体验？](https://www.zhihu.com/question/36292298/answer/102418523)这个问题下作者的回答（评论区提出该知乎问题下还有一个回答对此存有异议：https://www.zhihu.com/question/36292298/answer/136521303，大家自行分辨）。官方也有 [Electron 和 NW.js 的对比](http://electron.atom.io/docs/development/atom-shell-vs-node-webkit/)，相信作者在新的项目中有了新的思考，所以选择 Electron 是个对的选择，并且我们只需要开发 Mac 端（组内有 Windows 开发人员），没有对 XP 系统兼容的要求。\n\n也有考虑过像 [MacGap](https://github.com/MacGapProject) 这样的解决方案，不过 MacGap 是基于 webkit 内核的，并不支持 IndexedDB，而我们的项目依赖的第三方服务是依赖 IndexedDB 做为本地存储的。并且 Electron 更强大，比如新开 webview 加载第三方页面，并且可以预加载(preload) JavaScript来作为 jssdk 供 web 应用使用。\n\n所以 Electron，就是你了！\n\n## 主进程和渲染进程\n\n个人感觉，理解 Electron 最重要应该就是理解主进程（Main Process）和渲染进程（Render Process）了。理解了这两者，其他内容花费些时间查查API文档即可。\n\nElectron 中，入口是一个 js 文件（和 NW.js 不同，入口是 html 文件），运行这个入口文件（通常会是 package.json 里的 main 脚本）的进程称作主进程，在主进程使用 `BrowserWindow` 模块可以创建并管理 web 页面，也就是应用的 GUI。\n\n```js\nconst {BrowserWindow} = require('electron')\n// 主进程创建web页面\nlet someWindow = new BrowserWindow(winOpts)\n// 加载本地的文件\nsomeWindow.loadURL('file://' + __dirname + '/index.html')\n```\n\n在主进程创建的一个个web页面也都运行着自己的进程，即渲染进程，渲染进程各自独立，各自管理自己的页面，可以想象是浏览器一个个的 tab。\n\n## 进程间通信\n\n我们知道，Web 页面因为安全限制，不能直接访问原生的GUI资源（比如[dialog](http://electron.atom.io/docs/api/dialog/)、[电源监控](http://electron.atom.io/docs/api/power-monitor/)），Electron 中也是一样，渲染进程如果想要进行原生的GUI操作，就必须和主进程通讯，请求相应的GUI操作。\n\nElectron 提供了几种渲染进程和主进程通信的方式：\n\n一种是使用[ipcMain](https://github.com/electron/electron/blob/v1.1.3/docs/api/ipc-main.md)和[ipcRenderer](https://github.com/electron/electron/blob/v1.1.3/docs/api/ipc-renderer.md)模块，在渲染进程中使用ipcRender模块向主进程发送消息，主进程中ipcMain接收消息，进行操作，如果还需要反馈，则通知渲染进程，渲染进程根据接收的内容执行相应的操作：\n\n```js\n\n// 渲染进程中\nconst {ipcRenderer} = require('electron')\nipcRender.send('somemsg', data);\nipcRender.on('replaymsg', (evt, otherData) => {\n    console.log(otherData)\n})\n\n// 主进程中\nconst {ipcMain} = require('electron')\nipcMain.on('somemsg', (evt, data) => {\n    console.log(data)\n    evt.sender.send('replymsg', otherData);\n});\n\n// 同时Electron 也提供了同步的方式\n```\n\n**不过切忌用 ipc 传递大量的数据，会有很大的性能问题，严重会让你整个应用卡住。**\n\n第二种是直接在渲染进程使用[remote](http://electron.atom.io/docs/api/remote/)模块，remote 模块可以直接获取主进程中的模块。这种方式其实是第一种方式的简化。\n\n```js\n// 在渲染进程打开提示对话框\nconst {dialog} = require('electron').remote\ndialog.showMessageBox({ opts });\n```\n\n\n第三种是主进程向渲染进程发送消息\n\n```js\nthis.webviewWindow.webContents.send('ping');\n```\n\n第四种是渲染进程之间的通信\n\n如果数据不需要实时性，只是渲染进程之间数据的共享，那么使用官方的建议即可：[How to share data between web pages?](http://electron.atom.io/docs/faq/#how-to-share-data-between-web-pages)。如果要求实时性，需要在创建窗口时获取窗口的 id，在其他渲染进程中通过 id 获取窗口实例进行消息发送。\n\n```js\n// 主进程\n// 两个窗口互相获取对方的窗口 id, 并发送给渲染进程\nwin1.webContents.send('distributeIds',{\n    win2Id : win2.id\n});\nwin2.webContents.send('distributeIds',{\n    win1Id : win1.id\n});\n\n// 渲染进程\n// 通过 id 得到窗口\nremote.BrowserWindow.fromId(win2Id).webContents.send('someMsg', 'someThing');\n```\n\n## Nodejs集成\n\nElectron 内集成了 Nodejs，大大的方便了开发。Nodejs 在主进程和渲染进程中都可以使用，上面说到，渲染进程因为安全限制，不能直接操作原生 GUI。虽然如此，因为集成了 Nodejs，渲染进程也有了操作系统底层 API 的能力，Nodejs 中常用的 Path、fs、Crypto 等模块在 Electron 可以直接使用，方便我们处理链接、路径、文件MD5等，同时npm还有成千上万的模块供我们选择。\n\n尤其对于 Electron 不方便实现的功能，Nodejs 可能有奇效。我们应用中用户需要下载文件消息的文件，需要支持同事下载多个，并且需要给出进度，Electron 并没有提供一个好用的下载接口，所以我们使用 Nodejs 的 `http`、`fs` 模块结合 Electron 的 dialog 模块实现了文件下载，并且实现了下载进度以及下载超时错误提示。\n\n## HTML5增强\n\n不考虑兼容性应该是前端码农的梦想之一吧。Electron 使用 Chromium 来展示 web 页面，也就是我们开发只需要兼容 Chromium 浏览器即可，也就是说好多属性可以肆无忌惮的用：播放语音直接使用 HTML5 audio、大量数据存储使用数据库 IndexedDB、难搞的布局直接使用 Flexbox、方便的检测在线离线等等。\n\n同时 Electron 对一些 HTML5 的特性进行了增强：\n* 桌面通知，你可以直接使用 html5 的 notification，Electron会将其转化成为系统原生的桌面通知；\n* File 对象，在Web应用中我们能得到的一般是类似 `C:/fakePath/xxx.docx` 的假路径，Electron在 File 对象上增加了一个path属性，可以用来获取选择的文件在文件系统中的真实路径。\n* `a` 标签的 download 属性，在 Web 应用中 `a` 标签增加 download 属性会强制浏览器下载，Electron 中会直接调起系统下载框下载，如果没有特殊需求推荐这种方式。\n\n\n渲染进程调试和在浏览器中的调试完全一致。前面提到每个渲染进程完全独立，当你创建了多个web页面，每个页面都可以打开对应了调试工具，你可以和浏览器调试一样查看DOM、查看log、监听网络请求等等。\n同时 Electron 集成了 Nodejs，所以你在控制台或者断点时也能够调试 Nodejs 的 API，甚至因为渲染进程可以使用 remote 模块直接使用主进程的模块，你可以直接获取到这些数据以方便调试。\n\n## Electron 中的 Webview\n\n这次的新产品有一个需求，需要在客户端内加载 Webview 应用，并且要提供 jssdk 供 Web 应用使用，以获取更多的本地能力。其实 Electron 天然的优势可以加载外部应用的。但是要考虑的问题还是比较多的，比如要展示页面加载的进度、监听页面何时加载完成、页面 DOM 何时加载完成、服务端一些302重定向如何（比如一些跳转认证）处理、如何给 Web 应用提供 jssdk 等等。\n\nElectron 提供了一系列的事件来监听页面的加载，细化到了页面开始加载、页面加载完成、页面加载失败、DOM Ready、框架加载 (`did-frame-finish-load`)、重定向（`did-get-redirect-request`）等等，通过监听这些事件可以对页面状态进行处理。\n\n另外，如何给 Web 应用提供 jssdk 呢？我们需要依赖 [`BrowserWindow`](http://electron.atom.io/docs/api/browser-window/) 的一个配置项 - `preload`，preload 允许你指定一段脚本在页面加载之前载入，这段脚本你可以使用 Electron 和 Nodejs 的 API，即使你在配置中不允许使用 Nodejs。\n\n```js\n\n// preload 示例\nvar opts = {\n    autoHideMenuBar: true,\n    fullscreenable: false,\n    webPreferences: {\n        javascript: true,\n        plugins: true,\n        nodeIntegration: false, // 不集成 Nodejs\n        webSecurity: false,\n        preload: path.join(__dirname, 'preload/window_sdk.js') // 但预加载的 js 文件内仍可以使用 Nodejs 的 API\n    }\n}\n\nthis.webviewWindow = new BrowserWindow(opts);\n\n```\n\n预加载 js 文件与其他 js 并无二致，你只要根据你的业务，在 preload 的 js 中使用 remote 或者 ipc 通信给你的 Web 应用提供够用接口就好了。\n\n## 写在后面\n\nElectron 并不是很复杂，在写完不多的主进程代码后，其他的业务代码几乎和 Web 应用没什么区别，甚至可以将一个线上应用迅速的包装成为一个客户端应用，比如[electronic-wechat](https://github.com/geeeeeeeeek/electronic-wechat)、[worktile桌面端](https://worktile.com/)。\n不过坑不可避免（比如无法将 gif 写入剪切板等等），有时候也会感到很难像 Native 那样灵活，虽然如此，我还是很欣慰能有这样的工具，让我们前端可以做更多的事情。\n\n最后一点想说的是开发思维的转变，比如在客户端开发中本地数据库的存储十分常见，在前端 Web 开发中可能很少会接触到，比如我们这次就用 IndexedDB 本地存储了大量的数据。\n\n\n\n","slug":"electron-in-my-view","published":1,"date":"2019-01-17T13:00:11.000Z","updated":"2019-01-17T13:00:11.000Z","comments":1,"photos":[],"link":"","_id":"cjr1en2nx000wha9s6xrz69ox","content":"<p>这是去年年底写的关于 Electron 的总结，搬运到新的博客里面，做了微小的修改。</p>\n<hr>\n<p>之前发过一个装逼的朋友圈：感谢 Electron，我现在有两个身份了：前端开发和 Mac 端开发。</p>\n<p>今年开始了一个全新的产品，但项目组并没有 Mac 的开发人员，然后我们前端就顺利的扛下了这面大旗，并且选择了火爆的 <a href=\"http://electron.atom.io/\" target=\"_blank\" rel=\"noopener\">Electron</a>（4w+ star）。</p>\n<p>年底了，看大家在写各种各样的年终总结，想着我和 Electron 也打情骂俏了好几个月，也该写点东西。不过 Electron 已经够火了，能 google 到很多类似如何使用 Electron 开发桌面端应用的文章，比如<a href=\"http://get.ftqq.com/7870.get\" target=\"_blank\" rel=\"noopener\">用Electron开发桌面应用</a>，也能找到<a href=\"https://github.com/electron/electron/tree/master/docs-translations/zh-CN\" target=\"_blank\" rel=\"noopener\">官方中文文档</a>，虽然滞后了一点。所以我也就不再赘述怎样从头写一个 Electron 应用了，在阅读下面的内容之前，最好能先跟随官方的 <a href=\"http://electron.atom.io/docs/tutorial/quick-start/\" target=\"_blank\" rel=\"noopener\">Quick Start</a> 走一遍。</p>\n<h2 id=\"为什么选择-electron\">为什么选择 Electron</h2>\n<blockquote>\n<p>Electron提供了一个Nodejs的运行时，专注于构建桌面应用，同时使用web页面来作为应用的GUI，你可以将其看作是一个由JavaScript控制的迷你版的Chromium浏览器。</p>\n</blockquote>\n<p>够火自不必说，Electron 的作者和 NW.js（原 node-webkit）是同一人，大家可以去知乎围观<a href=\"https://www.zhihu.com/question/36292298/answer/102418523\" target=\"_blank\" rel=\"noopener\">维护一个大型开源项目是怎样的体验？</a>这个问题下作者的回答（评论区提出该知乎问题下还有一个回答对此存有异议：<a href=\"https://www.zhihu.com/question/36292298/answer/136521303%EF%BC%8C%E5%A4%A7%E5%AE%B6%E8%87%AA%E8%A1%8C%E5%88%86%E8%BE%A8%EF%BC%89%E3%80%82%E5%AE%98%E6%96%B9%E4%B9%9F%E6%9C%89\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/36292298/answer/136521303，大家自行分辨）。官方也有</a> <a href=\"http://electron.atom.io/docs/development/atom-shell-vs-node-webkit/\" target=\"_blank\" rel=\"noopener\">Electron 和 NW.js 的对比</a>，相信作者在新的项目中有了新的思考，所以选择 Electron 是个对的选择，并且我们只需要开发 Mac 端（组内有 Windows 开发人员），没有对 XP 系统兼容的要求。</p>\n<p>也有考虑过像 <a href=\"https://github.com/MacGapProject\" target=\"_blank\" rel=\"noopener\">MacGap</a> 这样的解决方案，不过 MacGap 是基于 webkit 内核的，并不支持 IndexedDB，而我们的项目依赖的第三方服务是依赖 IndexedDB 做为本地存储的。并且 Electron 更强大，比如新开 webview 加载第三方页面，并且可以预加载(preload) JavaScript来作为 jssdk 供 web 应用使用。</p>\n<p>所以 Electron，就是你了！</p>\n<h2 id=\"主进程和渲染进程\">主进程和渲染进程</h2>\n<p>个人感觉，理解 Electron 最重要应该就是理解主进程（Main Process）和渲染进程（Render Process）了。理解了这两者，其他内容花费些时间查查API文档即可。</p>\n<p>Electron 中，入口是一个 js 文件（和 NW.js 不同，入口是 html 文件），运行这个入口文件（通常会是 package.json 里的 main 脚本）的进程称作主进程，在主进程使用 <code>BrowserWindow</code> 模块可以创建并管理 web 页面，也就是应用的 GUI。</p>\n<pre><code class=\"language-js\">const {BrowserWindow} = require('electron')\n// 主进程创建web页面\nlet someWindow = new BrowserWindow(winOpts)\n// 加载本地的文件\nsomeWindow.loadURL('file://' + __dirname + '/index.html')\n</code></pre>\n<p>在主进程创建的一个个web页面也都运行着自己的进程，即渲染进程，渲染进程各自独立，各自管理自己的页面，可以想象是浏览器一个个的 tab。</p>\n<h2 id=\"进程间通信\">进程间通信</h2>\n<p>我们知道，Web 页面因为安全限制，不能直接访问原生的GUI资源（比如<a href=\"http://electron.atom.io/docs/api/dialog/\" target=\"_blank\" rel=\"noopener\">dialog</a>、<a href=\"http://electron.atom.io/docs/api/power-monitor/\" target=\"_blank\" rel=\"noopener\">电源监控</a>），Electron 中也是一样，渲染进程如果想要进行原生的GUI操作，就必须和主进程通讯，请求相应的GUI操作。</p>\n<p>Electron 提供了几种渲染进程和主进程通信的方式：</p>\n<p>一种是使用<a href=\"https://github.com/electron/electron/blob/v1.1.3/docs/api/ipc-main.md\" target=\"_blank\" rel=\"noopener\">ipcMain</a>和<a href=\"https://github.com/electron/electron/blob/v1.1.3/docs/api/ipc-renderer.md\" target=\"_blank\" rel=\"noopener\">ipcRenderer</a>模块，在渲染进程中使用ipcRender模块向主进程发送消息，主进程中ipcMain接收消息，进行操作，如果还需要反馈，则通知渲染进程，渲染进程根据接收的内容执行相应的操作：</p>\n<pre><code class=\"language-js\">\n// 渲染进程中\nconst {ipcRenderer} = require('electron')\nipcRender.send('somemsg', data);\nipcRender.on('replaymsg', (evt, otherData) =&gt; {\n    console.log(otherData)\n})\n\n// 主进程中\nconst {ipcMain} = require('electron')\nipcMain.on('somemsg', (evt, data) =&gt; {\n    console.log(data)\n    evt.sender.send('replymsg', otherData);\n});\n\n// 同时Electron 也提供了同步的方式\n</code></pre>\n<p><strong>不过切忌用 ipc 传递大量的数据，会有很大的性能问题，严重会让你整个应用卡住。</strong></p>\n<p>第二种是直接在渲染进程使用<a href=\"http://electron.atom.io/docs/api/remote/\" target=\"_blank\" rel=\"noopener\">remote</a>模块，remote 模块可以直接获取主进程中的模块。这种方式其实是第一种方式的简化。</p>\n<pre><code class=\"language-js\">// 在渲染进程打开提示对话框\nconst {dialog} = require('electron').remote\ndialog.showMessageBox({ opts });\n</code></pre>\n<p>第三种是主进程向渲染进程发送消息</p>\n<pre><code class=\"language-js\">this.webviewWindow.webContents.send('ping');\n</code></pre>\n<p>第四种是渲染进程之间的通信</p>\n<p>如果数据不需要实时性，只是渲染进程之间数据的共享，那么使用官方的建议即可：<a href=\"http://electron.atom.io/docs/faq/#how-to-share-data-between-web-pages\" target=\"_blank\" rel=\"noopener\">How to share data between web pages?</a>。如果要求实时性，需要在创建窗口时获取窗口的 id，在其他渲染进程中通过 id 获取窗口实例进行消息发送。</p>\n<pre><code class=\"language-js\">// 主进程\n// 两个窗口互相获取对方的窗口 id, 并发送给渲染进程\nwin1.webContents.send('distributeIds',{\n    win2Id : win2.id\n});\nwin2.webContents.send('distributeIds',{\n    win1Id : win1.id\n});\n\n// 渲染进程\n// 通过 id 得到窗口\nremote.BrowserWindow.fromId(win2Id).webContents.send('someMsg', 'someThing');\n</code></pre>\n<h2 id=\"nodejs集成\">Nodejs集成</h2>\n<p>Electron 内集成了 Nodejs，大大的方便了开发。Nodejs 在主进程和渲染进程中都可以使用，上面说到，渲染进程因为安全限制，不能直接操作原生 GUI。虽然如此，因为集成了 Nodejs，渲染进程也有了操作系统底层 API 的能力，Nodejs 中常用的 Path、fs、Crypto 等模块在 Electron 可以直接使用，方便我们处理链接、路径、文件MD5等，同时npm还有成千上万的模块供我们选择。</p>\n<p>尤其对于 Electron 不方便实现的功能，Nodejs 可能有奇效。我们应用中用户需要下载文件消息的文件，需要支持同事下载多个，并且需要给出进度，Electron 并没有提供一个好用的下载接口，所以我们使用 Nodejs 的 <code>http</code>、<code>fs</code> 模块结合 Electron 的 dialog 模块实现了文件下载，并且实现了下载进度以及下载超时错误提示。</p>\n<h2 id=\"html5增强\">HTML5增强</h2>\n<p>不考虑兼容性应该是前端码农的梦想之一吧。Electron 使用 Chromium 来展示 web 页面，也就是我们开发只需要兼容 Chromium 浏览器即可，也就是说好多属性可以肆无忌惮的用：播放语音直接使用 HTML5 audio、大量数据存储使用数据库 IndexedDB、难搞的布局直接使用 Flexbox、方便的检测在线离线等等。</p>\n<p>同时 Electron 对一些 HTML5 的特性进行了增强：</p>\n<ul>\n<li>桌面通知，你可以直接使用 html5 的 notification，Electron会将其转化成为系统原生的桌面通知；</li>\n<li>File 对象，在Web应用中我们能得到的一般是类似 <code>C:/fakePath/xxx.docx</code> 的假路径，Electron在 File 对象上增加了一个path属性，可以用来获取选择的文件在文件系统中的真实路径。</li>\n<li><code>a</code> 标签的 download 属性，在 Web 应用中 <code>a</code> 标签增加 download 属性会强制浏览器下载，Electron 中会直接调起系统下载框下载，如果没有特殊需求推荐这种方式。</li>\n</ul>\n<p>渲染进程调试和在浏览器中的调试完全一致。前面提到每个渲染进程完全独立，当你创建了多个web页面，每个页面都可以打开对应了调试工具，你可以和浏览器调试一样查看DOM、查看log、监听网络请求等等。<br>\n同时 Electron 集成了 Nodejs，所以你在控制台或者断点时也能够调试 Nodejs 的 API，甚至因为渲染进程可以使用 remote 模块直接使用主进程的模块，你可以直接获取到这些数据以方便调试。</p>\n<h2 id=\"electron-中的-webview\">Electron 中的 Webview</h2>\n<p>这次的新产品有一个需求，需要在客户端内加载 Webview 应用，并且要提供 jssdk 供 Web 应用使用，以获取更多的本地能力。其实 Electron 天然的优势可以加载外部应用的。但是要考虑的问题还是比较多的，比如要展示页面加载的进度、监听页面何时加载完成、页面 DOM 何时加载完成、服务端一些302重定向如何（比如一些跳转认证）处理、如何给 Web 应用提供 jssdk 等等。</p>\n<p>Electron 提供了一系列的事件来监听页面的加载，细化到了页面开始加载、页面加载完成、页面加载失败、DOM Ready、框架加载 (<code>did-frame-finish-load</code>)、重定向（<code>did-get-redirect-request</code>）等等，通过监听这些事件可以对页面状态进行处理。</p>\n<p>另外，如何给 Web 应用提供 jssdk 呢？我们需要依赖 <a href=\"http://electron.atom.io/docs/api/browser-window/\" target=\"_blank\" rel=\"noopener\"><code>BrowserWindow</code></a> 的一个配置项 - <code>preload</code>，preload 允许你指定一段脚本在页面加载之前载入，这段脚本你可以使用 Electron 和 Nodejs 的 API，即使你在配置中不允许使用 Nodejs。</p>\n<pre><code class=\"language-js\">\n// preload 示例\nvar opts = {\n    autoHideMenuBar: true,\n    fullscreenable: false,\n    webPreferences: {\n        javascript: true,\n        plugins: true,\n        nodeIntegration: false, // 不集成 Nodejs\n        webSecurity: false,\n        preload: path.join(__dirname, 'preload/window_sdk.js') // 但预加载的 js 文件内仍可以使用 Nodejs 的 API\n    }\n}\n\nthis.webviewWindow = new BrowserWindow(opts);\n\n</code></pre>\n<p>预加载 js 文件与其他 js 并无二致，你只要根据你的业务，在 preload 的 js 中使用 remote 或者 ipc 通信给你的 Web 应用提供够用接口就好了。</p>\n<h2 id=\"写在后面\">写在后面</h2>\n<p>Electron 并不是很复杂，在写完不多的主进程代码后，其他的业务代码几乎和 Web 应用没什么区别，甚至可以将一个线上应用迅速的包装成为一个客户端应用，比如<a href=\"https://github.com/geeeeeeeeek/electronic-wechat\" target=\"_blank\" rel=\"noopener\">electronic-wechat</a>、<a href=\"https://worktile.com/\" target=\"_blank\" rel=\"noopener\">worktile桌面端</a>。<br>\n不过坑不可避免（比如无法将 gif 写入剪切板等等），有时候也会感到很难像 Native 那样灵活，虽然如此，我还是很欣慰能有这样的工具，让我们前端可以做更多的事情。</p>\n<p>最后一点想说的是开发思维的转变，比如在客户端开发中本地数据库的存储十分常见，在前端 Web 开发中可能很少会接触到，比如我们这次就用 IndexedDB 本地存储了大量的数据。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这是去年年底写的关于 Electron 的总结，搬运到新的博客里面，做了微小的修改。</p>\n<hr>\n<p>之前发过一个装逼的朋友圈：感谢 Electron，我现在有两个身份了：前端开发和 Mac 端开发。</p>\n<p>今年开始了一个全新的产品，但项目组并没有 Mac 的开发人员，然后我们前端就顺利的扛下了这面大旗，并且选择了火爆的 <a href=\"http://electron.atom.io/\" target=\"_blank\" rel=\"noopener\">Electron</a>（4w+ star）。</p>\n<p>年底了，看大家在写各种各样的年终总结，想着我和 Electron 也打情骂俏了好几个月，也该写点东西。不过 Electron 已经够火了，能 google 到很多类似如何使用 Electron 开发桌面端应用的文章，比如<a href=\"http://get.ftqq.com/7870.get\" target=\"_blank\" rel=\"noopener\">用Electron开发桌面应用</a>，也能找到<a href=\"https://github.com/electron/electron/tree/master/docs-translations/zh-CN\" target=\"_blank\" rel=\"noopener\">官方中文文档</a>，虽然滞后了一点。所以我也就不再赘述怎样从头写一个 Electron 应用了，在阅读下面的内容之前，最好能先跟随官方的 <a href=\"http://electron.atom.io/docs/tutorial/quick-start/\" target=\"_blank\" rel=\"noopener\">Quick Start</a> 走一遍。</p>\n<h2 id=\"为什么选择-electron\">为什么选择 Electron</h2>\n<blockquote>\n<p>Electron提供了一个Nodejs的运行时，专注于构建桌面应用，同时使用web页面来作为应用的GUI，你可以将其看作是一个由JavaScript控制的迷你版的Chromium浏览器。</p>\n</blockquote>\n<p>够火自不必说，Electron 的作者和 NW.js（原 node-webkit）是同一人，大家可以去知乎围观<a href=\"https://www.zhihu.com/question/36292298/answer/102418523\" target=\"_blank\" rel=\"noopener\">维护一个大型开源项目是怎样的体验？</a>这个问题下作者的回答（评论区提出该知乎问题下还有一个回答对此存有异议：<a href=\"https://www.zhihu.com/question/36292298/answer/136521303%EF%BC%8C%E5%A4%A7%E5%AE%B6%E8%87%AA%E8%A1%8C%E5%88%86%E8%BE%A8%EF%BC%89%E3%80%82%E5%AE%98%E6%96%B9%E4%B9%9F%E6%9C%89\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/36292298/answer/136521303，大家自行分辨）。官方也有</a> <a href=\"http://electron.atom.io/docs/development/atom-shell-vs-node-webkit/\" target=\"_blank\" rel=\"noopener\">Electron 和 NW.js 的对比</a>，相信作者在新的项目中有了新的思考，所以选择 Electron 是个对的选择，并且我们只需要开发 Mac 端（组内有 Windows 开发人员），没有对 XP 系统兼容的要求。</p>\n<p>也有考虑过像 <a href=\"https://github.com/MacGapProject\" target=\"_blank\" rel=\"noopener\">MacGap</a> 这样的解决方案，不过 MacGap 是基于 webkit 内核的，并不支持 IndexedDB，而我们的项目依赖的第三方服务是依赖 IndexedDB 做为本地存储的。并且 Electron 更强大，比如新开 webview 加载第三方页面，并且可以预加载(preload) JavaScript来作为 jssdk 供 web 应用使用。</p>\n<p>所以 Electron，就是你了！</p>\n<h2 id=\"主进程和渲染进程\">主进程和渲染进程</h2>\n<p>个人感觉，理解 Electron 最重要应该就是理解主进程（Main Process）和渲染进程（Render Process）了。理解了这两者，其他内容花费些时间查查API文档即可。</p>\n<p>Electron 中，入口是一个 js 文件（和 NW.js 不同，入口是 html 文件），运行这个入口文件（通常会是 package.json 里的 main 脚本）的进程称作主进程，在主进程使用 <code>BrowserWindow</code> 模块可以创建并管理 web 页面，也就是应用的 GUI。</p>\n<pre><code class=\"language-js\">const {BrowserWindow} = require('electron')\n// 主进程创建web页面\nlet someWindow = new BrowserWindow(winOpts)\n// 加载本地的文件\nsomeWindow.loadURL('file://' + __dirname + '/index.html')\n</code></pre>\n<p>在主进程创建的一个个web页面也都运行着自己的进程，即渲染进程，渲染进程各自独立，各自管理自己的页面，可以想象是浏览器一个个的 tab。</p>\n<h2 id=\"进程间通信\">进程间通信</h2>\n<p>我们知道，Web 页面因为安全限制，不能直接访问原生的GUI资源（比如<a href=\"http://electron.atom.io/docs/api/dialog/\" target=\"_blank\" rel=\"noopener\">dialog</a>、<a href=\"http://electron.atom.io/docs/api/power-monitor/\" target=\"_blank\" rel=\"noopener\">电源监控</a>），Electron 中也是一样，渲染进程如果想要进行原生的GUI操作，就必须和主进程通讯，请求相应的GUI操作。</p>\n<p>Electron 提供了几种渲染进程和主进程通信的方式：</p>\n<p>一种是使用<a href=\"https://github.com/electron/electron/blob/v1.1.3/docs/api/ipc-main.md\" target=\"_blank\" rel=\"noopener\">ipcMain</a>和<a href=\"https://github.com/electron/electron/blob/v1.1.3/docs/api/ipc-renderer.md\" target=\"_blank\" rel=\"noopener\">ipcRenderer</a>模块，在渲染进程中使用ipcRender模块向主进程发送消息，主进程中ipcMain接收消息，进行操作，如果还需要反馈，则通知渲染进程，渲染进程根据接收的内容执行相应的操作：</p>\n<pre><code class=\"language-js\">\n// 渲染进程中\nconst {ipcRenderer} = require('electron')\nipcRender.send('somemsg', data);\nipcRender.on('replaymsg', (evt, otherData) =&gt; {\n    console.log(otherData)\n})\n\n// 主进程中\nconst {ipcMain} = require('electron')\nipcMain.on('somemsg', (evt, data) =&gt; {\n    console.log(data)\n    evt.sender.send('replymsg', otherData);\n});\n\n// 同时Electron 也提供了同步的方式\n</code></pre>\n<p><strong>不过切忌用 ipc 传递大量的数据，会有很大的性能问题，严重会让你整个应用卡住。</strong></p>\n<p>第二种是直接在渲染进程使用<a href=\"http://electron.atom.io/docs/api/remote/\" target=\"_blank\" rel=\"noopener\">remote</a>模块，remote 模块可以直接获取主进程中的模块。这种方式其实是第一种方式的简化。</p>\n<pre><code class=\"language-js\">// 在渲染进程打开提示对话框\nconst {dialog} = require('electron').remote\ndialog.showMessageBox({ opts });\n</code></pre>\n<p>第三种是主进程向渲染进程发送消息</p>\n<pre><code class=\"language-js\">this.webviewWindow.webContents.send('ping');\n</code></pre>\n<p>第四种是渲染进程之间的通信</p>\n<p>如果数据不需要实时性，只是渲染进程之间数据的共享，那么使用官方的建议即可：<a href=\"http://electron.atom.io/docs/faq/#how-to-share-data-between-web-pages\" target=\"_blank\" rel=\"noopener\">How to share data between web pages?</a>。如果要求实时性，需要在创建窗口时获取窗口的 id，在其他渲染进程中通过 id 获取窗口实例进行消息发送。</p>\n<pre><code class=\"language-js\">// 主进程\n// 两个窗口互相获取对方的窗口 id, 并发送给渲染进程\nwin1.webContents.send('distributeIds',{\n    win2Id : win2.id\n});\nwin2.webContents.send('distributeIds',{\n    win1Id : win1.id\n});\n\n// 渲染进程\n// 通过 id 得到窗口\nremote.BrowserWindow.fromId(win2Id).webContents.send('someMsg', 'someThing');\n</code></pre>\n<h2 id=\"nodejs集成\">Nodejs集成</h2>\n<p>Electron 内集成了 Nodejs，大大的方便了开发。Nodejs 在主进程和渲染进程中都可以使用，上面说到，渲染进程因为安全限制，不能直接操作原生 GUI。虽然如此，因为集成了 Nodejs，渲染进程也有了操作系统底层 API 的能力，Nodejs 中常用的 Path、fs、Crypto 等模块在 Electron 可以直接使用，方便我们处理链接、路径、文件MD5等，同时npm还有成千上万的模块供我们选择。</p>\n<p>尤其对于 Electron 不方便实现的功能，Nodejs 可能有奇效。我们应用中用户需要下载文件消息的文件，需要支持同事下载多个，并且需要给出进度，Electron 并没有提供一个好用的下载接口，所以我们使用 Nodejs 的 <code>http</code>、<code>fs</code> 模块结合 Electron 的 dialog 模块实现了文件下载，并且实现了下载进度以及下载超时错误提示。</p>\n<h2 id=\"html5增强\">HTML5增强</h2>\n<p>不考虑兼容性应该是前端码农的梦想之一吧。Electron 使用 Chromium 来展示 web 页面，也就是我们开发只需要兼容 Chromium 浏览器即可，也就是说好多属性可以肆无忌惮的用：播放语音直接使用 HTML5 audio、大量数据存储使用数据库 IndexedDB、难搞的布局直接使用 Flexbox、方便的检测在线离线等等。</p>\n<p>同时 Electron 对一些 HTML5 的特性进行了增强：</p>\n<ul>\n<li>桌面通知，你可以直接使用 html5 的 notification，Electron会将其转化成为系统原生的桌面通知；</li>\n<li>File 对象，在Web应用中我们能得到的一般是类似 <code>C:/fakePath/xxx.docx</code> 的假路径，Electron在 File 对象上增加了一个path属性，可以用来获取选择的文件在文件系统中的真实路径。</li>\n<li><code>a</code> 标签的 download 属性，在 Web 应用中 <code>a</code> 标签增加 download 属性会强制浏览器下载，Electron 中会直接调起系统下载框下载，如果没有特殊需求推荐这种方式。</li>\n</ul>\n<p>渲染进程调试和在浏览器中的调试完全一致。前面提到每个渲染进程完全独立，当你创建了多个web页面，每个页面都可以打开对应了调试工具，你可以和浏览器调试一样查看DOM、查看log、监听网络请求等等。<br>\n同时 Electron 集成了 Nodejs，所以你在控制台或者断点时也能够调试 Nodejs 的 API，甚至因为渲染进程可以使用 remote 模块直接使用主进程的模块，你可以直接获取到这些数据以方便调试。</p>\n<h2 id=\"electron-中的-webview\">Electron 中的 Webview</h2>\n<p>这次的新产品有一个需求，需要在客户端内加载 Webview 应用，并且要提供 jssdk 供 Web 应用使用，以获取更多的本地能力。其实 Electron 天然的优势可以加载外部应用的。但是要考虑的问题还是比较多的，比如要展示页面加载的进度、监听页面何时加载完成、页面 DOM 何时加载完成、服务端一些302重定向如何（比如一些跳转认证）处理、如何给 Web 应用提供 jssdk 等等。</p>\n<p>Electron 提供了一系列的事件来监听页面的加载，细化到了页面开始加载、页面加载完成、页面加载失败、DOM Ready、框架加载 (<code>did-frame-finish-load</code>)、重定向（<code>did-get-redirect-request</code>）等等，通过监听这些事件可以对页面状态进行处理。</p>\n<p>另外，如何给 Web 应用提供 jssdk 呢？我们需要依赖 <a href=\"http://electron.atom.io/docs/api/browser-window/\" target=\"_blank\" rel=\"noopener\"><code>BrowserWindow</code></a> 的一个配置项 - <code>preload</code>，preload 允许你指定一段脚本在页面加载之前载入，这段脚本你可以使用 Electron 和 Nodejs 的 API，即使你在配置中不允许使用 Nodejs。</p>\n<pre><code class=\"language-js\">\n// preload 示例\nvar opts = {\n    autoHideMenuBar: true,\n    fullscreenable: false,\n    webPreferences: {\n        javascript: true,\n        plugins: true,\n        nodeIntegration: false, // 不集成 Nodejs\n        webSecurity: false,\n        preload: path.join(__dirname, 'preload/window_sdk.js') // 但预加载的 js 文件内仍可以使用 Nodejs 的 API\n    }\n}\n\nthis.webviewWindow = new BrowserWindow(opts);\n\n</code></pre>\n<p>预加载 js 文件与其他 js 并无二致，你只要根据你的业务，在 preload 的 js 中使用 remote 或者 ipc 通信给你的 Web 应用提供够用接口就好了。</p>\n<h2 id=\"写在后面\">写在后面</h2>\n<p>Electron 并不是很复杂，在写完不多的主进程代码后，其他的业务代码几乎和 Web 应用没什么区别，甚至可以将一个线上应用迅速的包装成为一个客户端应用，比如<a href=\"https://github.com/geeeeeeeeek/electronic-wechat\" target=\"_blank\" rel=\"noopener\">electronic-wechat</a>、<a href=\"https://worktile.com/\" target=\"_blank\" rel=\"noopener\">worktile桌面端</a>。<br>\n不过坑不可避免（比如无法将 gif 写入剪切板等等），有时候也会感到很难像 Native 那样灵活，虽然如此，我还是很欣慰能有这样的工具，让我们前端可以做更多的事情。</p>\n<p>最后一点想说的是开发思维的转变，比如在客户端开发中本地数据库的存储十分常见，在前端 Web 开发中可能很少会接触到，比如我们这次就用 IndexedDB 本地存储了大量的数据。</p>\n"},{"layout":"post","title":"Express 源码简析","banner":"assets/img/express-source-code.jpeg","date":"2017-09-13T15:04:00.000Z","updated":"2019-01-17T13:00:11.000Z","_content":"\n[Express](https://github.com/expressjs/express) 是一个简洁易用的 Nodejs 的 Web 开发框架，我的个人项目：[基于Gulp构建前端Mock Server](https://github.com/zjzhome/Gulp-Mock-Server)中，前端服务器就是使用了 Express 来实现。\n\n使用 Express 创建 Web应用及其简单，可以直接使用 express-generator 创建一个脚手架，也可以最简单的一个 app.js 搞定，下面是一个简单的 Express 创建服务器的示例：\n\n```js\nvar express = require('express')\nvar app = express()\n\napp.set('views', path.join(__dirname, 'views'));\napp.set('view engine', 'jade');\n\napp.use(express.static(__dirname));\napp.use(bodyParser.json()); // for parsing application/json\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// 可以定制多种路由\napp.get('/api', function(req, res) {\n    res.send('Hello world')\n})\n\n// 也可以这样定义嵌套路由\n// express-generator 自动生成的代码就是采用了这样的方法\nvar users = require('./routes/users');\napp.use('/users', users);\n\napp.listen(3000)\n```\n\n./routes/users.js 内容如下：\n```js\nvar express = require('express');\nvar router = express.Router();\n\n/* GET users listing. */\nrouter.get('/', function(req, res, next) {\n  res.send('respond with a resource');\n});\n\nmodule.exports = router;\n```\n\n运行 `node app.js`, 访问 `localhost:3000/api` 页面会输出 `Hello world`，从上面可以看出，创建 express 大概需要这么几步：\n\n* 设置应用，比如设置要使用的模板引擎，设置模板目录\n* app.use 设置页面请求中要使用到的中间件\n* 设置路由监听\n* 开启服务器，监听响应端口\n\n我们对照这四个步骤来看下 Express 的源码。\n\n## 初始化和设置应用\n\n下载 express 4.x 源码，首先找到 express 的入口文件 `index.js`，只有一行：\n\n```js\nmodule.exports = require('./lib/express');\n```\n\n然后进入 `lib` 目录，其实 express 所有的代码都在 `lib` 目录下。找到 express.js ：\n\n```js\nvar proto = require('./application');\n\nexports = module.exports = createApplication;\n\nfunction createApplication() {\n  var app = function(req, res, next) {\n    app.handle(req, res, next);\n  };\n\n  // 继承 EventEmitter，使得 app 也能触发和监听事件\n  mixin(app, EventEmitter.prototype, false);\n  // app 增加方法，该方法来自于 application.js\n  // 其中就有 app.init\n  mixin(app, proto, false);\n\n  // expose the prototype that will get set on requests\n  // 暴露 request 属性\n  app.request = Object.create(req, {\n    app: { configurable: true, enumerable: true, writable: true, value: app }\n  })\n\n  // expose the prototype that will get set on responses\n  // 暴露 response 属性\n  app.response = Object.create(res, {\n    app: { configurable: true, enumerable: true, writable: true, value: app }\n  })\n\n  app.init();\n  return app;\n}\n```\n\n以上代码就是应用初始化的主要代码，当 `app = require('express')()`，也就是执行了 `createApplication` 方法，该方法返回了 `app` 实例。改方法对 `app` 做了相关处理，相关处理标注在了代码中。最后调用 `app.init` 进行应用设置，init 相关代码在 `application.js` 内，太长就不贴了。\n\n同时我们发现 app 其实是一个方法，这个方法拥有 `req`、`res`、`next`三个参数。当我们调用 `app.listen(3000)` 开启服务器监听端口时，其实是执行了一下代码：\n\n```js\n// 代码来自 application.js\napp.listen = function listen() {\n  var server = http.createServer(this);\n  return server.listen.apply(server, arguments);\n};\n\n// 其实也就是以下代码\napp.listen = function listen() {\n  var server = http.createServer(function(req, res, next) {\n    app.handle(req, res, next)\n  });\n  return server.listen.apply(server, arguments);\n};\n```\n\n我们看到 app 是作为 `http.createServer` 这个方法的参数传进去的，app 方法的前两个参数和 `http.createServer` 前两个参数一致，当用户访问某个链接时，就执行 `app.handle`，处理该路由对应的方法，该方法将在最后介绍。\n\n## 中间件处理\n\n使用中间件均是通过 app.use 方法，该方法位于 `./application.js`。\n\n```js\napp.use = function use(fn) {\n  var offset = 0;\n  var path = '/';\n\n  // default path to '/'\n  // disambiguate app.use([fn])\n  if (typeof fn !== 'function') {\n    var arg = fn;\n\n    while (Array.isArray(arg) && arg.length !== 0) {\n      arg = arg[0];\n    }\n\n    // first arg is the path\n    if (typeof arg !== 'function') {\n      offset = 1;\n      path = fn;\n    }\n  }\n\n  var fns = flatten(slice.call(arguments, offset));\n\n  if (fns.length === 0) {\n    throw new TypeError('app.use() requires middleware functions');\n  }\n\n  // 以上代码对方法参数进行处理，如果第一个参数没有指定路由，则默认为'/'\n  // 然后得到路由或者中间件的处理方法，交由下面的代码处理。\n\n  // setup router\n  // 路由初始化\n  this.lazyrouter();\n  var router = this._router;\n\n  fns.forEach(function (fn) {\n    // non-express app\n    // 如果fn为简单方法，直接使用 router.use('/', fn)\n    if (!fn || !fn.handle || !fn.set) {\n      return router.use(path, fn);\n    }\n\n    debug('.use app under %s', path);\n    fn.mountpath = path;\n    fn.parent = this;\n\n    // restore .app property on req and res\n    // 如果 fn 是有 handle 方法，则执行下面的逻辑\n    // 这种就对应使用 app.use 来定义路由的方式，app.use第一个参数是路由，第二个参数就是 router，router和 app 都有 handle、use等方法。\n    router.use(path, function mounted_app(req, res, next) {\n      var orig = req.app;\n      fn.handle(req, res, function (err) {\n        setPrototypeOf(req, orig.request)\n        setPrototypeOf(res, orig.response)\n        next(err);\n      });\n    });\n\n    // mounted an app\n    fn.emit('mount', this);\n  }, this);\n\n  return this;\n};\n```\n\n## 路由监听\n\n从上面我们可以看到，app.use 最终都指向了 router.use 或者 router.handle 方法，那就让我们进入 router 的源码一探究竟。router 的源码都在 `./lib/router` 目录下。\n\nrouter 的入口是 index.js，首先入口处定义了 router，定义的方式类似 app 这里就不再贴源码了。下面看一下，router 中被使用的 use 方法。\n\nrouter.use 处理方法和 app.use 类似，首先对方法参数做处理。把不一样的部分贴到下面：\n\n```js\nvar layer = new Layer(path, {\n  sensitive: this.caseSensitive,\n  strict: false,\n  end: false\n}, fn);\n\nlayer.route = undefined;\n\nthis.stack.push(layer);\n```\n\n首先得到一个 Layer 实例，并且 push 到 this.stack。\n\nLayer 相关的代码在 layer.js 内，Layer 内定义单个路由处理的相关方法，包括路由是否匹配、处理路由逻辑、错误处理等。在接下来要说到的处理请求会用到，处理请求，主要是 router.handle 方法，在上面提到的 app.handle 最终也是调用了 router.handle 方法。\n\n## 处理请求\n\nrouter.handle 方法很长。主要功能是遍历 router.stack 内存储的所有路由及其对应的方法，即 layer, 如果匹配到当前用户访问的路由，就通过执行 layer.handle_request 执行路由对应的方法。\n\n这些路由处理的方法要么是通过 app[method] 定义要么是通过 router[mothod] 定义，这里的 method 是 get、post 这个 HTTP 动词。这些方法定义在 Route 对象下，源代码位于 `./lib/router/route.js` 内。\n\n```js\n// methods 是服务器支持的所有 http 动词\n// 这些方法也被代理到 app 和 router 上，所以 app 和 router 能够直接调用\nmethods.forEach(function(method){\n  Route.prototype[method] = function(){\n    var handles = flatten(slice.call(arguments));\n\n    for (var i = 0; i < handles.length; i++) {\n      var handle = handles[i];\n\n      if (typeof handle !== 'function') {\n        var type = toString.call(handle);\n        var msg = 'Route.' + method + '() requires callback functions but got a ' + type;\n        throw new Error(msg);\n      }\n\n      debug('%s %o', method, this.path)\n\n      // router.get('/', function(req, res, next) {\n      //   res.send('respond with a resource');\n      // });\n      var layer = Layer('/', {}, handle);\n      layer.method = method;\n\n      this.methods[method] = true;\n      this.stack.push(layer);\n    }\n\n    return this;\n  };\n});\n```\n\n当直接调用 app.get 等方法时，其实是执行了以下的语句：\n\n```js\nvar route = this._router.route(path);\nroute[method].apply(route, slice.call(arguments, 1));\n```\n\n在执行对应的 route.get 之前，先执行了 router.route:\n\n```js\nproto.route = function route(path) {\n  var route = new Route(path);\n\n  var layer = new Layer(path, {\n    sensitive: this.caseSensitive,\n    strict: this.strict,\n    end: true\n  }, route.dispatch.bind(route));\n\n  layer.route = route;\n\n  this.stack.push(layer);\n  return route;\n};\n```\n\n我们看到 Layer 的第三个参数是 route.dispatch，这个方法处理方式类似前面提到的 router.handle，最终都是通过layer 找到匹配的路由并且执行相应的方法。\n\n所以 Layer 可以看做是一个中间层，起到了承上启下的作用。每个 layer 实例存储一个路由方法，以及这个路由方法对应的路由。当调用 route.dispatch 或者 router.handle 等方法的时候，都要过一遍这个中间层，筛选出用户当前访问的路由，然后做出处理。\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/express-source-code-analysis.md","raw":"\nlayout: post\ntitle: Express 源码简析\nbanner: assets/img/express-source-code.jpeg\ndate: 2017-9-13 23:04\nupdated: 0\ntags: nodejs\n---\n\n[Express](https://github.com/expressjs/express) 是一个简洁易用的 Nodejs 的 Web 开发框架，我的个人项目：[基于Gulp构建前端Mock Server](https://github.com/zjzhome/Gulp-Mock-Server)中，前端服务器就是使用了 Express 来实现。\n\n使用 Express 创建 Web应用及其简单，可以直接使用 express-generator 创建一个脚手架，也可以最简单的一个 app.js 搞定，下面是一个简单的 Express 创建服务器的示例：\n\n```js\nvar express = require('express')\nvar app = express()\n\napp.set('views', path.join(__dirname, 'views'));\napp.set('view engine', 'jade');\n\napp.use(express.static(__dirname));\napp.use(bodyParser.json()); // for parsing application/json\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// 可以定制多种路由\napp.get('/api', function(req, res) {\n    res.send('Hello world')\n})\n\n// 也可以这样定义嵌套路由\n// express-generator 自动生成的代码就是采用了这样的方法\nvar users = require('./routes/users');\napp.use('/users', users);\n\napp.listen(3000)\n```\n\n./routes/users.js 内容如下：\n```js\nvar express = require('express');\nvar router = express.Router();\n\n/* GET users listing. */\nrouter.get('/', function(req, res, next) {\n  res.send('respond with a resource');\n});\n\nmodule.exports = router;\n```\n\n运行 `node app.js`, 访问 `localhost:3000/api` 页面会输出 `Hello world`，从上面可以看出，创建 express 大概需要这么几步：\n\n* 设置应用，比如设置要使用的模板引擎，设置模板目录\n* app.use 设置页面请求中要使用到的中间件\n* 设置路由监听\n* 开启服务器，监听响应端口\n\n我们对照这四个步骤来看下 Express 的源码。\n\n## 初始化和设置应用\n\n下载 express 4.x 源码，首先找到 express 的入口文件 `index.js`，只有一行：\n\n```js\nmodule.exports = require('./lib/express');\n```\n\n然后进入 `lib` 目录，其实 express 所有的代码都在 `lib` 目录下。找到 express.js ：\n\n```js\nvar proto = require('./application');\n\nexports = module.exports = createApplication;\n\nfunction createApplication() {\n  var app = function(req, res, next) {\n    app.handle(req, res, next);\n  };\n\n  // 继承 EventEmitter，使得 app 也能触发和监听事件\n  mixin(app, EventEmitter.prototype, false);\n  // app 增加方法，该方法来自于 application.js\n  // 其中就有 app.init\n  mixin(app, proto, false);\n\n  // expose the prototype that will get set on requests\n  // 暴露 request 属性\n  app.request = Object.create(req, {\n    app: { configurable: true, enumerable: true, writable: true, value: app }\n  })\n\n  // expose the prototype that will get set on responses\n  // 暴露 response 属性\n  app.response = Object.create(res, {\n    app: { configurable: true, enumerable: true, writable: true, value: app }\n  })\n\n  app.init();\n  return app;\n}\n```\n\n以上代码就是应用初始化的主要代码，当 `app = require('express')()`，也就是执行了 `createApplication` 方法，该方法返回了 `app` 实例。改方法对 `app` 做了相关处理，相关处理标注在了代码中。最后调用 `app.init` 进行应用设置，init 相关代码在 `application.js` 内，太长就不贴了。\n\n同时我们发现 app 其实是一个方法，这个方法拥有 `req`、`res`、`next`三个参数。当我们调用 `app.listen(3000)` 开启服务器监听端口时，其实是执行了一下代码：\n\n```js\n// 代码来自 application.js\napp.listen = function listen() {\n  var server = http.createServer(this);\n  return server.listen.apply(server, arguments);\n};\n\n// 其实也就是以下代码\napp.listen = function listen() {\n  var server = http.createServer(function(req, res, next) {\n    app.handle(req, res, next)\n  });\n  return server.listen.apply(server, arguments);\n};\n```\n\n我们看到 app 是作为 `http.createServer` 这个方法的参数传进去的，app 方法的前两个参数和 `http.createServer` 前两个参数一致，当用户访问某个链接时，就执行 `app.handle`，处理该路由对应的方法，该方法将在最后介绍。\n\n## 中间件处理\n\n使用中间件均是通过 app.use 方法，该方法位于 `./application.js`。\n\n```js\napp.use = function use(fn) {\n  var offset = 0;\n  var path = '/';\n\n  // default path to '/'\n  // disambiguate app.use([fn])\n  if (typeof fn !== 'function') {\n    var arg = fn;\n\n    while (Array.isArray(arg) && arg.length !== 0) {\n      arg = arg[0];\n    }\n\n    // first arg is the path\n    if (typeof arg !== 'function') {\n      offset = 1;\n      path = fn;\n    }\n  }\n\n  var fns = flatten(slice.call(arguments, offset));\n\n  if (fns.length === 0) {\n    throw new TypeError('app.use() requires middleware functions');\n  }\n\n  // 以上代码对方法参数进行处理，如果第一个参数没有指定路由，则默认为'/'\n  // 然后得到路由或者中间件的处理方法，交由下面的代码处理。\n\n  // setup router\n  // 路由初始化\n  this.lazyrouter();\n  var router = this._router;\n\n  fns.forEach(function (fn) {\n    // non-express app\n    // 如果fn为简单方法，直接使用 router.use('/', fn)\n    if (!fn || !fn.handle || !fn.set) {\n      return router.use(path, fn);\n    }\n\n    debug('.use app under %s', path);\n    fn.mountpath = path;\n    fn.parent = this;\n\n    // restore .app property on req and res\n    // 如果 fn 是有 handle 方法，则执行下面的逻辑\n    // 这种就对应使用 app.use 来定义路由的方式，app.use第一个参数是路由，第二个参数就是 router，router和 app 都有 handle、use等方法。\n    router.use(path, function mounted_app(req, res, next) {\n      var orig = req.app;\n      fn.handle(req, res, function (err) {\n        setPrototypeOf(req, orig.request)\n        setPrototypeOf(res, orig.response)\n        next(err);\n      });\n    });\n\n    // mounted an app\n    fn.emit('mount', this);\n  }, this);\n\n  return this;\n};\n```\n\n## 路由监听\n\n从上面我们可以看到，app.use 最终都指向了 router.use 或者 router.handle 方法，那就让我们进入 router 的源码一探究竟。router 的源码都在 `./lib/router` 目录下。\n\nrouter 的入口是 index.js，首先入口处定义了 router，定义的方式类似 app 这里就不再贴源码了。下面看一下，router 中被使用的 use 方法。\n\nrouter.use 处理方法和 app.use 类似，首先对方法参数做处理。把不一样的部分贴到下面：\n\n```js\nvar layer = new Layer(path, {\n  sensitive: this.caseSensitive,\n  strict: false,\n  end: false\n}, fn);\n\nlayer.route = undefined;\n\nthis.stack.push(layer);\n```\n\n首先得到一个 Layer 实例，并且 push 到 this.stack。\n\nLayer 相关的代码在 layer.js 内，Layer 内定义单个路由处理的相关方法，包括路由是否匹配、处理路由逻辑、错误处理等。在接下来要说到的处理请求会用到，处理请求，主要是 router.handle 方法，在上面提到的 app.handle 最终也是调用了 router.handle 方法。\n\n## 处理请求\n\nrouter.handle 方法很长。主要功能是遍历 router.stack 内存储的所有路由及其对应的方法，即 layer, 如果匹配到当前用户访问的路由，就通过执行 layer.handle_request 执行路由对应的方法。\n\n这些路由处理的方法要么是通过 app[method] 定义要么是通过 router[mothod] 定义，这里的 method 是 get、post 这个 HTTP 动词。这些方法定义在 Route 对象下，源代码位于 `./lib/router/route.js` 内。\n\n```js\n// methods 是服务器支持的所有 http 动词\n// 这些方法也被代理到 app 和 router 上，所以 app 和 router 能够直接调用\nmethods.forEach(function(method){\n  Route.prototype[method] = function(){\n    var handles = flatten(slice.call(arguments));\n\n    for (var i = 0; i < handles.length; i++) {\n      var handle = handles[i];\n\n      if (typeof handle !== 'function') {\n        var type = toString.call(handle);\n        var msg = 'Route.' + method + '() requires callback functions but got a ' + type;\n        throw new Error(msg);\n      }\n\n      debug('%s %o', method, this.path)\n\n      // router.get('/', function(req, res, next) {\n      //   res.send('respond with a resource');\n      // });\n      var layer = Layer('/', {}, handle);\n      layer.method = method;\n\n      this.methods[method] = true;\n      this.stack.push(layer);\n    }\n\n    return this;\n  };\n});\n```\n\n当直接调用 app.get 等方法时，其实是执行了以下的语句：\n\n```js\nvar route = this._router.route(path);\nroute[method].apply(route, slice.call(arguments, 1));\n```\n\n在执行对应的 route.get 之前，先执行了 router.route:\n\n```js\nproto.route = function route(path) {\n  var route = new Route(path);\n\n  var layer = new Layer(path, {\n    sensitive: this.caseSensitive,\n    strict: this.strict,\n    end: true\n  }, route.dispatch.bind(route));\n\n  layer.route = route;\n\n  this.stack.push(layer);\n  return route;\n};\n```\n\n我们看到 Layer 的第三个参数是 route.dispatch，这个方法处理方式类似前面提到的 router.handle，最终都是通过layer 找到匹配的路由并且执行相应的方法。\n\n所以 Layer 可以看做是一个中间层，起到了承上启下的作用。每个 layer 实例存储一个路由方法，以及这个路由方法对应的路由。当调用 route.dispatch 或者 router.handle 等方法的时候，都要过一遍这个中间层，筛选出用户当前访问的路由，然后做出处理。\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"express-source-code-analysis","published":1,"comments":1,"photos":[],"link":"","_id":"cjr1en2nz000yha9sffn1uoxd","content":"<p><a href=\"https://github.com/expressjs/express\" target=\"_blank\" rel=\"noopener\">Express</a> 是一个简洁易用的 Nodejs 的 Web 开发框架，我的个人项目：<a href=\"https://github.com/zjzhome/Gulp-Mock-Server\" target=\"_blank\" rel=\"noopener\">基于Gulp构建前端Mock Server</a>中，前端服务器就是使用了 Express 来实现。</p>\n<p>使用 Express 创建 Web应用及其简单，可以直接使用 express-generator 创建一个脚手架，也可以最简单的一个 app.js 搞定，下面是一个简单的 Express 创建服务器的示例：</p>\n<pre><code class=\"language-js\">var express = require('express')\nvar app = express()\n\napp.set('views', path.join(__dirname, 'views'));\napp.set('view engine', 'jade');\n\napp.use(express.static(__dirname));\napp.use(bodyParser.json()); // for parsing application/json\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// 可以定制多种路由\napp.get('/api', function(req, res) {\n    res.send('Hello world')\n})\n\n// 也可以这样定义嵌套路由\n// express-generator 自动生成的代码就是采用了这样的方法\nvar users = require('./routes/users');\napp.use('/users', users);\n\napp.listen(3000)\n</code></pre>\n<p>./routes/users.js 内容如下：</p>\n<pre><code class=\"language-js\">var express = require('express');\nvar router = express.Router();\n\n/* GET users listing. */\nrouter.get('/', function(req, res, next) {\n  res.send('respond with a resource');\n});\n\nmodule.exports = router;\n</code></pre>\n<p>运行 <code>node app.js</code>, 访问 <code>localhost:3000/api</code> 页面会输出 <code>Hello world</code>，从上面可以看出，创建 express 大概需要这么几步：</p>\n<ul>\n<li>设置应用，比如设置要使用的模板引擎，设置模板目录</li>\n<li>app.use 设置页面请求中要使用到的中间件</li>\n<li>设置路由监听</li>\n<li>开启服务器，监听响应端口</li>\n</ul>\n<p>我们对照这四个步骤来看下 Express 的源码。</p>\n<h2 id=\"初始化和设置应用\">初始化和设置应用</h2>\n<p>下载 express 4.x 源码，首先找到 express 的入口文件 <code>index.js</code>，只有一行：</p>\n<pre><code class=\"language-js\">module.exports = require('./lib/express');\n</code></pre>\n<p>然后进入 <code>lib</code> 目录，其实 express 所有的代码都在 <code>lib</code> 目录下。找到 express.js ：</p>\n<pre><code class=\"language-js\">var proto = require('./application');\n\nexports = module.exports = createApplication;\n\nfunction createApplication() {\n  var app = function(req, res, next) {\n    app.handle(req, res, next);\n  };\n\n  // 继承 EventEmitter，使得 app 也能触发和监听事件\n  mixin(app, EventEmitter.prototype, false);\n  // app 增加方法，该方法来自于 application.js\n  // 其中就有 app.init\n  mixin(app, proto, false);\n\n  // expose the prototype that will get set on requests\n  // 暴露 request 属性\n  app.request = Object.create(req, {\n    app: { configurable: true, enumerable: true, writable: true, value: app }\n  })\n\n  // expose the prototype that will get set on responses\n  // 暴露 response 属性\n  app.response = Object.create(res, {\n    app: { configurable: true, enumerable: true, writable: true, value: app }\n  })\n\n  app.init();\n  return app;\n}\n</code></pre>\n<p>以上代码就是应用初始化的主要代码，当 <code>app = require('express')()</code>，也就是执行了 <code>createApplication</code> 方法，该方法返回了 <code>app</code> 实例。改方法对 <code>app</code> 做了相关处理，相关处理标注在了代码中。最后调用 <code>app.init</code> 进行应用设置，init 相关代码在 <code>application.js</code> 内，太长就不贴了。</p>\n<p>同时我们发现 app 其实是一个方法，这个方法拥有 <code>req</code>、<code>res</code>、<code>next</code>三个参数。当我们调用 <code>app.listen(3000)</code> 开启服务器监听端口时，其实是执行了一下代码：</p>\n<pre><code class=\"language-js\">// 代码来自 application.js\napp.listen = function listen() {\n  var server = http.createServer(this);\n  return server.listen.apply(server, arguments);\n};\n\n// 其实也就是以下代码\napp.listen = function listen() {\n  var server = http.createServer(function(req, res, next) {\n    app.handle(req, res, next)\n  });\n  return server.listen.apply(server, arguments);\n};\n</code></pre>\n<p>我们看到 app 是作为 <code>http.createServer</code> 这个方法的参数传进去的，app 方法的前两个参数和 <code>http.createServer</code> 前两个参数一致，当用户访问某个链接时，就执行 <code>app.handle</code>，处理该路由对应的方法，该方法将在最后介绍。</p>\n<h2 id=\"中间件处理\">中间件处理</h2>\n<p>使用中间件均是通过 app.use 方法，该方法位于 <code>./application.js</code>。</p>\n<pre><code class=\"language-js\">app.use = function use(fn) {\n  var offset = 0;\n  var path = '/';\n\n  // default path to '/'\n  // disambiguate app.use([fn])\n  if (typeof fn !== 'function') {\n    var arg = fn;\n\n    while (Array.isArray(arg) &amp;&amp; arg.length !== 0) {\n      arg = arg[0];\n    }\n\n    // first arg is the path\n    if (typeof arg !== 'function') {\n      offset = 1;\n      path = fn;\n    }\n  }\n\n  var fns = flatten(slice.call(arguments, offset));\n\n  if (fns.length === 0) {\n    throw new TypeError('app.use() requires middleware functions');\n  }\n\n  // 以上代码对方法参数进行处理，如果第一个参数没有指定路由，则默认为'/'\n  // 然后得到路由或者中间件的处理方法，交由下面的代码处理。\n\n  // setup router\n  // 路由初始化\n  this.lazyrouter();\n  var router = this._router;\n\n  fns.forEach(function (fn) {\n    // non-express app\n    // 如果fn为简单方法，直接使用 router.use('/', fn)\n    if (!fn || !fn.handle || !fn.set) {\n      return router.use(path, fn);\n    }\n\n    debug('.use app under %s', path);\n    fn.mountpath = path;\n    fn.parent = this;\n\n    // restore .app property on req and res\n    // 如果 fn 是有 handle 方法，则执行下面的逻辑\n    // 这种就对应使用 app.use 来定义路由的方式，app.use第一个参数是路由，第二个参数就是 router，router和 app 都有 handle、use等方法。\n    router.use(path, function mounted_app(req, res, next) {\n      var orig = req.app;\n      fn.handle(req, res, function (err) {\n        setPrototypeOf(req, orig.request)\n        setPrototypeOf(res, orig.response)\n        next(err);\n      });\n    });\n\n    // mounted an app\n    fn.emit('mount', this);\n  }, this);\n\n  return this;\n};\n</code></pre>\n<h2 id=\"路由监听\">路由监听</h2>\n<p>从上面我们可以看到，app.use 最终都指向了 router.use 或者 router.handle 方法，那就让我们进入 router 的源码一探究竟。router 的源码都在 <code>./lib/router</code> 目录下。</p>\n<p>router 的入口是 index.js，首先入口处定义了 router，定义的方式类似 app 这里就不再贴源码了。下面看一下，router 中被使用的 use 方法。</p>\n<p>router.use 处理方法和 app.use 类似，首先对方法参数做处理。把不一样的部分贴到下面：</p>\n<pre><code class=\"language-js\">var layer = new Layer(path, {\n  sensitive: this.caseSensitive,\n  strict: false,\n  end: false\n}, fn);\n\nlayer.route = undefined;\n\nthis.stack.push(layer);\n</code></pre>\n<p>首先得到一个 Layer 实例，并且 push 到 this.stack。</p>\n<p>Layer 相关的代码在 layer.js 内，Layer 内定义单个路由处理的相关方法，包括路由是否匹配、处理路由逻辑、错误处理等。在接下来要说到的处理请求会用到，处理请求，主要是 router.handle 方法，在上面提到的 app.handle 最终也是调用了 router.handle 方法。</p>\n<h2 id=\"处理请求\">处理请求</h2>\n<p>router.handle 方法很长。主要功能是遍历 router.stack 内存储的所有路由及其对应的方法，即 layer, 如果匹配到当前用户访问的路由，就通过执行 layer.handle_request 执行路由对应的方法。</p>\n<p>这些路由处理的方法要么是通过 app[method] 定义要么是通过 router[mothod] 定义，这里的 method 是 get、post 这个 HTTP 动词。这些方法定义在 Route 对象下，源代码位于 <code>./lib/router/route.js</code> 内。</p>\n<pre><code class=\"language-js\">// methods 是服务器支持的所有 http 动词\n// 这些方法也被代理到 app 和 router 上，所以 app 和 router 能够直接调用\nmethods.forEach(function(method){\n  Route.prototype[method] = function(){\n    var handles = flatten(slice.call(arguments));\n\n    for (var i = 0; i &lt; handles.length; i++) {\n      var handle = handles[i];\n\n      if (typeof handle !== 'function') {\n        var type = toString.call(handle);\n        var msg = 'Route.' + method + '() requires callback functions but got a ' + type;\n        throw new Error(msg);\n      }\n\n      debug('%s %o', method, this.path)\n\n      // router.get('/', function(req, res, next) {\n      //   res.send('respond with a resource');\n      // });\n      var layer = Layer('/', {}, handle);\n      layer.method = method;\n\n      this.methods[method] = true;\n      this.stack.push(layer);\n    }\n\n    return this;\n  };\n});\n</code></pre>\n<p>当直接调用 app.get 等方法时，其实是执行了以下的语句：</p>\n<pre><code class=\"language-js\">var route = this._router.route(path);\nroute[method].apply(route, slice.call(arguments, 1));\n</code></pre>\n<p>在执行对应的 route.get 之前，先执行了 router.route:</p>\n<pre><code class=\"language-js\">proto.route = function route(path) {\n  var route = new Route(path);\n\n  var layer = new Layer(path, {\n    sensitive: this.caseSensitive,\n    strict: this.strict,\n    end: true\n  }, route.dispatch.bind(route));\n\n  layer.route = route;\n\n  this.stack.push(layer);\n  return route;\n};\n</code></pre>\n<p>我们看到 Layer 的第三个参数是 route.dispatch，这个方法处理方式类似前面提到的 router.handle，最终都是通过layer 找到匹配的路由并且执行相应的方法。</p>\n<p>所以 Layer 可以看做是一个中间层，起到了承上启下的作用。每个 layer 实例存储一个路由方法，以及这个路由方法对应的路由。当调用 route.dispatch 或者 router.handle 等方法的时候，都要过一遍这个中间层，筛选出用户当前访问的路由，然后做出处理。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://github.com/expressjs/express\" target=\"_blank\" rel=\"noopener\">Express</a> 是一个简洁易用的 Nodejs 的 Web 开发框架，我的个人项目：<a href=\"https://github.com/zjzhome/Gulp-Mock-Server\" target=\"_blank\" rel=\"noopener\">基于Gulp构建前端Mock Server</a>中，前端服务器就是使用了 Express 来实现。</p>\n<p>使用 Express 创建 Web应用及其简单，可以直接使用 express-generator 创建一个脚手架，也可以最简单的一个 app.js 搞定，下面是一个简单的 Express 创建服务器的示例：</p>\n<pre><code class=\"language-js\">var express = require('express')\nvar app = express()\n\napp.set('views', path.join(__dirname, 'views'));\napp.set('view engine', 'jade');\n\napp.use(express.static(__dirname));\napp.use(bodyParser.json()); // for parsing application/json\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// 可以定制多种路由\napp.get('/api', function(req, res) {\n    res.send('Hello world')\n})\n\n// 也可以这样定义嵌套路由\n// express-generator 自动生成的代码就是采用了这样的方法\nvar users = require('./routes/users');\napp.use('/users', users);\n\napp.listen(3000)\n</code></pre>\n<p>./routes/users.js 内容如下：</p>\n<pre><code class=\"language-js\">var express = require('express');\nvar router = express.Router();\n\n/* GET users listing. */\nrouter.get('/', function(req, res, next) {\n  res.send('respond with a resource');\n});\n\nmodule.exports = router;\n</code></pre>\n<p>运行 <code>node app.js</code>, 访问 <code>localhost:3000/api</code> 页面会输出 <code>Hello world</code>，从上面可以看出，创建 express 大概需要这么几步：</p>\n<ul>\n<li>设置应用，比如设置要使用的模板引擎，设置模板目录</li>\n<li>app.use 设置页面请求中要使用到的中间件</li>\n<li>设置路由监听</li>\n<li>开启服务器，监听响应端口</li>\n</ul>\n<p>我们对照这四个步骤来看下 Express 的源码。</p>\n<h2 id=\"初始化和设置应用\">初始化和设置应用</h2>\n<p>下载 express 4.x 源码，首先找到 express 的入口文件 <code>index.js</code>，只有一行：</p>\n<pre><code class=\"language-js\">module.exports = require('./lib/express');\n</code></pre>\n<p>然后进入 <code>lib</code> 目录，其实 express 所有的代码都在 <code>lib</code> 目录下。找到 express.js ：</p>\n<pre><code class=\"language-js\">var proto = require('./application');\n\nexports = module.exports = createApplication;\n\nfunction createApplication() {\n  var app = function(req, res, next) {\n    app.handle(req, res, next);\n  };\n\n  // 继承 EventEmitter，使得 app 也能触发和监听事件\n  mixin(app, EventEmitter.prototype, false);\n  // app 增加方法，该方法来自于 application.js\n  // 其中就有 app.init\n  mixin(app, proto, false);\n\n  // expose the prototype that will get set on requests\n  // 暴露 request 属性\n  app.request = Object.create(req, {\n    app: { configurable: true, enumerable: true, writable: true, value: app }\n  })\n\n  // expose the prototype that will get set on responses\n  // 暴露 response 属性\n  app.response = Object.create(res, {\n    app: { configurable: true, enumerable: true, writable: true, value: app }\n  })\n\n  app.init();\n  return app;\n}\n</code></pre>\n<p>以上代码就是应用初始化的主要代码，当 <code>app = require('express')()</code>，也就是执行了 <code>createApplication</code> 方法，该方法返回了 <code>app</code> 实例。改方法对 <code>app</code> 做了相关处理，相关处理标注在了代码中。最后调用 <code>app.init</code> 进行应用设置，init 相关代码在 <code>application.js</code> 内，太长就不贴了。</p>\n<p>同时我们发现 app 其实是一个方法，这个方法拥有 <code>req</code>、<code>res</code>、<code>next</code>三个参数。当我们调用 <code>app.listen(3000)</code> 开启服务器监听端口时，其实是执行了一下代码：</p>\n<pre><code class=\"language-js\">// 代码来自 application.js\napp.listen = function listen() {\n  var server = http.createServer(this);\n  return server.listen.apply(server, arguments);\n};\n\n// 其实也就是以下代码\napp.listen = function listen() {\n  var server = http.createServer(function(req, res, next) {\n    app.handle(req, res, next)\n  });\n  return server.listen.apply(server, arguments);\n};\n</code></pre>\n<p>我们看到 app 是作为 <code>http.createServer</code> 这个方法的参数传进去的，app 方法的前两个参数和 <code>http.createServer</code> 前两个参数一致，当用户访问某个链接时，就执行 <code>app.handle</code>，处理该路由对应的方法，该方法将在最后介绍。</p>\n<h2 id=\"中间件处理\">中间件处理</h2>\n<p>使用中间件均是通过 app.use 方法，该方法位于 <code>./application.js</code>。</p>\n<pre><code class=\"language-js\">app.use = function use(fn) {\n  var offset = 0;\n  var path = '/';\n\n  // default path to '/'\n  // disambiguate app.use([fn])\n  if (typeof fn !== 'function') {\n    var arg = fn;\n\n    while (Array.isArray(arg) &amp;&amp; arg.length !== 0) {\n      arg = arg[0];\n    }\n\n    // first arg is the path\n    if (typeof arg !== 'function') {\n      offset = 1;\n      path = fn;\n    }\n  }\n\n  var fns = flatten(slice.call(arguments, offset));\n\n  if (fns.length === 0) {\n    throw new TypeError('app.use() requires middleware functions');\n  }\n\n  // 以上代码对方法参数进行处理，如果第一个参数没有指定路由，则默认为'/'\n  // 然后得到路由或者中间件的处理方法，交由下面的代码处理。\n\n  // setup router\n  // 路由初始化\n  this.lazyrouter();\n  var router = this._router;\n\n  fns.forEach(function (fn) {\n    // non-express app\n    // 如果fn为简单方法，直接使用 router.use('/', fn)\n    if (!fn || !fn.handle || !fn.set) {\n      return router.use(path, fn);\n    }\n\n    debug('.use app under %s', path);\n    fn.mountpath = path;\n    fn.parent = this;\n\n    // restore .app property on req and res\n    // 如果 fn 是有 handle 方法，则执行下面的逻辑\n    // 这种就对应使用 app.use 来定义路由的方式，app.use第一个参数是路由，第二个参数就是 router，router和 app 都有 handle、use等方法。\n    router.use(path, function mounted_app(req, res, next) {\n      var orig = req.app;\n      fn.handle(req, res, function (err) {\n        setPrototypeOf(req, orig.request)\n        setPrototypeOf(res, orig.response)\n        next(err);\n      });\n    });\n\n    // mounted an app\n    fn.emit('mount', this);\n  }, this);\n\n  return this;\n};\n</code></pre>\n<h2 id=\"路由监听\">路由监听</h2>\n<p>从上面我们可以看到，app.use 最终都指向了 router.use 或者 router.handle 方法，那就让我们进入 router 的源码一探究竟。router 的源码都在 <code>./lib/router</code> 目录下。</p>\n<p>router 的入口是 index.js，首先入口处定义了 router，定义的方式类似 app 这里就不再贴源码了。下面看一下，router 中被使用的 use 方法。</p>\n<p>router.use 处理方法和 app.use 类似，首先对方法参数做处理。把不一样的部分贴到下面：</p>\n<pre><code class=\"language-js\">var layer = new Layer(path, {\n  sensitive: this.caseSensitive,\n  strict: false,\n  end: false\n}, fn);\n\nlayer.route = undefined;\n\nthis.stack.push(layer);\n</code></pre>\n<p>首先得到一个 Layer 实例，并且 push 到 this.stack。</p>\n<p>Layer 相关的代码在 layer.js 内，Layer 内定义单个路由处理的相关方法，包括路由是否匹配、处理路由逻辑、错误处理等。在接下来要说到的处理请求会用到，处理请求，主要是 router.handle 方法，在上面提到的 app.handle 最终也是调用了 router.handle 方法。</p>\n<h2 id=\"处理请求\">处理请求</h2>\n<p>router.handle 方法很长。主要功能是遍历 router.stack 内存储的所有路由及其对应的方法，即 layer, 如果匹配到当前用户访问的路由，就通过执行 layer.handle_request 执行路由对应的方法。</p>\n<p>这些路由处理的方法要么是通过 app[method] 定义要么是通过 router[mothod] 定义，这里的 method 是 get、post 这个 HTTP 动词。这些方法定义在 Route 对象下，源代码位于 <code>./lib/router/route.js</code> 内。</p>\n<pre><code class=\"language-js\">// methods 是服务器支持的所有 http 动词\n// 这些方法也被代理到 app 和 router 上，所以 app 和 router 能够直接调用\nmethods.forEach(function(method){\n  Route.prototype[method] = function(){\n    var handles = flatten(slice.call(arguments));\n\n    for (var i = 0; i &lt; handles.length; i++) {\n      var handle = handles[i];\n\n      if (typeof handle !== 'function') {\n        var type = toString.call(handle);\n        var msg = 'Route.' + method + '() requires callback functions but got a ' + type;\n        throw new Error(msg);\n      }\n\n      debug('%s %o', method, this.path)\n\n      // router.get('/', function(req, res, next) {\n      //   res.send('respond with a resource');\n      // });\n      var layer = Layer('/', {}, handle);\n      layer.method = method;\n\n      this.methods[method] = true;\n      this.stack.push(layer);\n    }\n\n    return this;\n  };\n});\n</code></pre>\n<p>当直接调用 app.get 等方法时，其实是执行了以下的语句：</p>\n<pre><code class=\"language-js\">var route = this._router.route(path);\nroute[method].apply(route, slice.call(arguments, 1));\n</code></pre>\n<p>在执行对应的 route.get 之前，先执行了 router.route:</p>\n<pre><code class=\"language-js\">proto.route = function route(path) {\n  var route = new Route(path);\n\n  var layer = new Layer(path, {\n    sensitive: this.caseSensitive,\n    strict: this.strict,\n    end: true\n  }, route.dispatch.bind(route));\n\n  layer.route = route;\n\n  this.stack.push(layer);\n  return route;\n};\n</code></pre>\n<p>我们看到 Layer 的第三个参数是 route.dispatch，这个方法处理方式类似前面提到的 router.handle，最终都是通过layer 找到匹配的路由并且执行相应的方法。</p>\n<p>所以 Layer 可以看做是一个中间层，起到了承上启下的作用。每个 layer 实例存储一个路由方法，以及这个路由方法对应的路由。当调用 route.dispatch 或者 router.handle 等方法的时候，都要过一遍这个中间层，筛选出用户当前访问的路由，然后做出处理。</p>\n"},{"layout":"post","title":"写在生日这一天","banner":"assets/img/birthday.jpg","_content":"\n2017年3月11日，阴。农历二月十四，今天我生日。\n\n虽然公司部门生日会，以及现在好多人都是按照阳历来过生日，但我一直喜欢老家的传统，农历过生日。其实并没有对自己今年的生日抱多大的希望，自从一个人开始生活后，就对各种节日包括自己的生日并没有什么感觉了。不过我也清楚自己的性格，我并不是一个喜欢热闹的人，更多的时候我宁愿一个人在家睡大觉，虽然很多人聚在一起的时候我会是那个活跃气氛的人。\n\n昨晚下班的时候，意外的收到了小染寄来的生日礼物，怪不得前几天聊天的时候突然问起来了鞋码:joy:，里面还有一句酥麻的话：\n\n> 愿你出走半生归来，仍是少女\n\n原话明明是少年好嘛 :rolling_eyes:\n\n早晨一起床，收到了老爸祝福的短信。晚上和老爸老妈视频，唠家常。每次视频，都有点想回家。:persevere:\n\n还是老姐最实惠，转了一笔巨款。:see_no_evil:\n\n本科班级群还是一如既往的收到了各种祝福。:stuck_out_tongue_closed_eyes:\n\n现在是晚上10点钟，想了想今天都做什么了，除了呼呼的睡了一下午，好像还真记不起自己做了什么，:cry: 好像是刷了刷微博知乎，好像是看了几篇文章，好像是在各个群里露了个脸。。。\n\n过了今天，就是26周岁，有时候看看年龄还是很着急的，奔3了，至今还是无车无房无志向的三无青年，坐在租来的小房间里，啪啦啪啦的写下了这几行文字。\n\n半夜看完了《名侦探柯南 - 纯黑的噩梦》，终于有一集黑衣人的剧情了，有生之年不知道能不能更新完毕，或者能不能看到柯南长大或者柯南和小兰在一起。\n\n晚安 ~ :sleepy:\n\n\n\n\n\n\n","source":"_posts/my-birthday.md","raw":"\nlayout: post\ntitle: 写在生日这一天\nbanner: assets/img/birthday.jpg\ntags: life\n---\n\n2017年3月11日，阴。农历二月十四，今天我生日。\n\n虽然公司部门生日会，以及现在好多人都是按照阳历来过生日，但我一直喜欢老家的传统，农历过生日。其实并没有对自己今年的生日抱多大的希望，自从一个人开始生活后，就对各种节日包括自己的生日并没有什么感觉了。不过我也清楚自己的性格，我并不是一个喜欢热闹的人，更多的时候我宁愿一个人在家睡大觉，虽然很多人聚在一起的时候我会是那个活跃气氛的人。\n\n昨晚下班的时候，意外的收到了小染寄来的生日礼物，怪不得前几天聊天的时候突然问起来了鞋码:joy:，里面还有一句酥麻的话：\n\n> 愿你出走半生归来，仍是少女\n\n原话明明是少年好嘛 :rolling_eyes:\n\n早晨一起床，收到了老爸祝福的短信。晚上和老爸老妈视频，唠家常。每次视频，都有点想回家。:persevere:\n\n还是老姐最实惠，转了一笔巨款。:see_no_evil:\n\n本科班级群还是一如既往的收到了各种祝福。:stuck_out_tongue_closed_eyes:\n\n现在是晚上10点钟，想了想今天都做什么了，除了呼呼的睡了一下午，好像还真记不起自己做了什么，:cry: 好像是刷了刷微博知乎，好像是看了几篇文章，好像是在各个群里露了个脸。。。\n\n过了今天，就是26周岁，有时候看看年龄还是很着急的，奔3了，至今还是无车无房无志向的三无青年，坐在租来的小房间里，啪啦啪啦的写下了这几行文字。\n\n半夜看完了《名侦探柯南 - 纯黑的噩梦》，终于有一集黑衣人的剧情了，有生之年不知道能不能更新完毕，或者能不能看到柯南长大或者柯南和小兰在一起。\n\n晚安 ~ :sleepy:\n\n\n\n\n\n\n","slug":"my-birthday","published":1,"date":"2019-01-17T13:00:11.000Z","updated":"2019-01-17T13:00:11.000Z","comments":1,"photos":[],"link":"","_id":"cjr1en2o1000zha9s0xhbq4zo","content":"<p>2017年3月11日，阴。农历二月十四，今天我生日。</p>\n<p>虽然公司部门生日会，以及现在好多人都是按照阳历来过生日，但我一直喜欢老家的传统，农历过生日。其实并没有对自己今年的生日抱多大的希望，自从一个人开始生活后，就对各种节日包括自己的生日并没有什么感觉了。不过我也清楚自己的性格，我并不是一个喜欢热闹的人，更多的时候我宁愿一个人在家睡大觉，虽然很多人聚在一起的时候我会是那个活跃气氛的人。</p>\n<p>昨晚下班的时候，意外的收到了小染寄来的生日礼物，怪不得前几天聊天的时候突然问起来了鞋码😂，里面还有一句酥麻的话：</p>\n<blockquote>\n<p>愿你出走半生归来，仍是少女</p>\n</blockquote>\n<p>原话明明是少年好嘛 :rolling_eyes:</p>\n<p>早晨一起床，收到了老爸祝福的短信。晚上和老爸老妈视频，唠家常。每次视频，都有点想回家。😣</p>\n<p>还是老姐最实惠，转了一笔巨款。🙈</p>\n<p>本科班级群还是一如既往的收到了各种祝福。😝</p>\n<p>现在是晚上10点钟，想了想今天都做什么了，除了呼呼的睡了一下午，好像还真记不起自己做了什么，😢 好像是刷了刷微博知乎，好像是看了几篇文章，好像是在各个群里露了个脸。。。</p>\n<p>过了今天，就是26周岁，有时候看看年龄还是很着急的，奔3了，至今还是无车无房无志向的三无青年，坐在租来的小房间里，啪啦啪啦的写下了这几行文字。</p>\n<p>半夜看完了《名侦探柯南 - 纯黑的噩梦》，终于有一集黑衣人的剧情了，有生之年不知道能不能更新完毕，或者能不能看到柯南长大或者柯南和小兰在一起。</p>\n<p>晚安 ~ 😪</p>\n","site":{"data":{}},"excerpt":"","more":"<p>2017年3月11日，阴。农历二月十四，今天我生日。</p>\n<p>虽然公司部门生日会，以及现在好多人都是按照阳历来过生日，但我一直喜欢老家的传统，农历过生日。其实并没有对自己今年的生日抱多大的希望，自从一个人开始生活后，就对各种节日包括自己的生日并没有什么感觉了。不过我也清楚自己的性格，我并不是一个喜欢热闹的人，更多的时候我宁愿一个人在家睡大觉，虽然很多人聚在一起的时候我会是那个活跃气氛的人。</p>\n<p>昨晚下班的时候，意外的收到了小染寄来的生日礼物，怪不得前几天聊天的时候突然问起来了鞋码😂，里面还有一句酥麻的话：</p>\n<blockquote>\n<p>愿你出走半生归来，仍是少女</p>\n</blockquote>\n<p>原话明明是少年好嘛 :rolling_eyes:</p>\n<p>早晨一起床，收到了老爸祝福的短信。晚上和老爸老妈视频，唠家常。每次视频，都有点想回家。😣</p>\n<p>还是老姐最实惠，转了一笔巨款。🙈</p>\n<p>本科班级群还是一如既往的收到了各种祝福。😝</p>\n<p>现在是晚上10点钟，想了想今天都做什么了，除了呼呼的睡了一下午，好像还真记不起自己做了什么，😢 好像是刷了刷微博知乎，好像是看了几篇文章，好像是在各个群里露了个脸。。。</p>\n<p>过了今天，就是26周岁，有时候看看年龄还是很着急的，奔3了，至今还是无车无房无志向的三无青年，坐在租来的小房间里，啪啦啪啦的写下了这几行文字。</p>\n<p>半夜看完了《名侦探柯南 - 纯黑的噩梦》，终于有一集黑衣人的剧情了，有生之年不知道能不能更新完毕，或者能不能看到柯南长大或者柯南和小兰在一起。</p>\n<p>晚安 ~ 😪</p>\n"},{"layout":"post","title":"我和我的2018","banner":"assets/img/my2018.jpeg","_content":"\n\n我叫。。\n算了我叫什么并不重要。\n今年。。\n算了我今年几岁也不重要。\n说回主角\n2018，\n这个年末，很冷，有雪。\n记得来杭州第一年冬天我是不用开空调的。\n2018年，\n对友情越来越重。\n对生活越来越丧。\n2018年，回忆不起什么能让我记住的事情。\n不对，一定是回忆的姿势不对。\n被窝里，躺着慢慢想，然后。。睡着了。\n楼下，对着雪花想，冷到死人啊。大脑不运转了。\n点个外卖，垃圾食品让我兴奋，快乐水让我忘记一切。\n开电脑，本职工作应该可以有所触动，这特么谁写的，好炫酷实现好自然好不做作，奥我写的。我这么有追求来着？\n打开一部电影，应该可以触动回忆。卧槽好特么感人想哭。\n掏出街机switch，我的米珐啊。。心都化了。\n翻翻微博知乎别人的博客，找点灵感，卧槽好大好白好长好直。\n哎，我刚才要干嘛来着？\n看看朋友圈，算了不看了。\n嗯。。\n嗯。。\n这种感觉就像，当别人问你周末都做什么的时候，你才发现自己连个爱好都没有。\n看来，2019年第一个flag就是记录生活的小事，以防无事可写。\n比如，我独自一人去衣服店买好了衣服并和漂亮的售货员小姐姐相视一笑这种可以载入史册的事情。\n再使劲想想。\n使劲。。\n嗯。。\n嗯。。\n然后还有。。\n脑袋要炸了。。\n算了，想不出来。\n那就这样吧。。\n点一首歌送给2018年。\n那就这样吧。\n这歌词比我还丧。\n2018年要过去了，有点不舍。\n我不知道我在不舍什么，因为2018年过的也就那样。\n2019年，过来的也不知道是个什么鬼。\n反正他也只有一年寿命而已。\n","source":"_posts/my2018.md","raw":"\nlayout: post\ntitle: 我和我的2018\nbanner: assets/img/my2018.jpeg\ntags:\n- life\n---\n\n\n我叫。。\n算了我叫什么并不重要。\n今年。。\n算了我今年几岁也不重要。\n说回主角\n2018，\n这个年末，很冷，有雪。\n记得来杭州第一年冬天我是不用开空调的。\n2018年，\n对友情越来越重。\n对生活越来越丧。\n2018年，回忆不起什么能让我记住的事情。\n不对，一定是回忆的姿势不对。\n被窝里，躺着慢慢想，然后。。睡着了。\n楼下，对着雪花想，冷到死人啊。大脑不运转了。\n点个外卖，垃圾食品让我兴奋，快乐水让我忘记一切。\n开电脑，本职工作应该可以有所触动，这特么谁写的，好炫酷实现好自然好不做作，奥我写的。我这么有追求来着？\n打开一部电影，应该可以触动回忆。卧槽好特么感人想哭。\n掏出街机switch，我的米珐啊。。心都化了。\n翻翻微博知乎别人的博客，找点灵感，卧槽好大好白好长好直。\n哎，我刚才要干嘛来着？\n看看朋友圈，算了不看了。\n嗯。。\n嗯。。\n这种感觉就像，当别人问你周末都做什么的时候，你才发现自己连个爱好都没有。\n看来，2019年第一个flag就是记录生活的小事，以防无事可写。\n比如，我独自一人去衣服店买好了衣服并和漂亮的售货员小姐姐相视一笑这种可以载入史册的事情。\n再使劲想想。\n使劲。。\n嗯。。\n嗯。。\n然后还有。。\n脑袋要炸了。。\n算了，想不出来。\n那就这样吧。。\n点一首歌送给2018年。\n那就这样吧。\n这歌词比我还丧。\n2018年要过去了，有点不舍。\n我不知道我在不舍什么，因为2018年过的也就那样。\n2019年，过来的也不知道是个什么鬼。\n反正他也只有一年寿命而已。\n","slug":"my2018","published":1,"date":"2019-01-17T13:00:11.000Z","updated":"2019-01-17T13:00:11.000Z","comments":1,"photos":[],"link":"","_id":"cjr1en2o20011ha9syz8kbkvn","content":"<p>我叫。。<br>\n算了我叫什么并不重要。<br>\n今年。。<br>\n算了我今年几岁也不重要。<br>\n说回主角<br>\n2018，<br>\n这个年末，很冷，有雪。<br>\n记得来杭州第一年冬天我是不用开空调的。<br>\n2018年，<br>\n对友情越来越重。<br>\n对生活越来越丧。<br>\n2018年，回忆不起什么能让我记住的事情。<br>\n不对，一定是回忆的姿势不对。<br>\n被窝里，躺着慢慢想，然后。。睡着了。<br>\n楼下，对着雪花想，冷到死人啊。大脑不运转了。<br>\n点个外卖，垃圾食品让我兴奋，快乐水让我忘记一切。<br>\n开电脑，本职工作应该可以有所触动，这特么谁写的，好炫酷实现好自然好不做作，奥我写的。我这么有追求来着？<br>\n打开一部电影，应该可以触动回忆。卧槽好特么感人想哭。<br>\n掏出街机switch，我的米珐啊。。心都化了。<br>\n翻翻微博知乎别人的博客，找点灵感，卧槽好大好白好长好直。<br>\n哎，我刚才要干嘛来着？<br>\n看看朋友圈，算了不看了。<br>\n嗯。。<br>\n嗯。。<br>\n这种感觉就像，当别人问你周末都做什么的时候，你才发现自己连个爱好都没有。<br>\n看来，2019年第一个flag就是记录生活的小事，以防无事可写。<br>\n比如，我独自一人去衣服店买好了衣服并和漂亮的售货员小姐姐相视一笑这种可以载入史册的事情。<br>\n再使劲想想。<br>\n使劲。。<br>\n嗯。。<br>\n嗯。。<br>\n然后还有。。<br>\n脑袋要炸了。。<br>\n算了，想不出来。<br>\n那就这样吧。。<br>\n点一首歌送给2018年。<br>\n那就这样吧。<br>\n这歌词比我还丧。<br>\n2018年要过去了，有点不舍。<br>\n我不知道我在不舍什么，因为2018年过的也就那样。<br>\n2019年，过来的也不知道是个什么鬼。<br>\n反正他也只有一年寿命而已。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>我叫。。<br>\n算了我叫什么并不重要。<br>\n今年。。<br>\n算了我今年几岁也不重要。<br>\n说回主角<br>\n2018，<br>\n这个年末，很冷，有雪。<br>\n记得来杭州第一年冬天我是不用开空调的。<br>\n2018年，<br>\n对友情越来越重。<br>\n对生活越来越丧。<br>\n2018年，回忆不起什么能让我记住的事情。<br>\n不对，一定是回忆的姿势不对。<br>\n被窝里，躺着慢慢想，然后。。睡着了。<br>\n楼下，对着雪花想，冷到死人啊。大脑不运转了。<br>\n点个外卖，垃圾食品让我兴奋，快乐水让我忘记一切。<br>\n开电脑，本职工作应该可以有所触动，这特么谁写的，好炫酷实现好自然好不做作，奥我写的。我这么有追求来着？<br>\n打开一部电影，应该可以触动回忆。卧槽好特么感人想哭。<br>\n掏出街机switch，我的米珐啊。。心都化了。<br>\n翻翻微博知乎别人的博客，找点灵感，卧槽好大好白好长好直。<br>\n哎，我刚才要干嘛来着？<br>\n看看朋友圈，算了不看了。<br>\n嗯。。<br>\n嗯。。<br>\n这种感觉就像，当别人问你周末都做什么的时候，你才发现自己连个爱好都没有。<br>\n看来，2019年第一个flag就是记录生活的小事，以防无事可写。<br>\n比如，我独自一人去衣服店买好了衣服并和漂亮的售货员小姐姐相视一笑这种可以载入史册的事情。<br>\n再使劲想想。<br>\n使劲。。<br>\n嗯。。<br>\n嗯。。<br>\n然后还有。。<br>\n脑袋要炸了。。<br>\n算了，想不出来。<br>\n那就这样吧。。<br>\n点一首歌送给2018年。<br>\n那就这样吧。<br>\n这歌词比我还丧。<br>\n2018年要过去了，有点不舍。<br>\n我不知道我在不舍什么，因为2018年过的也就那样。<br>\n2019年，过来的也不知道是个什么鬼。<br>\n反正他也只有一年寿命而已。</p>\n"},{"layout":"post","title":"我和前端的2017","banner":"assets/img/myself-recently.jpeg","_content":"\n16年其实一直在做 Electron 的桌面应用（Mac 为主），春节后也一直在做，那时候重心开始放在内嵌 webview 的开发，开始探索如何更好的给 web 应用提供接口，更好的展示 web 内的应用，并且随着内置的云盘和新闻项目，也有了一些实践经验。\n\n紧接着，webpack 发布了重要的 2.0 版本，正好我们的打包脚本对于项目也开始有些乏力，所以开始决定重构打包脚本，将 webpack 替换为 2.0，同时将一些 gulp 任务也改为直接借助 webpack 及其插件实现。打包脚本修改的同时，也兼顾到了端与端的差异，比如桌面端会用到的 nodejs 模块在 Web 端需要忽略掉，此时也真正的将 web 版本和桌面版本的代码合在了一起，推动几个小伙伴在代码层面做了重构，并顺利的部署在了测试环境。\n\n不过有时候就是这么不巧，这个接到通知需要去另外一个项目。所以虽然该重构的也重构了，该合并的也合并了，总觉得还是有点遗憾。\n\n换到了新的项目组之后，主要的工作也从 Web 技术开发客户端回到了传统的 web 项目，虽然是移动端项目，但我一般不认为移动端项目有什么特殊之处。不过各种国产机总会给你意想不到的惊喜，所以有时候代码写的还是挺谨慎。\n\n在开发内部使用的后台的时候，用了一波 vue，虽然这个时候采用 vue 显得有点晚了一些。vue 确实给后台的开发提升了很大的速度，团队还有一个 ios 的小伙，也是很快的上了手，并承担了大部分任务。感觉以后可能会有一个岗位叫 vue 开发工程师。。。\n\n进入新的项目后可能对我最重要的影响是，让我对一些很基础的东西有了新的认识，比如：浏览器本地存储（cookie、sessionStorage、localStorage），跨域请求（预检请求的触发、跨域读写 cookie 以及如何 IE8 下兼容 CORS）。\n\n然后再感受一点技术无关的事情，在项目里算是体验了一点电商的感觉，市场和运营在主导着产品的走向，开发的节奏也很不稳定。前端来说，可能要给运营产出很多的活动页或者工具，就要求这些工具有很大的灵活性，能够很快的上线新的需求。\n\n然后不巧的事情又发生了，又要准备打包去另外一个项目组了。\n\n所以最近的日子还是很平稳的，所以就有时间到处看看，看了下 virtual dom 然后自己撸了个库；看路由的实现，自己搞一下实现；翻翻 spring boot，和服务端更好的交流；看看数据可视化的例子，养养眼。。\n\n流水账以这样记录了一年的事情，好像有些没记起来没写进去，新的一年有新的项目，希望可以有新的积累。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/my-fe-and-me.md","raw":"\nlayout: post\ntitle: 我和前端的2017\nbanner: assets/img/myself-recently.jpeg\ntags: life\n---\n\n16年其实一直在做 Electron 的桌面应用（Mac 为主），春节后也一直在做，那时候重心开始放在内嵌 webview 的开发，开始探索如何更好的给 web 应用提供接口，更好的展示 web 内的应用，并且随着内置的云盘和新闻项目，也有了一些实践经验。\n\n紧接着，webpack 发布了重要的 2.0 版本，正好我们的打包脚本对于项目也开始有些乏力，所以开始决定重构打包脚本，将 webpack 替换为 2.0，同时将一些 gulp 任务也改为直接借助 webpack 及其插件实现。打包脚本修改的同时，也兼顾到了端与端的差异，比如桌面端会用到的 nodejs 模块在 Web 端需要忽略掉，此时也真正的将 web 版本和桌面版本的代码合在了一起，推动几个小伙伴在代码层面做了重构，并顺利的部署在了测试环境。\n\n不过有时候就是这么不巧，这个接到通知需要去另外一个项目。所以虽然该重构的也重构了，该合并的也合并了，总觉得还是有点遗憾。\n\n换到了新的项目组之后，主要的工作也从 Web 技术开发客户端回到了传统的 web 项目，虽然是移动端项目，但我一般不认为移动端项目有什么特殊之处。不过各种国产机总会给你意想不到的惊喜，所以有时候代码写的还是挺谨慎。\n\n在开发内部使用的后台的时候，用了一波 vue，虽然这个时候采用 vue 显得有点晚了一些。vue 确实给后台的开发提升了很大的速度，团队还有一个 ios 的小伙，也是很快的上了手，并承担了大部分任务。感觉以后可能会有一个岗位叫 vue 开发工程师。。。\n\n进入新的项目后可能对我最重要的影响是，让我对一些很基础的东西有了新的认识，比如：浏览器本地存储（cookie、sessionStorage、localStorage），跨域请求（预检请求的触发、跨域读写 cookie 以及如何 IE8 下兼容 CORS）。\n\n然后再感受一点技术无关的事情，在项目里算是体验了一点电商的感觉，市场和运营在主导着产品的走向，开发的节奏也很不稳定。前端来说，可能要给运营产出很多的活动页或者工具，就要求这些工具有很大的灵活性，能够很快的上线新的需求。\n\n然后不巧的事情又发生了，又要准备打包去另外一个项目组了。\n\n所以最近的日子还是很平稳的，所以就有时间到处看看，看了下 virtual dom 然后自己撸了个库；看路由的实现，自己搞一下实现；翻翻 spring boot，和服务端更好的交流；看看数据可视化的例子，养养眼。。\n\n流水账以这样记录了一年的事情，好像有些没记起来没写进去，新的一年有新的项目，希望可以有新的积累。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"my-fe-and-me","published":1,"date":"2019-01-17T13:00:11.000Z","updated":"2019-01-17T13:00:11.000Z","comments":1,"photos":[],"link":"","_id":"cjr1en2o30014ha9swxe09me4","content":"<p>16年其实一直在做 Electron 的桌面应用（Mac 为主），春节后也一直在做，那时候重心开始放在内嵌 webview 的开发，开始探索如何更好的给 web 应用提供接口，更好的展示 web 内的应用，并且随着内置的云盘和新闻项目，也有了一些实践经验。</p>\n<p>紧接着，webpack 发布了重要的 2.0 版本，正好我们的打包脚本对于项目也开始有些乏力，所以开始决定重构打包脚本，将 webpack 替换为 2.0，同时将一些 gulp 任务也改为直接借助 webpack 及其插件实现。打包脚本修改的同时，也兼顾到了端与端的差异，比如桌面端会用到的 nodejs 模块在 Web 端需要忽略掉，此时也真正的将 web 版本和桌面版本的代码合在了一起，推动几个小伙伴在代码层面做了重构，并顺利的部署在了测试环境。</p>\n<p>不过有时候就是这么不巧，这个接到通知需要去另外一个项目。所以虽然该重构的也重构了，该合并的也合并了，总觉得还是有点遗憾。</p>\n<p>换到了新的项目组之后，主要的工作也从 Web 技术开发客户端回到了传统的 web 项目，虽然是移动端项目，但我一般不认为移动端项目有什么特殊之处。不过各种国产机总会给你意想不到的惊喜，所以有时候代码写的还是挺谨慎。</p>\n<p>在开发内部使用的后台的时候，用了一波 vue，虽然这个时候采用 vue 显得有点晚了一些。vue 确实给后台的开发提升了很大的速度，团队还有一个 ios 的小伙，也是很快的上了手，并承担了大部分任务。感觉以后可能会有一个岗位叫 vue 开发工程师。。。</p>\n<p>进入新的项目后可能对我最重要的影响是，让我对一些很基础的东西有了新的认识，比如：浏览器本地存储（cookie、sessionStorage、localStorage），跨域请求（预检请求的触发、跨域读写 cookie 以及如何 IE8 下兼容 CORS）。</p>\n<p>然后再感受一点技术无关的事情，在项目里算是体验了一点电商的感觉，市场和运营在主导着产品的走向，开发的节奏也很不稳定。前端来说，可能要给运营产出很多的活动页或者工具，就要求这些工具有很大的灵活性，能够很快的上线新的需求。</p>\n<p>然后不巧的事情又发生了，又要准备打包去另外一个项目组了。</p>\n<p>所以最近的日子还是很平稳的，所以就有时间到处看看，看了下 virtual dom 然后自己撸了个库；看路由的实现，自己搞一下实现；翻翻 spring boot，和服务端更好的交流；看看数据可视化的例子，养养眼。。</p>\n<p>流水账以这样记录了一年的事情，好像有些没记起来没写进去，新的一年有新的项目，希望可以有新的积累。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>16年其实一直在做 Electron 的桌面应用（Mac 为主），春节后也一直在做，那时候重心开始放在内嵌 webview 的开发，开始探索如何更好的给 web 应用提供接口，更好的展示 web 内的应用，并且随着内置的云盘和新闻项目，也有了一些实践经验。</p>\n<p>紧接着，webpack 发布了重要的 2.0 版本，正好我们的打包脚本对于项目也开始有些乏力，所以开始决定重构打包脚本，将 webpack 替换为 2.0，同时将一些 gulp 任务也改为直接借助 webpack 及其插件实现。打包脚本修改的同时，也兼顾到了端与端的差异，比如桌面端会用到的 nodejs 模块在 Web 端需要忽略掉，此时也真正的将 web 版本和桌面版本的代码合在了一起，推动几个小伙伴在代码层面做了重构，并顺利的部署在了测试环境。</p>\n<p>不过有时候就是这么不巧，这个接到通知需要去另外一个项目。所以虽然该重构的也重构了，该合并的也合并了，总觉得还是有点遗憾。</p>\n<p>换到了新的项目组之后，主要的工作也从 Web 技术开发客户端回到了传统的 web 项目，虽然是移动端项目，但我一般不认为移动端项目有什么特殊之处。不过各种国产机总会给你意想不到的惊喜，所以有时候代码写的还是挺谨慎。</p>\n<p>在开发内部使用的后台的时候，用了一波 vue，虽然这个时候采用 vue 显得有点晚了一些。vue 确实给后台的开发提升了很大的速度，团队还有一个 ios 的小伙，也是很快的上了手，并承担了大部分任务。感觉以后可能会有一个岗位叫 vue 开发工程师。。。</p>\n<p>进入新的项目后可能对我最重要的影响是，让我对一些很基础的东西有了新的认识，比如：浏览器本地存储（cookie、sessionStorage、localStorage），跨域请求（预检请求的触发、跨域读写 cookie 以及如何 IE8 下兼容 CORS）。</p>\n<p>然后再感受一点技术无关的事情，在项目里算是体验了一点电商的感觉，市场和运营在主导着产品的走向，开发的节奏也很不稳定。前端来说，可能要给运营产出很多的活动页或者工具，就要求这些工具有很大的灵活性，能够很快的上线新的需求。</p>\n<p>然后不巧的事情又发生了，又要准备打包去另外一个项目组了。</p>\n<p>所以最近的日子还是很平稳的，所以就有时间到处看看，看了下 virtual dom 然后自己撸了个库；看路由的实现，自己搞一下实现；翻翻 spring boot，和服务端更好的交流；看看数据可视化的例子，养养眼。。</p>\n<p>流水账以这样记录了一年的事情，好像有些没记起来没写进去，新的一年有新的项目，希望可以有新的积累。</p>\n"},{"layout":"post","title":"最近的状态","banner":"assets/img/myself-recently.jpeg","_content":"\n今天520，一个比较不适合一个人走路回家的日子，下班就已经10点半了，不想路上还是很热闹，各种大货车，也有各种挖掘机开始施工，而且这个日子当然遇到多对情侣，女生手捧鲜花，男生提着大包小包，看到此情此景，心想应该打车回家的啊。。\n\n为什么周六还要这么晚回家，其实我自己也是纳闷的。\n\n前段时间部门调整，离开企业易信，去了新的部门。关于离开企业易信，其实还是很突然的，当然我们无法揣测上级的意思，作为一个搬砖跳坑的小兵，上级的安排只能服从。其实离开企业易信，还是很不舍得的，其实从入职就是和这些人一起工作，也有了一些挚友。并且在企业易信中，尝试了一些新的技术：做了一个比较复杂的单页应用，也就是企业易信 Web 版；也尝试使用 Electron 开发了 Mac 版本（之前有一篇关于 Electron 的博文），并且实现了一套代码，打包到两个平台。并且在开发中，第一次使用了 Redux（虽然还有很多瑕疵），也大面积的使用了 Webpack、gulp 来简化和流程化我们的开发和打包（在网易内部我比较多的接触是使用一个一键部署的 nej 打包工具的）。\n\n企业易信，算是我参加工作以来做过的最复杂的应用了，这个复杂并不是说有多少个页面，而是这个页面有许多的模块，各个模块数据相互联系，又涉及实时推送界面更新。在这个项目中还是有了很多的收获。因为这个项目是自己一直跟过来的，所以还是很有情感的。不过留下维护的童鞋也是个很极客很喜欢倒腾的人，我也很放心。\n\n说回刚才的话题，周六加班，当然是做新项目了。\n\n晚上一个人走在路上，有些失落。\n\n> 突然发现，有些事情，过了很久，或许是一年，也或许是两年，你才知道当时的人们到底付出了多少情感，到底付出了多少的勇气。而我现在才明白，也已经来不及了。再过段时间，当和别人说笑着谈起这些事情的时候，别人看不到，有多少把锋利的刀子插在我的心上。\n\n\n\n","source":"_posts/myself-recently.md","raw":"\nlayout: post\ntitle: 最近的状态\nbanner: assets/img/myself-recently.jpeg\ntags: life\n---\n\n今天520，一个比较不适合一个人走路回家的日子，下班就已经10点半了，不想路上还是很热闹，各种大货车，也有各种挖掘机开始施工，而且这个日子当然遇到多对情侣，女生手捧鲜花，男生提着大包小包，看到此情此景，心想应该打车回家的啊。。\n\n为什么周六还要这么晚回家，其实我自己也是纳闷的。\n\n前段时间部门调整，离开企业易信，去了新的部门。关于离开企业易信，其实还是很突然的，当然我们无法揣测上级的意思，作为一个搬砖跳坑的小兵，上级的安排只能服从。其实离开企业易信，还是很不舍得的，其实从入职就是和这些人一起工作，也有了一些挚友。并且在企业易信中，尝试了一些新的技术：做了一个比较复杂的单页应用，也就是企业易信 Web 版；也尝试使用 Electron 开发了 Mac 版本（之前有一篇关于 Electron 的博文），并且实现了一套代码，打包到两个平台。并且在开发中，第一次使用了 Redux（虽然还有很多瑕疵），也大面积的使用了 Webpack、gulp 来简化和流程化我们的开发和打包（在网易内部我比较多的接触是使用一个一键部署的 nej 打包工具的）。\n\n企业易信，算是我参加工作以来做过的最复杂的应用了，这个复杂并不是说有多少个页面，而是这个页面有许多的模块，各个模块数据相互联系，又涉及实时推送界面更新。在这个项目中还是有了很多的收获。因为这个项目是自己一直跟过来的，所以还是很有情感的。不过留下维护的童鞋也是个很极客很喜欢倒腾的人，我也很放心。\n\n说回刚才的话题，周六加班，当然是做新项目了。\n\n晚上一个人走在路上，有些失落。\n\n> 突然发现，有些事情，过了很久，或许是一年，也或许是两年，你才知道当时的人们到底付出了多少情感，到底付出了多少的勇气。而我现在才明白，也已经来不及了。再过段时间，当和别人说笑着谈起这些事情的时候，别人看不到，有多少把锋利的刀子插在我的心上。\n\n\n\n","slug":"myself-recently","published":1,"date":"2019-01-17T13:00:11.000Z","updated":"2019-01-17T13:00:11.000Z","comments":1,"photos":[],"link":"","_id":"cjr1en2o50016ha9swrmfdfkg","content":"<p>今天520，一个比较不适合一个人走路回家的日子，下班就已经10点半了，不想路上还是很热闹，各种大货车，也有各种挖掘机开始施工，而且这个日子当然遇到多对情侣，女生手捧鲜花，男生提着大包小包，看到此情此景，心想应该打车回家的啊。。</p>\n<p>为什么周六还要这么晚回家，其实我自己也是纳闷的。</p>\n<p>前段时间部门调整，离开企业易信，去了新的部门。关于离开企业易信，其实还是很突然的，当然我们无法揣测上级的意思，作为一个搬砖跳坑的小兵，上级的安排只能服从。其实离开企业易信，还是很不舍得的，其实从入职就是和这些人一起工作，也有了一些挚友。并且在企业易信中，尝试了一些新的技术：做了一个比较复杂的单页应用，也就是企业易信 Web 版；也尝试使用 Electron 开发了 Mac 版本（之前有一篇关于 Electron 的博文），并且实现了一套代码，打包到两个平台。并且在开发中，第一次使用了 Redux（虽然还有很多瑕疵），也大面积的使用了 Webpack、gulp 来简化和流程化我们的开发和打包（在网易内部我比较多的接触是使用一个一键部署的 nej 打包工具的）。</p>\n<p>企业易信，算是我参加工作以来做过的最复杂的应用了，这个复杂并不是说有多少个页面，而是这个页面有许多的模块，各个模块数据相互联系，又涉及实时推送界面更新。在这个项目中还是有了很多的收获。因为这个项目是自己一直跟过来的，所以还是很有情感的。不过留下维护的童鞋也是个很极客很喜欢倒腾的人，我也很放心。</p>\n<p>说回刚才的话题，周六加班，当然是做新项目了。</p>\n<p>晚上一个人走在路上，有些失落。</p>\n<blockquote>\n<p>突然发现，有些事情，过了很久，或许是一年，也或许是两年，你才知道当时的人们到底付出了多少情感，到底付出了多少的勇气。而我现在才明白，也已经来不及了。再过段时间，当和别人说笑着谈起这些事情的时候，别人看不到，有多少把锋利的刀子插在我的心上。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>今天520，一个比较不适合一个人走路回家的日子，下班就已经10点半了，不想路上还是很热闹，各种大货车，也有各种挖掘机开始施工，而且这个日子当然遇到多对情侣，女生手捧鲜花，男生提着大包小包，看到此情此景，心想应该打车回家的啊。。</p>\n<p>为什么周六还要这么晚回家，其实我自己也是纳闷的。</p>\n<p>前段时间部门调整，离开企业易信，去了新的部门。关于离开企业易信，其实还是很突然的，当然我们无法揣测上级的意思，作为一个搬砖跳坑的小兵，上级的安排只能服从。其实离开企业易信，还是很不舍得的，其实从入职就是和这些人一起工作，也有了一些挚友。并且在企业易信中，尝试了一些新的技术：做了一个比较复杂的单页应用，也就是企业易信 Web 版；也尝试使用 Electron 开发了 Mac 版本（之前有一篇关于 Electron 的博文），并且实现了一套代码，打包到两个平台。并且在开发中，第一次使用了 Redux（虽然还有很多瑕疵），也大面积的使用了 Webpack、gulp 来简化和流程化我们的开发和打包（在网易内部我比较多的接触是使用一个一键部署的 nej 打包工具的）。</p>\n<p>企业易信，算是我参加工作以来做过的最复杂的应用了，这个复杂并不是说有多少个页面，而是这个页面有许多的模块，各个模块数据相互联系，又涉及实时推送界面更新。在这个项目中还是有了很多的收获。因为这个项目是自己一直跟过来的，所以还是很有情感的。不过留下维护的童鞋也是个很极客很喜欢倒腾的人，我也很放心。</p>\n<p>说回刚才的话题，周六加班，当然是做新项目了。</p>\n<p>晚上一个人走在路上，有些失落。</p>\n<blockquote>\n<p>突然发现，有些事情，过了很久，或许是一年，也或许是两年，你才知道当时的人们到底付出了多少情感，到底付出了多少的勇气。而我现在才明白，也已经来不及了。再过段时间，当和别人说笑着谈起这些事情的时候，别人看不到，有多少把锋利的刀子插在我的心上。</p>\n</blockquote>\n"},{"layout":"post","title":"新的博客，新的一年","banner":"assets/img/new-year-new-blog.jpeg","date":"2017-02-25T16:00:00.000Z","updated":"2017-09-02T02:54:00.000Z","_content":"\n在好多可以写博客的地方混迹过，但每次都不持久（误）。要么就是这个平台压根想不起来（避免挨打，不列举了），要么就是这个平台看起来又老又旧，万年不更新的样子，虽然样式可以自己定制（比如[博客园](http://www.cnblogs.com/zjzhome/)）。索性就自己做一个。\n\n开始是 fork 了 [barryclark/jekyll-now](https://github.com/barryclark/jekyll-now)这个项目，基于 jekyll。半年后（2017-8-29），迁移到了 Hexo，并且自己制作了主题，在主题制作过程中，借（chao）鉴（xi）了一些博客的样式和结构。:joy:\n\n做一个能让自己赏心悦目的博客呢也主要是为了让自己能有写文章的动力。其实特别敬佩那些时常能更新文章并且文章有长度也有深度的人，比如张鑫旭大大，既有很新的知识又有一些看起来很常见，但他的文章会深挖一些你不知道又很有趣的特性。话说回自己，从工作到现在，其实也接触了一些新的东西并有了一些收获，但好像并没有很好的沉淀下来，也没有很好的分享出去。去年年底的时候，被群里一个小伙伴追着写了一篇关于 `Electron` 的文章，才发现自己用 Electron 用了大半年，却没有留下几篇文章，或许是关于 Electron 本身的，或许是关于 web 技术构建桌面应用的，或许是 web 应用和客户端应用的差异，都没有，很是汗颜。\n\n所以给自己开一个新的地方，留下一些文字，留下一些成长。\n\n去年元旦半夜，我写过一段挺矫情的话：\n\n> 我是个没有计划的人，2015年底并没有给2016规划，所以我并不知道我的2016年比预期的要好还是坏。我看到了我2016年失去了什么，并为此难眠，我看不到2017年我该去做什么，我不知道该不该给2017年一个规划。但不管怎样，即使我拒绝进入下一年，2017也会把我笼罩。明早，我会放一首孙燕姿的第一天把我从2017叫醒。\n\n2017年，开始吧 :smile:\n\n---\n\n*感谢*\n\n* 特别参考 [kikobeats](https://kikobeats.com/)\n* 参考 [hexo-theme-icarus](http://blog.zhangruipeng.me/hexo-theme-icarus/)\n* 参考 [hexo-theme-tranquilpeak/](http://louisbarranqueiro.github.io/hexo-theme-tranquilpeak/)\n* 参考 [http://www.ahonn.me/](http://www.ahonn.me/)\n* 图片来源 [PEXELS](https://www.pexels.com/?ref=producthunt)\n* 图片来源 [泼辣有图](http://www.polayoutu.com/collections)\n* 评论 [来必力](https://livere.com/introduce)\n","source":"_posts/new-blog-and-new-year.md","raw":"\nlayout: post\ntitle: 新的博客，新的一年\nbanner: assets/img/new-year-new-blog.jpeg\ndate: 2017-2-26\nupdated: 2017-9-2 10:54\ntags: life\n---\n\n在好多可以写博客的地方混迹过，但每次都不持久（误）。要么就是这个平台压根想不起来（避免挨打，不列举了），要么就是这个平台看起来又老又旧，万年不更新的样子，虽然样式可以自己定制（比如[博客园](http://www.cnblogs.com/zjzhome/)）。索性就自己做一个。\n\n开始是 fork 了 [barryclark/jekyll-now](https://github.com/barryclark/jekyll-now)这个项目，基于 jekyll。半年后（2017-8-29），迁移到了 Hexo，并且自己制作了主题，在主题制作过程中，借（chao）鉴（xi）了一些博客的样式和结构。:joy:\n\n做一个能让自己赏心悦目的博客呢也主要是为了让自己能有写文章的动力。其实特别敬佩那些时常能更新文章并且文章有长度也有深度的人，比如张鑫旭大大，既有很新的知识又有一些看起来很常见，但他的文章会深挖一些你不知道又很有趣的特性。话说回自己，从工作到现在，其实也接触了一些新的东西并有了一些收获，但好像并没有很好的沉淀下来，也没有很好的分享出去。去年年底的时候，被群里一个小伙伴追着写了一篇关于 `Electron` 的文章，才发现自己用 Electron 用了大半年，却没有留下几篇文章，或许是关于 Electron 本身的，或许是关于 web 技术构建桌面应用的，或许是 web 应用和客户端应用的差异，都没有，很是汗颜。\n\n所以给自己开一个新的地方，留下一些文字，留下一些成长。\n\n去年元旦半夜，我写过一段挺矫情的话：\n\n> 我是个没有计划的人，2015年底并没有给2016规划，所以我并不知道我的2016年比预期的要好还是坏。我看到了我2016年失去了什么，并为此难眠，我看不到2017年我该去做什么，我不知道该不该给2017年一个规划。但不管怎样，即使我拒绝进入下一年，2017也会把我笼罩。明早，我会放一首孙燕姿的第一天把我从2017叫醒。\n\n2017年，开始吧 :smile:\n\n---\n\n*感谢*\n\n* 特别参考 [kikobeats](https://kikobeats.com/)\n* 参考 [hexo-theme-icarus](http://blog.zhangruipeng.me/hexo-theme-icarus/)\n* 参考 [hexo-theme-tranquilpeak/](http://louisbarranqueiro.github.io/hexo-theme-tranquilpeak/)\n* 参考 [http://www.ahonn.me/](http://www.ahonn.me/)\n* 图片来源 [PEXELS](https://www.pexels.com/?ref=producthunt)\n* 图片来源 [泼辣有图](http://www.polayoutu.com/collections)\n* 评论 [来必力](https://livere.com/introduce)\n","slug":"new-blog-and-new-year","published":1,"comments":1,"photos":[],"link":"","_id":"cjr1en2o60018ha9ssffw25a8","content":"<p>在好多可以写博客的地方混迹过，但每次都不持久（误）。要么就是这个平台压根想不起来（避免挨打，不列举了），要么就是这个平台看起来又老又旧，万年不更新的样子，虽然样式可以自己定制（比如<a href=\"http://www.cnblogs.com/zjzhome/\" target=\"_blank\" rel=\"noopener\">博客园</a>）。索性就自己做一个。</p>\n<p>开始是 fork 了 <a href=\"https://github.com/barryclark/jekyll-now\" target=\"_blank\" rel=\"noopener\">barryclark/jekyll-now</a>这个项目，基于 jekyll。半年后（2017-8-29），迁移到了 Hexo，并且自己制作了主题，在主题制作过程中，借（chao）鉴（xi）了一些博客的样式和结构。😂</p>\n<p>做一个能让自己赏心悦目的博客呢也主要是为了让自己能有写文章的动力。其实特别敬佩那些时常能更新文章并且文章有长度也有深度的人，比如张鑫旭大大，既有很新的知识又有一些看起来很常见，但他的文章会深挖一些你不知道又很有趣的特性。话说回自己，从工作到现在，其实也接触了一些新的东西并有了一些收获，但好像并没有很好的沉淀下来，也没有很好的分享出去。去年年底的时候，被群里一个小伙伴追着写了一篇关于 <code>Electron</code> 的文章，才发现自己用 Electron 用了大半年，却没有留下几篇文章，或许是关于 Electron 本身的，或许是关于 web 技术构建桌面应用的，或许是 web 应用和客户端应用的差异，都没有，很是汗颜。</p>\n<p>所以给自己开一个新的地方，留下一些文字，留下一些成长。</p>\n<p>去年元旦半夜，我写过一段挺矫情的话：</p>\n<blockquote>\n<p>我是个没有计划的人，2015年底并没有给2016规划，所以我并不知道我的2016年比预期的要好还是坏。我看到了我2016年失去了什么，并为此难眠，我看不到2017年我该去做什么，我不知道该不该给2017年一个规划。但不管怎样，即使我拒绝进入下一年，2017也会把我笼罩。明早，我会放一首孙燕姿的第一天把我从2017叫醒。</p>\n</blockquote>\n<p>2017年，开始吧 😄</p>\n<hr>\n<p><em>感谢</em></p>\n<ul>\n<li>特别参考 <a href=\"https://kikobeats.com/\" target=\"_blank\" rel=\"noopener\">kikobeats</a></li>\n<li>参考 <a href=\"http://blog.zhangruipeng.me/hexo-theme-icarus/\" target=\"_blank\" rel=\"noopener\">hexo-theme-icarus</a></li>\n<li>参考 <a href=\"http://louisbarranqueiro.github.io/hexo-theme-tranquilpeak/\" target=\"_blank\" rel=\"noopener\">hexo-theme-tranquilpeak/</a></li>\n<li>参考 <a href=\"http://www.ahonn.me/\" target=\"_blank\" rel=\"noopener\">http://www.ahonn.me/</a></li>\n<li>图片来源 <a href=\"https://www.pexels.com/?ref=producthunt\" target=\"_blank\" rel=\"noopener\">PEXELS</a></li>\n<li>图片来源 <a href=\"http://www.polayoutu.com/collections\" target=\"_blank\" rel=\"noopener\">泼辣有图</a></li>\n<li>评论 <a href=\"https://livere.com/introduce\" target=\"_blank\" rel=\"noopener\">来必力</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>在好多可以写博客的地方混迹过，但每次都不持久（误）。要么就是这个平台压根想不起来（避免挨打，不列举了），要么就是这个平台看起来又老又旧，万年不更新的样子，虽然样式可以自己定制（比如<a href=\"http://www.cnblogs.com/zjzhome/\" target=\"_blank\" rel=\"noopener\">博客园</a>）。索性就自己做一个。</p>\n<p>开始是 fork 了 <a href=\"https://github.com/barryclark/jekyll-now\" target=\"_blank\" rel=\"noopener\">barryclark/jekyll-now</a>这个项目，基于 jekyll。半年后（2017-8-29），迁移到了 Hexo，并且自己制作了主题，在主题制作过程中，借（chao）鉴（xi）了一些博客的样式和结构。😂</p>\n<p>做一个能让自己赏心悦目的博客呢也主要是为了让自己能有写文章的动力。其实特别敬佩那些时常能更新文章并且文章有长度也有深度的人，比如张鑫旭大大，既有很新的知识又有一些看起来很常见，但他的文章会深挖一些你不知道又很有趣的特性。话说回自己，从工作到现在，其实也接触了一些新的东西并有了一些收获，但好像并没有很好的沉淀下来，也没有很好的分享出去。去年年底的时候，被群里一个小伙伴追着写了一篇关于 <code>Electron</code> 的文章，才发现自己用 Electron 用了大半年，却没有留下几篇文章，或许是关于 Electron 本身的，或许是关于 web 技术构建桌面应用的，或许是 web 应用和客户端应用的差异，都没有，很是汗颜。</p>\n<p>所以给自己开一个新的地方，留下一些文字，留下一些成长。</p>\n<p>去年元旦半夜，我写过一段挺矫情的话：</p>\n<blockquote>\n<p>我是个没有计划的人，2015年底并没有给2016规划，所以我并不知道我的2016年比预期的要好还是坏。我看到了我2016年失去了什么，并为此难眠，我看不到2017年我该去做什么，我不知道该不该给2017年一个规划。但不管怎样，即使我拒绝进入下一年，2017也会把我笼罩。明早，我会放一首孙燕姿的第一天把我从2017叫醒。</p>\n</blockquote>\n<p>2017年，开始吧 😄</p>\n<hr>\n<p><em>感谢</em></p>\n<ul>\n<li>特别参考 <a href=\"https://kikobeats.com/\" target=\"_blank\" rel=\"noopener\">kikobeats</a></li>\n<li>参考 <a href=\"http://blog.zhangruipeng.me/hexo-theme-icarus/\" target=\"_blank\" rel=\"noopener\">hexo-theme-icarus</a></li>\n<li>参考 <a href=\"http://louisbarranqueiro.github.io/hexo-theme-tranquilpeak/\" target=\"_blank\" rel=\"noopener\">hexo-theme-tranquilpeak/</a></li>\n<li>参考 <a href=\"http://www.ahonn.me/\" target=\"_blank\" rel=\"noopener\">http://www.ahonn.me/</a></li>\n<li>图片来源 <a href=\"https://www.pexels.com/?ref=producthunt\" target=\"_blank\" rel=\"noopener\">PEXELS</a></li>\n<li>图片来源 <a href=\"http://www.polayoutu.com/collections\" target=\"_blank\" rel=\"noopener\">泼辣有图</a></li>\n<li>评论 <a href=\"https://livere.com/introduce\" target=\"_blank\" rel=\"noopener\">来必力</a></li>\n</ul>\n"},{"layout":"post","title":"REMEBER","banner":"assets/img/remember.jpeg","date":"2017-06-15T16:00:00.000Z","_content":"\n这周周五，决定不加班，在小区外的超市买了饮料、啤酒、雪糕扔进冰箱，买了杨梅。\n\n看完了西游伏妖篇，好吧，这电影都好久了。最近讨论的都是异形木乃伊之类的。\n\n特效完美，吴亦凡尬戏，女星艳美，剧情反转略干。\n\n唐僧忘不掉的段小姐，化为孙悟空的金箍，感情微妙。\n\n看着电影吃完了杨梅，特意买了两盒。却吃不出去年的味道。\n\n去年，是什么味道来着？\n\n前几周，回到刚来杭州租房的地方附近，找不到那家筒骨饭了，一对夫妻开店，儿子偶尔帮忙，味道也很好。突然不知道吃什么了。\n\n晚上没开灯，彻夜难眠，有好几个时刻我都有些恍惚，这个侧脸真的好像。\n\n周日晚上看了笑声传奇，蔡明老师说：人这一辈子，不是想做什么就能做什么的。\n\n笑声传奇里的那个哑剧组合真的是惊艳到了我，以前一直感觉这种艺术形式很无聊，但这个不一样。一个完整的故事，充实的剧情，感人的结尾。\n\n循环往复的生活。","source":"_posts/remeber.md","raw":"\nlayout: post\ntitle: REMEBER\nbanner: assets/img/remember.jpeg\ndate: 2017-6-16\ntags: life\n---\n\n这周周五，决定不加班，在小区外的超市买了饮料、啤酒、雪糕扔进冰箱，买了杨梅。\n\n看完了西游伏妖篇，好吧，这电影都好久了。最近讨论的都是异形木乃伊之类的。\n\n特效完美，吴亦凡尬戏，女星艳美，剧情反转略干。\n\n唐僧忘不掉的段小姐，化为孙悟空的金箍，感情微妙。\n\n看着电影吃完了杨梅，特意买了两盒。却吃不出去年的味道。\n\n去年，是什么味道来着？\n\n前几周，回到刚来杭州租房的地方附近，找不到那家筒骨饭了，一对夫妻开店，儿子偶尔帮忙，味道也很好。突然不知道吃什么了。\n\n晚上没开灯，彻夜难眠，有好几个时刻我都有些恍惚，这个侧脸真的好像。\n\n周日晚上看了笑声传奇，蔡明老师说：人这一辈子，不是想做什么就能做什么的。\n\n笑声传奇里的那个哑剧组合真的是惊艳到了我，以前一直感觉这种艺术形式很无聊，但这个不一样。一个完整的故事，充实的剧情，感人的结尾。\n\n循环往复的生活。","slug":"remeber","published":1,"updated":"2019-01-17T13:00:11.000Z","comments":1,"photos":[],"link":"","_id":"cjr1en2o7001aha9stb9516fl","content":"<p>这周周五，决定不加班，在小区外的超市买了饮料、啤酒、雪糕扔进冰箱，买了杨梅。</p>\n<p>看完了西游伏妖篇，好吧，这电影都好久了。最近讨论的都是异形木乃伊之类的。</p>\n<p>特效完美，吴亦凡尬戏，女星艳美，剧情反转略干。</p>\n<p>唐僧忘不掉的段小姐，化为孙悟空的金箍，感情微妙。</p>\n<p>看着电影吃完了杨梅，特意买了两盒。却吃不出去年的味道。</p>\n<p>去年，是什么味道来着？</p>\n<p>前几周，回到刚来杭州租房的地方附近，找不到那家筒骨饭了，一对夫妻开店，儿子偶尔帮忙，味道也很好。突然不知道吃什么了。</p>\n<p>晚上没开灯，彻夜难眠，有好几个时刻我都有些恍惚，这个侧脸真的好像。</p>\n<p>周日晚上看了笑声传奇，蔡明老师说：人这一辈子，不是想做什么就能做什么的。</p>\n<p>笑声传奇里的那个哑剧组合真的是惊艳到了我，以前一直感觉这种艺术形式很无聊，但这个不一样。一个完整的故事，充实的剧情，感人的结尾。</p>\n<p>循环往复的生活。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这周周五，决定不加班，在小区外的超市买了饮料、啤酒、雪糕扔进冰箱，买了杨梅。</p>\n<p>看完了西游伏妖篇，好吧，这电影都好久了。最近讨论的都是异形木乃伊之类的。</p>\n<p>特效完美，吴亦凡尬戏，女星艳美，剧情反转略干。</p>\n<p>唐僧忘不掉的段小姐，化为孙悟空的金箍，感情微妙。</p>\n<p>看着电影吃完了杨梅，特意买了两盒。却吃不出去年的味道。</p>\n<p>去年，是什么味道来着？</p>\n<p>前几周，回到刚来杭州租房的地方附近，找不到那家筒骨饭了，一对夫妻开店，儿子偶尔帮忙，味道也很好。突然不知道吃什么了。</p>\n<p>晚上没开灯，彻夜难眠，有好几个时刻我都有些恍惚，这个侧脸真的好像。</p>\n<p>周日晚上看了笑声传奇，蔡明老师说：人这一辈子，不是想做什么就能做什么的。</p>\n<p>笑声传奇里的那个哑剧组合真的是惊艳到了我，以前一直感觉这种艺术形式很无聊，但这个不一样。一个完整的故事，充实的剧情，感人的结尾。</p>\n<p>循环往复的生活。</p>\n"},{"layout":"post","title":"心中有嘻哈","banner":"assets/img/rap-of-china.jpeg","date":"2017-09-10T15:04:00.000Z","updated":"2019-01-17T13:00:11.000Z","_content":"\n周六晚上看完了中国有嘻哈的总决赛。\n\n嗯，已经很少有哪个综艺能让我从头追到尾了。\n\n自己的挺早的时候就开始听 rap，最早也最喜欢的当然是周杰伦，到现在为止，依然感觉周杰伦的 rap 是最屌也是最舒服的。后来听了热狗、蛋堡、AP 满人、Jony J。节目开播前段时间听到了 Bridge 的老大并被圈粉。\n\n最后的结果是双冠军，不管是真的巧合也好还是精心安排也好，这也是个不错的结果。只不过每人票数 125，嗯，总数250，不知道这个250指得是谁。\n\n吴亦凡再次改编了周杰伦的歌，这次是以父之名，上次是三年二班，虽然大家都再说改编的怎么怎么好，但我依然觉得并不好听。可能原曲太难以超越，再怎么改编都是亵渎。\n\nPG One 最后一首歌，加入了让子弹飞的台词绝对是亮点。不过最近的黑点貌似有点多，只能说年纪还小，做事情多思考一些。（这句话也送给我自己）\n\nGAI 的霸气真的无可挑剔，喜欢 GAI 的唱腔和风格。\n\n统一 GAI 说的话，场外投票很扯淡，脑残粉刷存在感的重要时刻。当场外票数PG One 遥遥领先的时候，吴亦凡露出了邪魅的笑容。只能说制作人和下面的选手真的很统一。\n\n所以也强烈同意热狗说的，幸好不是下面的观众投票，要不然又是脑残粉刷存在感。\n\n还有一个小细节，练习生 rapper 最后投票好像都投的 GAI，之前的剪辑，GAI 对练习生 rapper 是最不爽的。\n\nbridge 一如既往的调皮，投票时第一次直接用脚踩，真的是用脚投票了，我还害怕后面的人会不会觉得被踩了太脏不去按 GAI 的投票器了哈哈。第二次嘴里吐出的投票牌。\n\n心疼 Jony J，实力很强，不知道为什么大家就像忽略了他一样。不过还是看到小青龙和 TT 把票投给了他。\n\n最后一期了，有点不舍。有嘻哈之后，越来越多的人开始听开始唱黑怕，不过还是希望大家喜欢的是嘻哈歌曲，而不是喜欢某个人，更不是给某个人当脑残粉，甚至傻逼到撕逼去人肉。\n\n**Keep Real!**\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/rap-of-china.md","raw":"\nlayout: post\ntitle: 心中有嘻哈\nbanner: assets/img/rap-of-china.jpeg\ndate: 2017-9-10 23:04\nupdated: 0\ntags: life\n---\n\n周六晚上看完了中国有嘻哈的总决赛。\n\n嗯，已经很少有哪个综艺能让我从头追到尾了。\n\n自己的挺早的时候就开始听 rap，最早也最喜欢的当然是周杰伦，到现在为止，依然感觉周杰伦的 rap 是最屌也是最舒服的。后来听了热狗、蛋堡、AP 满人、Jony J。节目开播前段时间听到了 Bridge 的老大并被圈粉。\n\n最后的结果是双冠军，不管是真的巧合也好还是精心安排也好，这也是个不错的结果。只不过每人票数 125，嗯，总数250，不知道这个250指得是谁。\n\n吴亦凡再次改编了周杰伦的歌，这次是以父之名，上次是三年二班，虽然大家都再说改编的怎么怎么好，但我依然觉得并不好听。可能原曲太难以超越，再怎么改编都是亵渎。\n\nPG One 最后一首歌，加入了让子弹飞的台词绝对是亮点。不过最近的黑点貌似有点多，只能说年纪还小，做事情多思考一些。（这句话也送给我自己）\n\nGAI 的霸气真的无可挑剔，喜欢 GAI 的唱腔和风格。\n\n统一 GAI 说的话，场外投票很扯淡，脑残粉刷存在感的重要时刻。当场外票数PG One 遥遥领先的时候，吴亦凡露出了邪魅的笑容。只能说制作人和下面的选手真的很统一。\n\n所以也强烈同意热狗说的，幸好不是下面的观众投票，要不然又是脑残粉刷存在感。\n\n还有一个小细节，练习生 rapper 最后投票好像都投的 GAI，之前的剪辑，GAI 对练习生 rapper 是最不爽的。\n\nbridge 一如既往的调皮，投票时第一次直接用脚踩，真的是用脚投票了，我还害怕后面的人会不会觉得被踩了太脏不去按 GAI 的投票器了哈哈。第二次嘴里吐出的投票牌。\n\n心疼 Jony J，实力很强，不知道为什么大家就像忽略了他一样。不过还是看到小青龙和 TT 把票投给了他。\n\n最后一期了，有点不舍。有嘻哈之后，越来越多的人开始听开始唱黑怕，不过还是希望大家喜欢的是嘻哈歌曲，而不是喜欢某个人，更不是给某个人当脑残粉，甚至傻逼到撕逼去人肉。\n\n**Keep Real!**\n\n\n\n\n\n\n\n\n\n\n\n","slug":"rap-of-china","published":1,"comments":1,"photos":[],"link":"","_id":"cjr1en2o8001cha9sbm1uegtx","content":"<p>周六晚上看完了中国有嘻哈的总决赛。</p>\n<p>嗯，已经很少有哪个综艺能让我从头追到尾了。</p>\n<p>自己的挺早的时候就开始听 rap，最早也最喜欢的当然是周杰伦，到现在为止，依然感觉周杰伦的 rap 是最屌也是最舒服的。后来听了热狗、蛋堡、AP 满人、Jony J。节目开播前段时间听到了 Bridge 的老大并被圈粉。</p>\n<p>最后的结果是双冠军，不管是真的巧合也好还是精心安排也好，这也是个不错的结果。只不过每人票数 125，嗯，总数250，不知道这个250指得是谁。</p>\n<p>吴亦凡再次改编了周杰伦的歌，这次是以父之名，上次是三年二班，虽然大家都再说改编的怎么怎么好，但我依然觉得并不好听。可能原曲太难以超越，再怎么改编都是亵渎。</p>\n<p>PG One 最后一首歌，加入了让子弹飞的台词绝对是亮点。不过最近的黑点貌似有点多，只能说年纪还小，做事情多思考一些。（这句话也送给我自己）</p>\n<p>GAI 的霸气真的无可挑剔，喜欢 GAI 的唱腔和风格。</p>\n<p>统一 GAI 说的话，场外投票很扯淡，脑残粉刷存在感的重要时刻。当场外票数PG One 遥遥领先的时候，吴亦凡露出了邪魅的笑容。只能说制作人和下面的选手真的很统一。</p>\n<p>所以也强烈同意热狗说的，幸好不是下面的观众投票，要不然又是脑残粉刷存在感。</p>\n<p>还有一个小细节，练习生 rapper 最后投票好像都投的 GAI，之前的剪辑，GAI 对练习生 rapper 是最不爽的。</p>\n<p>bridge 一如既往的调皮，投票时第一次直接用脚踩，真的是用脚投票了，我还害怕后面的人会不会觉得被踩了太脏不去按 GAI 的投票器了哈哈。第二次嘴里吐出的投票牌。</p>\n<p>心疼 Jony J，实力很强，不知道为什么大家就像忽略了他一样。不过还是看到小青龙和 TT 把票投给了他。</p>\n<p>最后一期了，有点不舍。有嘻哈之后，越来越多的人开始听开始唱黑怕，不过还是希望大家喜欢的是嘻哈歌曲，而不是喜欢某个人，更不是给某个人当脑残粉，甚至傻逼到撕逼去人肉。</p>\n<p><strong>Keep Real!</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<p>周六晚上看完了中国有嘻哈的总决赛。</p>\n<p>嗯，已经很少有哪个综艺能让我从头追到尾了。</p>\n<p>自己的挺早的时候就开始听 rap，最早也最喜欢的当然是周杰伦，到现在为止，依然感觉周杰伦的 rap 是最屌也是最舒服的。后来听了热狗、蛋堡、AP 满人、Jony J。节目开播前段时间听到了 Bridge 的老大并被圈粉。</p>\n<p>最后的结果是双冠军，不管是真的巧合也好还是精心安排也好，这也是个不错的结果。只不过每人票数 125，嗯，总数250，不知道这个250指得是谁。</p>\n<p>吴亦凡再次改编了周杰伦的歌，这次是以父之名，上次是三年二班，虽然大家都再说改编的怎么怎么好，但我依然觉得并不好听。可能原曲太难以超越，再怎么改编都是亵渎。</p>\n<p>PG One 最后一首歌，加入了让子弹飞的台词绝对是亮点。不过最近的黑点貌似有点多，只能说年纪还小，做事情多思考一些。（这句话也送给我自己）</p>\n<p>GAI 的霸气真的无可挑剔，喜欢 GAI 的唱腔和风格。</p>\n<p>统一 GAI 说的话，场外投票很扯淡，脑残粉刷存在感的重要时刻。当场外票数PG One 遥遥领先的时候，吴亦凡露出了邪魅的笑容。只能说制作人和下面的选手真的很统一。</p>\n<p>所以也强烈同意热狗说的，幸好不是下面的观众投票，要不然又是脑残粉刷存在感。</p>\n<p>还有一个小细节，练习生 rapper 最后投票好像都投的 GAI，之前的剪辑，GAI 对练习生 rapper 是最不爽的。</p>\n<p>bridge 一如既往的调皮，投票时第一次直接用脚踩，真的是用脚投票了，我还害怕后面的人会不会觉得被踩了太脏不去按 GAI 的投票器了哈哈。第二次嘴里吐出的投票牌。</p>\n<p>心疼 Jony J，实力很强，不知道为什么大家就像忽略了他一样。不过还是看到小青龙和 TT 把票投给了他。</p>\n<p>最后一期了，有点不舍。有嘻哈之后，越来越多的人开始听开始唱黑怕，不过还是希望大家喜欢的是嘻哈歌曲，而不是喜欢某个人，更不是给某个人当脑残粉，甚至傻逼到撕逼去人肉。</p>\n<p><strong>Keep Real!</strong></p>\n"},{"layout":"post","title":"常用排序查找算法 JavaScript 实现","banner":"assets/img/sort.jpg","_content":"\n一直没有对算法进行系统的了解，所以在这里对常用算法（排序和查找）做一些整理。\n\n## 冒泡排序\n\n冒泡排序，顾名思义，在多次循环中，小的数字会浮到数组左侧，大的数组则慢慢沉下去。\n\n```js\n// 交换方法\nfunction swap(arr, i, j) {\n    var temp = arr[i]\n    arr[i] = arr[j]\n    arr[j] = temp\n}\n```\n\n```js\nfunction bubbleSort(arr) {\n    for(var i = 1; i < arr.length; i++) {\n        for(var j = 0; j <= i; j++) {\n            if(arr[i] < arr[j]) {\n                swap(arr, i, j)\n            }\n            console.log(arr)\n        }\n    }\n\n    return arr\n}\n```\n\n## 插入排序\n\n插入排序中，插入是指选取合适的元素插入到适当的位置。\n\n插入排序有两个循环。外循环将数组元素挨个移动，而内循环则对外循环中选中的元素及 它后面的那个元素进行比较。如果外循环中选中的元素比内循环中选中的元素小，那么数 组元素会向右移动，为内循环中的这个元素腾出位置。（数据结构与算法JavaScript描述）\n\n```js\nfunction insertionSort(arr) {\n    var preIndex, current\n    for(var i = 1; i < arr.length; i++) {\n        preIndex = i - 1\n        current = arr[i]\n        while(preIndex >= 0 && arr[preIndex] > current) {\n            arr[preIndex+1] = arr[preIndex];\n            preIndex--\n        }\n        arr[preIndex+1] = current\n    }\n    return arr\n}\n```\n\n## 选择排序\n\n选择排序中的选择是选择数组中最小的元素，放到数组的第一位。\n\n选择排序从数组的开头开始，将第一个元素和其他元 素进行比较。检查完所有元素后，最小的元素会被放到数组的第一个位置，然后算法会从 第二个位置继续。这个过程一直进行，当进行到数组的倒数第二个位置时，所有的数据便 完成了排序。（数据结构与算法JavaScript描述）\n\n```js\nfunction selectionSort(arr) {\n    var minIndex;\n    for(var i = 0; i < arr.length - 1; i++) {\n        minIndex = i\n        for(var j = i+1; j < arr.length; j++) {\n            if(arr[j] < arr[minIndex]) {\n                minIndex = j\n            }\n        }\n\n        if(minIndex !== i) {\n            swap(arr, minIndex, i)\n        }\n    }\n\n    return arr\n}\n```\n\n## 快速排序\n\n快速排序很快。\n\n它是一种分而治之的算法，通过递归的方 式将数据依次分解为包含较小元素和较大元素的不同子序列。该算法不断重复这个步骤直 到所有数据都是有序的。（数据结构与算法JavaScript描述）\n\n```js\nfunction quickSort(arr) {\n    if(!arr.length) return []\n    var lesser = [];\n    var greater = [];\n    var middle = arr[0];\n\n    for(var i = 1; i < arr.length; i++) {\n        if(arr[i] <= middle) {\n            lesser.push(arr[i])\n        } else {\n            greater.push(arr[i])\n        }\n    }\n\n    return quickSort(lesser).concat(middle).concat(quickSort(greater))\n}\n```\n\n## 合并排序\n\n把一系列排好序的子序列合并成一个大的完整有序序列。\n\n```js\nfunction mergeSort(arr) { \n    var len = arr.length;\n    if(len < 2) {\n        return arr;\n    }\n    var middle = Math.floor(len / 2),\n        left = arr.slice(0, middle),\n        right = arr.slice(middle);\n    return merge(mergeSort(left), mergeSort(right));\n}\n\nfunction merge(left, right) {\n    var result = [];\n\n    while (left.length && right.length) {\n        if (left[0] <= right[0]) {\n            result.push(left.shift());\n        } else {\n            result.push(right.shift());\n        }\n    }\n\n    while (left.length)\n        result.push(left.shift());\n\n    while (right.length)\n        result.push(right.shift());\n\n    return result;\n}\n\n```\n\n## 二分查找\n\n只对有序的数据集有效。\n\n```js\nfunction binSearch(arr, item) {\n    var high = arr.length - 1\n    var low = 0\n    if(low > high) return -1\n\n    while(low <= high) {\n        var middle = Math.ceil((low + high)/2)\n\n        if(item > arr[middle]) {\n            low = middle + 1\n        } else if(item < arr[middle]) {\n            high = middle - 1\n        } else {\n            return middle\n        }\n    }\n\n    return -1;\n}\n```\n\n\n\n\n\n\n\n","source":"_posts/sort-search.md","raw":"\nlayout: post\ntitle: 常用排序查找算法 JavaScript 实现\nbanner: assets/img/sort.jpg\ntags: algorithm\n---\n\n一直没有对算法进行系统的了解，所以在这里对常用算法（排序和查找）做一些整理。\n\n## 冒泡排序\n\n冒泡排序，顾名思义，在多次循环中，小的数字会浮到数组左侧，大的数组则慢慢沉下去。\n\n```js\n// 交换方法\nfunction swap(arr, i, j) {\n    var temp = arr[i]\n    arr[i] = arr[j]\n    arr[j] = temp\n}\n```\n\n```js\nfunction bubbleSort(arr) {\n    for(var i = 1; i < arr.length; i++) {\n        for(var j = 0; j <= i; j++) {\n            if(arr[i] < arr[j]) {\n                swap(arr, i, j)\n            }\n            console.log(arr)\n        }\n    }\n\n    return arr\n}\n```\n\n## 插入排序\n\n插入排序中，插入是指选取合适的元素插入到适当的位置。\n\n插入排序有两个循环。外循环将数组元素挨个移动，而内循环则对外循环中选中的元素及 它后面的那个元素进行比较。如果外循环中选中的元素比内循环中选中的元素小，那么数 组元素会向右移动，为内循环中的这个元素腾出位置。（数据结构与算法JavaScript描述）\n\n```js\nfunction insertionSort(arr) {\n    var preIndex, current\n    for(var i = 1; i < arr.length; i++) {\n        preIndex = i - 1\n        current = arr[i]\n        while(preIndex >= 0 && arr[preIndex] > current) {\n            arr[preIndex+1] = arr[preIndex];\n            preIndex--\n        }\n        arr[preIndex+1] = current\n    }\n    return arr\n}\n```\n\n## 选择排序\n\n选择排序中的选择是选择数组中最小的元素，放到数组的第一位。\n\n选择排序从数组的开头开始，将第一个元素和其他元 素进行比较。检查完所有元素后，最小的元素会被放到数组的第一个位置，然后算法会从 第二个位置继续。这个过程一直进行，当进行到数组的倒数第二个位置时，所有的数据便 完成了排序。（数据结构与算法JavaScript描述）\n\n```js\nfunction selectionSort(arr) {\n    var minIndex;\n    for(var i = 0; i < arr.length - 1; i++) {\n        minIndex = i\n        for(var j = i+1; j < arr.length; j++) {\n            if(arr[j] < arr[minIndex]) {\n                minIndex = j\n            }\n        }\n\n        if(minIndex !== i) {\n            swap(arr, minIndex, i)\n        }\n    }\n\n    return arr\n}\n```\n\n## 快速排序\n\n快速排序很快。\n\n它是一种分而治之的算法，通过递归的方 式将数据依次分解为包含较小元素和较大元素的不同子序列。该算法不断重复这个步骤直 到所有数据都是有序的。（数据结构与算法JavaScript描述）\n\n```js\nfunction quickSort(arr) {\n    if(!arr.length) return []\n    var lesser = [];\n    var greater = [];\n    var middle = arr[0];\n\n    for(var i = 1; i < arr.length; i++) {\n        if(arr[i] <= middle) {\n            lesser.push(arr[i])\n        } else {\n            greater.push(arr[i])\n        }\n    }\n\n    return quickSort(lesser).concat(middle).concat(quickSort(greater))\n}\n```\n\n## 合并排序\n\n把一系列排好序的子序列合并成一个大的完整有序序列。\n\n```js\nfunction mergeSort(arr) { \n    var len = arr.length;\n    if(len < 2) {\n        return arr;\n    }\n    var middle = Math.floor(len / 2),\n        left = arr.slice(0, middle),\n        right = arr.slice(middle);\n    return merge(mergeSort(left), mergeSort(right));\n}\n\nfunction merge(left, right) {\n    var result = [];\n\n    while (left.length && right.length) {\n        if (left[0] <= right[0]) {\n            result.push(left.shift());\n        } else {\n            result.push(right.shift());\n        }\n    }\n\n    while (left.length)\n        result.push(left.shift());\n\n    while (right.length)\n        result.push(right.shift());\n\n    return result;\n}\n\n```\n\n## 二分查找\n\n只对有序的数据集有效。\n\n```js\nfunction binSearch(arr, item) {\n    var high = arr.length - 1\n    var low = 0\n    if(low > high) return -1\n\n    while(low <= high) {\n        var middle = Math.ceil((low + high)/2)\n\n        if(item > arr[middle]) {\n            low = middle + 1\n        } else if(item < arr[middle]) {\n            high = middle - 1\n        } else {\n            return middle\n        }\n    }\n\n    return -1;\n}\n```\n\n\n\n\n\n\n\n","slug":"sort-search","published":1,"date":"2019-01-17T13:00:11.000Z","updated":"2019-01-17T13:00:11.000Z","comments":1,"photos":[],"link":"","_id":"cjr1en2o9001eha9s1meomhvm","content":"<p>一直没有对算法进行系统的了解，所以在这里对常用算法（排序和查找）做一些整理。</p>\n<h2 id=\"冒泡排序\">冒泡排序</h2>\n<p>冒泡排序，顾名思义，在多次循环中，小的数字会浮到数组左侧，大的数组则慢慢沉下去。</p>\n<pre><code class=\"language-js\">// 交换方法\nfunction swap(arr, i, j) {\n    var temp = arr[i]\n    arr[i] = arr[j]\n    arr[j] = temp\n}\n</code></pre>\n<pre><code class=\"language-js\">function bubbleSort(arr) {\n    for(var i = 1; i &lt; arr.length; i++) {\n        for(var j = 0; j &lt;= i; j++) {\n            if(arr[i] &lt; arr[j]) {\n                swap(arr, i, j)\n            }\n            console.log(arr)\n        }\n    }\n\n    return arr\n}\n</code></pre>\n<h2 id=\"插入排序\">插入排序</h2>\n<p>插入排序中，插入是指选取合适的元素插入到适当的位置。</p>\n<p>插入排序有两个循环。外循环将数组元素挨个移动，而内循环则对外循环中选中的元素及 它后面的那个元素进行比较。如果外循环中选中的元素比内循环中选中的元素小，那么数 组元素会向右移动，为内循环中的这个元素腾出位置。（数据结构与算法JavaScript描述）</p>\n<pre><code class=\"language-js\">function insertionSort(arr) {\n    var preIndex, current\n    for(var i = 1; i &lt; arr.length; i++) {\n        preIndex = i - 1\n        current = arr[i]\n        while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) {\n            arr[preIndex+1] = arr[preIndex];\n            preIndex--\n        }\n        arr[preIndex+1] = current\n    }\n    return arr\n}\n</code></pre>\n<h2 id=\"选择排序\">选择排序</h2>\n<p>选择排序中的选择是选择数组中最小的元素，放到数组的第一位。</p>\n<p>选择排序从数组的开头开始，将第一个元素和其他元 素进行比较。检查完所有元素后，最小的元素会被放到数组的第一个位置，然后算法会从 第二个位置继续。这个过程一直进行，当进行到数组的倒数第二个位置时，所有的数据便 完成了排序。（数据结构与算法JavaScript描述）</p>\n<pre><code class=\"language-js\">function selectionSort(arr) {\n    var minIndex;\n    for(var i = 0; i &lt; arr.length - 1; i++) {\n        minIndex = i\n        for(var j = i+1; j &lt; arr.length; j++) {\n            if(arr[j] &lt; arr[minIndex]) {\n                minIndex = j\n            }\n        }\n\n        if(minIndex !== i) {\n            swap(arr, minIndex, i)\n        }\n    }\n\n    return arr\n}\n</code></pre>\n<h2 id=\"快速排序\">快速排序</h2>\n<p>快速排序很快。</p>\n<p>它是一种分而治之的算法，通过递归的方 式将数据依次分解为包含较小元素和较大元素的不同子序列。该算法不断重复这个步骤直 到所有数据都是有序的。（数据结构与算法JavaScript描述）</p>\n<pre><code class=\"language-js\">function quickSort(arr) {\n    if(!arr.length) return []\n    var lesser = [];\n    var greater = [];\n    var middle = arr[0];\n\n    for(var i = 1; i &lt; arr.length; i++) {\n        if(arr[i] &lt;= middle) {\n            lesser.push(arr[i])\n        } else {\n            greater.push(arr[i])\n        }\n    }\n\n    return quickSort(lesser).concat(middle).concat(quickSort(greater))\n}\n</code></pre>\n<h2 id=\"合并排序\">合并排序</h2>\n<p>把一系列排好序的子序列合并成一个大的完整有序序列。</p>\n<pre><code class=\"language-js\">function mergeSort(arr) { \n    var len = arr.length;\n    if(len &lt; 2) {\n        return arr;\n    }\n    var middle = Math.floor(len / 2),\n        left = arr.slice(0, middle),\n        right = arr.slice(middle);\n    return merge(mergeSort(left), mergeSort(right));\n}\n\nfunction merge(left, right) {\n    var result = [];\n\n    while (left.length &amp;&amp; right.length) {\n        if (left[0] &lt;= right[0]) {\n            result.push(left.shift());\n        } else {\n            result.push(right.shift());\n        }\n    }\n\n    while (left.length)\n        result.push(left.shift());\n\n    while (right.length)\n        result.push(right.shift());\n\n    return result;\n}\n\n</code></pre>\n<h2 id=\"二分查找\">二分查找</h2>\n<p>只对有序的数据集有效。</p>\n<pre><code class=\"language-js\">function binSearch(arr, item) {\n    var high = arr.length - 1\n    var low = 0\n    if(low &gt; high) return -1\n\n    while(low &lt;= high) {\n        var middle = Math.ceil((low + high)/2)\n\n        if(item &gt; arr[middle]) {\n            low = middle + 1\n        } else if(item &lt; arr[middle]) {\n            high = middle - 1\n        } else {\n            return middle\n        }\n    }\n\n    return -1;\n}\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>一直没有对算法进行系统的了解，所以在这里对常用算法（排序和查找）做一些整理。</p>\n<h2 id=\"冒泡排序\">冒泡排序</h2>\n<p>冒泡排序，顾名思义，在多次循环中，小的数字会浮到数组左侧，大的数组则慢慢沉下去。</p>\n<pre><code class=\"language-js\">// 交换方法\nfunction swap(arr, i, j) {\n    var temp = arr[i]\n    arr[i] = arr[j]\n    arr[j] = temp\n}\n</code></pre>\n<pre><code class=\"language-js\">function bubbleSort(arr) {\n    for(var i = 1; i &lt; arr.length; i++) {\n        for(var j = 0; j &lt;= i; j++) {\n            if(arr[i] &lt; arr[j]) {\n                swap(arr, i, j)\n            }\n            console.log(arr)\n        }\n    }\n\n    return arr\n}\n</code></pre>\n<h2 id=\"插入排序\">插入排序</h2>\n<p>插入排序中，插入是指选取合适的元素插入到适当的位置。</p>\n<p>插入排序有两个循环。外循环将数组元素挨个移动，而内循环则对外循环中选中的元素及 它后面的那个元素进行比较。如果外循环中选中的元素比内循环中选中的元素小，那么数 组元素会向右移动，为内循环中的这个元素腾出位置。（数据结构与算法JavaScript描述）</p>\n<pre><code class=\"language-js\">function insertionSort(arr) {\n    var preIndex, current\n    for(var i = 1; i &lt; arr.length; i++) {\n        preIndex = i - 1\n        current = arr[i]\n        while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) {\n            arr[preIndex+1] = arr[preIndex];\n            preIndex--\n        }\n        arr[preIndex+1] = current\n    }\n    return arr\n}\n</code></pre>\n<h2 id=\"选择排序\">选择排序</h2>\n<p>选择排序中的选择是选择数组中最小的元素，放到数组的第一位。</p>\n<p>选择排序从数组的开头开始，将第一个元素和其他元 素进行比较。检查完所有元素后，最小的元素会被放到数组的第一个位置，然后算法会从 第二个位置继续。这个过程一直进行，当进行到数组的倒数第二个位置时，所有的数据便 完成了排序。（数据结构与算法JavaScript描述）</p>\n<pre><code class=\"language-js\">function selectionSort(arr) {\n    var minIndex;\n    for(var i = 0; i &lt; arr.length - 1; i++) {\n        minIndex = i\n        for(var j = i+1; j &lt; arr.length; j++) {\n            if(arr[j] &lt; arr[minIndex]) {\n                minIndex = j\n            }\n        }\n\n        if(minIndex !== i) {\n            swap(arr, minIndex, i)\n        }\n    }\n\n    return arr\n}\n</code></pre>\n<h2 id=\"快速排序\">快速排序</h2>\n<p>快速排序很快。</p>\n<p>它是一种分而治之的算法，通过递归的方 式将数据依次分解为包含较小元素和较大元素的不同子序列。该算法不断重复这个步骤直 到所有数据都是有序的。（数据结构与算法JavaScript描述）</p>\n<pre><code class=\"language-js\">function quickSort(arr) {\n    if(!arr.length) return []\n    var lesser = [];\n    var greater = [];\n    var middle = arr[0];\n\n    for(var i = 1; i &lt; arr.length; i++) {\n        if(arr[i] &lt;= middle) {\n            lesser.push(arr[i])\n        } else {\n            greater.push(arr[i])\n        }\n    }\n\n    return quickSort(lesser).concat(middle).concat(quickSort(greater))\n}\n</code></pre>\n<h2 id=\"合并排序\">合并排序</h2>\n<p>把一系列排好序的子序列合并成一个大的完整有序序列。</p>\n<pre><code class=\"language-js\">function mergeSort(arr) { \n    var len = arr.length;\n    if(len &lt; 2) {\n        return arr;\n    }\n    var middle = Math.floor(len / 2),\n        left = arr.slice(0, middle),\n        right = arr.slice(middle);\n    return merge(mergeSort(left), mergeSort(right));\n}\n\nfunction merge(left, right) {\n    var result = [];\n\n    while (left.length &amp;&amp; right.length) {\n        if (left[0] &lt;= right[0]) {\n            result.push(left.shift());\n        } else {\n            result.push(right.shift());\n        }\n    }\n\n    while (left.length)\n        result.push(left.shift());\n\n    while (right.length)\n        result.push(right.shift());\n\n    return result;\n}\n\n</code></pre>\n<h2 id=\"二分查找\">二分查找</h2>\n<p>只对有序的数据集有效。</p>\n<pre><code class=\"language-js\">function binSearch(arr, item) {\n    var high = arr.length - 1\n    var low = 0\n    if(low &gt; high) return -1\n\n    while(low &lt;= high) {\n        var middle = Math.ceil((low + high)/2)\n\n        if(item &gt; arr[middle]) {\n            low = middle + 1\n        } else if(item &lt; arr[middle]) {\n            high = middle - 1\n        } else {\n            return middle\n        }\n    }\n\n    return -1;\n}\n</code></pre>\n"},{"layout":"post","title":"重温 XHR","banner":"assets/img/ajax.jpg","date":"2017-06-05T16:00:00.000Z","_content":"\n前端几乎所有的业务都离不开 Ajax，页面上 `$.ajax`、`axios` 满天飞，恐怕好久没有好好的认识 XMLHttpRequest 这个对象了。XMLHttpRequest 也已经有了好多改变，本文重新认识一下这个老朋友。\n\n## XHR 流程梳理\n\n* 首先初始初始化 XMLHttpRequest `var xhr = new XMLHttpRequest()`，在其他操作之前，即可监听 xhr 的状态变化事件。\n\n```js\nxhr.onreadystatechange = function() { /* 状态变化事件 */ }\n```\n\n* 调用 open 方法，初始化请求\n\n```js\n// 请求方法，请求地址，是否异步，用户名（可选），密码（可选）\nxhr.open(method, url, async, user, password)\n```\n\n在调用 open 方法之后，可以重写由服务器返回的MIME type，\n```js\n// 以前使用 xhr 提取图片常见方法\nxhr.overrideMimeType('text/plain; charset=x-user-defined')\n```\n\n* 修改请求头，发送请求之前可以设置请求的头部\n\n```js\nxhr.setRequestHeader(headerName, headerValue)\n```\n\n* 指定响应格式（xhr2）\n\n以前 xhr 的响应体，只有xhr.responseText 和 xhr.responseXML，responseXML真的很少用，几乎都是 responseText，JSON.parse 之后用， xhr2 提供了设置响应格式的方法：\n\n```js\n// arraybuffer\n// blob\n// document\n// json\nxhr.responseType = 'text'(默认)\n```\n\n设置之后，可以从 `xhr.response` 取得响应结果，`xhr.response` 的格式就是指定的格式。\n\n* 发送请求\n\n```js\n// 要发送的数据\n// xhr.sendAsBinary() [已经废弃](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/sendAsBinary)\n// \nxhr.send()\nxhr.send(ArrayBuffer data)\nxhr.send(Blob data)\nxhr.send(Document data)\nxhr.send(DOMString? data)\nxhr.send(FormData data)\n// 发送后，可能abort\nxhr.abort()\n```\n\n* 处理响应结果\n\nxhr1 中通过监听 onreadystatechange 事件\n\n```js\nxhr.onreadystatechange = function() {\n    if(xhr.readyState == 4) {\n        if((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {\n            // 请求成功\n            handleResponse(xhr.responseText) // 或者 xhr.responseXML\n        } else {\n            // 请求失败\n        }\n    } \n}\n```\n\nxhr2 增加了几个新的事件，监听 xhr 的进度。\n\n```js\nxhr.onprogress = function() {}\nxhr.onload = function() {}\nxhr.onerror = function() {}\nxhr.abort = function() {}\n```\n\n同事也可以监听上传事件\n\n```js\nxhr.upload.onprogress = function() {}\n```\n\n## 实例\n\n从实际触发看一些实例。\n\n### 简单xhr2 请求\n\n重点关注不同的请求头对请求的影响。推荐 [四种常见的 POST 提交数据方式](四种常见的 POST 提交数据方式)\n\n```js\n\nvar xhr = new XMLHttpRequest()\n\nxhr.onprogress = function(e) { \n    console.log('进度：' + e.loaded / e.total)\n}\nxhr.onload = function() {\n    // 请求结束\n    if(xhr.status == 200) {\n        console.log(xhr.response)\n    } else {\n        // handle error\n    }\n}\nxhr.onerror = function(err) {\n    // 不知道何时触发\n}\nxhr.abort = function() {\n    console.log('abort')\n}\n\n// express 服务器为例\n// req.query = { x: HHH }\nxhr.open('post', '/xhr2-post?' + 'x=' + encodeURIComponent('HHH'), true) \nxhr.responseType = 'json'\n\n// post 请求默认请求头为 application/x-www-form-urlencoded\n// req.body = { z: 123 }\n// 此时如果传入JSON.stringify({ y: 123 })，req.body = { '{y:123}': '' }\nxhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded')\nxhr.send('z=' + encodeURIComponent('123'))\n\n// application/json 请求头\n// req.body = { y: 123 }\n// 如果此时 send 参数传入 y=123, 得到400错误\nxhr.setRequestHeader('Content-Type', 'application/json')\nxhr.send(JSON.stringify({\n    y: 123\n}))\n\nxhr.abort() // 会触发 abort 事件\n```\n\n### iframe 上传\n\nxhr2 之前，如果要实现无刷新上传只能借助于 iframe，因为 form 表单只能同步提交。上传进度也一般依赖于轮询。\n\niframe 上传就是将 form 表单提交到 iframe 里，在 iframe 里得到服务端返回的数据，形成一种未刷新的假象。\n\n```html\n<!--\ntarget 设置为 iframe 的 name\n-->\n<form id=\"form\" action=\"/upload\" target=\"frame\" method=\"post\" enctype=\"multipart/form-data\">\n    <input type=\"file\" id=\"file\" name=\"file\" /> <br />\n    <input type=\"submit\" value=\"上传\" />\n</form>\n\n<iframe id=\"uploadFrame\" name=\"frame\" style=\"display:none;\"></iframe>\n```\n\n```js\nwindow.uploadCallback = function(data) {\n    console.log(data)\n}\n\nvar form = document.getElementById('form')\nvar frame = document.getElementById('uploadFrame')\nform.onsubmit = function(e) {\n    frame.src = form.action\n\n    frame.onload = function() {\n        var db = frame.contentDocument.body\n        var txt = db.textContent\n        parent.uploadCallback(JSON.parse(txt))\n    }\n}   \n```\n\n```js\n// 服务器返回一段 js\n// express multer 代码\napp.post('/upload', upload.single('file'), function(req, res) {\n    res.json({\n        code: 200,\n        body: req.file\n    })\n})\n```\n\n### HTML5 文件上传\n\nXHR2 出现之后，异步上传文件变的简单的多。\n\nform 表单和上面一样，target 属性去掉。\n\n```js\nform.onsubmit = function(e) {\n    e.preventDefault()\n\n    // formData 提交\n    var formData = new FormData(form)\n\n    var xhr = new XMLHttpRequest()\n    xhr.open('POST', form.action, true)\n    xhr.responseType = 'json'\n\n    xhr.onload = function() { \n        if(xhr.status == 200) {\n            console.log(xhr.response)\n        }\n    }\n\n    // 监听上传进度\n    xhr.upload.onprogress = function(e) {\n        if (e.lengthComputable) {\n            console.log(e.loaded / e.total)\n        } \n    }\n\n    xhr.send(formData)\n}\n```\n\n## 总结\n\n重新梳理了下 XHR 的相关知识，清晰了许多。如果需要兼容 IE8 等浏览器，如果加上跨域和 jsonp，就是一个完整的 ajax 库了。比如 [NEJ 的 Ajax 模块](https://github.com/genify/nej/blob/master/doc/AJAX.md)。\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/review-xhr.md","raw":"\nlayout: post\ntitle:  重温 XHR\nbanner: assets/img/ajax.jpg\ndate: 2017-6-6\ntags: \n- JavaScript\n- xhr\n---\n\n前端几乎所有的业务都离不开 Ajax，页面上 `$.ajax`、`axios` 满天飞，恐怕好久没有好好的认识 XMLHttpRequest 这个对象了。XMLHttpRequest 也已经有了好多改变，本文重新认识一下这个老朋友。\n\n## XHR 流程梳理\n\n* 首先初始初始化 XMLHttpRequest `var xhr = new XMLHttpRequest()`，在其他操作之前，即可监听 xhr 的状态变化事件。\n\n```js\nxhr.onreadystatechange = function() { /* 状态变化事件 */ }\n```\n\n* 调用 open 方法，初始化请求\n\n```js\n// 请求方法，请求地址，是否异步，用户名（可选），密码（可选）\nxhr.open(method, url, async, user, password)\n```\n\n在调用 open 方法之后，可以重写由服务器返回的MIME type，\n```js\n// 以前使用 xhr 提取图片常见方法\nxhr.overrideMimeType('text/plain; charset=x-user-defined')\n```\n\n* 修改请求头，发送请求之前可以设置请求的头部\n\n```js\nxhr.setRequestHeader(headerName, headerValue)\n```\n\n* 指定响应格式（xhr2）\n\n以前 xhr 的响应体，只有xhr.responseText 和 xhr.responseXML，responseXML真的很少用，几乎都是 responseText，JSON.parse 之后用， xhr2 提供了设置响应格式的方法：\n\n```js\n// arraybuffer\n// blob\n// document\n// json\nxhr.responseType = 'text'(默认)\n```\n\n设置之后，可以从 `xhr.response` 取得响应结果，`xhr.response` 的格式就是指定的格式。\n\n* 发送请求\n\n```js\n// 要发送的数据\n// xhr.sendAsBinary() [已经废弃](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/sendAsBinary)\n// \nxhr.send()\nxhr.send(ArrayBuffer data)\nxhr.send(Blob data)\nxhr.send(Document data)\nxhr.send(DOMString? data)\nxhr.send(FormData data)\n// 发送后，可能abort\nxhr.abort()\n```\n\n* 处理响应结果\n\nxhr1 中通过监听 onreadystatechange 事件\n\n```js\nxhr.onreadystatechange = function() {\n    if(xhr.readyState == 4) {\n        if((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {\n            // 请求成功\n            handleResponse(xhr.responseText) // 或者 xhr.responseXML\n        } else {\n            // 请求失败\n        }\n    } \n}\n```\n\nxhr2 增加了几个新的事件，监听 xhr 的进度。\n\n```js\nxhr.onprogress = function() {}\nxhr.onload = function() {}\nxhr.onerror = function() {}\nxhr.abort = function() {}\n```\n\n同事也可以监听上传事件\n\n```js\nxhr.upload.onprogress = function() {}\n```\n\n## 实例\n\n从实际触发看一些实例。\n\n### 简单xhr2 请求\n\n重点关注不同的请求头对请求的影响。推荐 [四种常见的 POST 提交数据方式](四种常见的 POST 提交数据方式)\n\n```js\n\nvar xhr = new XMLHttpRequest()\n\nxhr.onprogress = function(e) { \n    console.log('进度：' + e.loaded / e.total)\n}\nxhr.onload = function() {\n    // 请求结束\n    if(xhr.status == 200) {\n        console.log(xhr.response)\n    } else {\n        // handle error\n    }\n}\nxhr.onerror = function(err) {\n    // 不知道何时触发\n}\nxhr.abort = function() {\n    console.log('abort')\n}\n\n// express 服务器为例\n// req.query = { x: HHH }\nxhr.open('post', '/xhr2-post?' + 'x=' + encodeURIComponent('HHH'), true) \nxhr.responseType = 'json'\n\n// post 请求默认请求头为 application/x-www-form-urlencoded\n// req.body = { z: 123 }\n// 此时如果传入JSON.stringify({ y: 123 })，req.body = { '{y:123}': '' }\nxhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded')\nxhr.send('z=' + encodeURIComponent('123'))\n\n// application/json 请求头\n// req.body = { y: 123 }\n// 如果此时 send 参数传入 y=123, 得到400错误\nxhr.setRequestHeader('Content-Type', 'application/json')\nxhr.send(JSON.stringify({\n    y: 123\n}))\n\nxhr.abort() // 会触发 abort 事件\n```\n\n### iframe 上传\n\nxhr2 之前，如果要实现无刷新上传只能借助于 iframe，因为 form 表单只能同步提交。上传进度也一般依赖于轮询。\n\niframe 上传就是将 form 表单提交到 iframe 里，在 iframe 里得到服务端返回的数据，形成一种未刷新的假象。\n\n```html\n<!--\ntarget 设置为 iframe 的 name\n-->\n<form id=\"form\" action=\"/upload\" target=\"frame\" method=\"post\" enctype=\"multipart/form-data\">\n    <input type=\"file\" id=\"file\" name=\"file\" /> <br />\n    <input type=\"submit\" value=\"上传\" />\n</form>\n\n<iframe id=\"uploadFrame\" name=\"frame\" style=\"display:none;\"></iframe>\n```\n\n```js\nwindow.uploadCallback = function(data) {\n    console.log(data)\n}\n\nvar form = document.getElementById('form')\nvar frame = document.getElementById('uploadFrame')\nform.onsubmit = function(e) {\n    frame.src = form.action\n\n    frame.onload = function() {\n        var db = frame.contentDocument.body\n        var txt = db.textContent\n        parent.uploadCallback(JSON.parse(txt))\n    }\n}   \n```\n\n```js\n// 服务器返回一段 js\n// express multer 代码\napp.post('/upload', upload.single('file'), function(req, res) {\n    res.json({\n        code: 200,\n        body: req.file\n    })\n})\n```\n\n### HTML5 文件上传\n\nXHR2 出现之后，异步上传文件变的简单的多。\n\nform 表单和上面一样，target 属性去掉。\n\n```js\nform.onsubmit = function(e) {\n    e.preventDefault()\n\n    // formData 提交\n    var formData = new FormData(form)\n\n    var xhr = new XMLHttpRequest()\n    xhr.open('POST', form.action, true)\n    xhr.responseType = 'json'\n\n    xhr.onload = function() { \n        if(xhr.status == 200) {\n            console.log(xhr.response)\n        }\n    }\n\n    // 监听上传进度\n    xhr.upload.onprogress = function(e) {\n        if (e.lengthComputable) {\n            console.log(e.loaded / e.total)\n        } \n    }\n\n    xhr.send(formData)\n}\n```\n\n## 总结\n\n重新梳理了下 XHR 的相关知识，清晰了许多。如果需要兼容 IE8 等浏览器，如果加上跨域和 jsonp，就是一个完整的 ajax 库了。比如 [NEJ 的 Ajax 模块](https://github.com/genify/nej/blob/master/doc/AJAX.md)。\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"review-xhr","published":1,"updated":"2019-01-17T13:00:11.000Z","comments":1,"photos":[],"link":"","_id":"cjr1en2oa001gha9s7f61mufw","content":"<p>前端几乎所有的业务都离不开 Ajax，页面上 <code>$.ajax</code>、<code>axios</code> 满天飞，恐怕好久没有好好的认识 XMLHttpRequest 这个对象了。XMLHttpRequest 也已经有了好多改变，本文重新认识一下这个老朋友。</p>\n<h2 id=\"xhr-流程梳理\">XHR 流程梳理</h2>\n<ul>\n<li>首先初始初始化 XMLHttpRequest <code>var xhr = new XMLHttpRequest()</code>，在其他操作之前，即可监听 xhr 的状态变化事件。</li>\n</ul>\n<pre><code class=\"language-js\">xhr.onreadystatechange = function() { /* 状态变化事件 */ }\n</code></pre>\n<ul>\n<li>调用 open 方法，初始化请求</li>\n</ul>\n<pre><code class=\"language-js\">// 请求方法，请求地址，是否异步，用户名（可选），密码（可选）\nxhr.open(method, url, async, user, password)\n</code></pre>\n<p>在调用 open 方法之后，可以重写由服务器返回的MIME type，</p>\n<pre><code class=\"language-js\">// 以前使用 xhr 提取图片常见方法\nxhr.overrideMimeType('text/plain; charset=x-user-defined')\n</code></pre>\n<ul>\n<li>修改请求头，发送请求之前可以设置请求的头部</li>\n</ul>\n<pre><code class=\"language-js\">xhr.setRequestHeader(headerName, headerValue)\n</code></pre>\n<ul>\n<li>指定响应格式（xhr2）</li>\n</ul>\n<p>以前 xhr 的响应体，只有xhr.responseText 和 xhr.responseXML，responseXML真的很少用，几乎都是 responseText，JSON.parse 之后用， xhr2 提供了设置响应格式的方法：</p>\n<pre><code class=\"language-js\">// arraybuffer\n// blob\n// document\n// json\nxhr.responseType = 'text'(默认)\n</code></pre>\n<p>设置之后，可以从 <code>xhr.response</code> 取得响应结果，<code>xhr.response</code> 的格式就是指定的格式。</p>\n<ul>\n<li>发送请求</li>\n</ul>\n<pre><code class=\"language-js\">// 要发送的数据\n// xhr.sendAsBinary() [已经废弃](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/sendAsBinary)\n// \nxhr.send()\nxhr.send(ArrayBuffer data)\nxhr.send(Blob data)\nxhr.send(Document data)\nxhr.send(DOMString? data)\nxhr.send(FormData data)\n// 发送后，可能abort\nxhr.abort()\n</code></pre>\n<ul>\n<li>处理响应结果</li>\n</ul>\n<p>xhr1 中通过监听 onreadystatechange 事件</p>\n<pre><code class=\"language-js\">xhr.onreadystatechange = function() {\n    if(xhr.readyState == 4) {\n        if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) {\n            // 请求成功\n            handleResponse(xhr.responseText) // 或者 xhr.responseXML\n        } else {\n            // 请求失败\n        }\n    } \n}\n</code></pre>\n<p>xhr2 增加了几个新的事件，监听 xhr 的进度。</p>\n<pre><code class=\"language-js\">xhr.onprogress = function() {}\nxhr.onload = function() {}\nxhr.onerror = function() {}\nxhr.abort = function() {}\n</code></pre>\n<p>同事也可以监听上传事件</p>\n<pre><code class=\"language-js\">xhr.upload.onprogress = function() {}\n</code></pre>\n<h2 id=\"实例\">实例</h2>\n<p>从实际触发看一些实例。</p>\n<h3 id=\"简单xhr2-请求\">简单xhr2 请求</h3>\n<p>重点关注不同的请求头对请求的影响。推荐 [四种常见的 POST 提交数据方式](四种常见的 POST 提交数据方式)</p>\n<pre><code class=\"language-js\">\nvar xhr = new XMLHttpRequest()\n\nxhr.onprogress = function(e) { \n    console.log('进度：' + e.loaded / e.total)\n}\nxhr.onload = function() {\n    // 请求结束\n    if(xhr.status == 200) {\n        console.log(xhr.response)\n    } else {\n        // handle error\n    }\n}\nxhr.onerror = function(err) {\n    // 不知道何时触发\n}\nxhr.abort = function() {\n    console.log('abort')\n}\n\n// express 服务器为例\n// req.query = { x: HHH }\nxhr.open('post', '/xhr2-post?' + 'x=' + encodeURIComponent('HHH'), true) \nxhr.responseType = 'json'\n\n// post 请求默认请求头为 application/x-www-form-urlencoded\n// req.body = { z: 123 }\n// 此时如果传入JSON.stringify({ y: 123 })，req.body = { '{y:123}': '' }\nxhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded')\nxhr.send('z=' + encodeURIComponent('123'))\n\n// application/json 请求头\n// req.body = { y: 123 }\n// 如果此时 send 参数传入 y=123, 得到400错误\nxhr.setRequestHeader('Content-Type', 'application/json')\nxhr.send(JSON.stringify({\n    y: 123\n}))\n\nxhr.abort() // 会触发 abort 事件\n</code></pre>\n<h3 id=\"iframe-上传\">iframe 上传</h3>\n<p>xhr2 之前，如果要实现无刷新上传只能借助于 iframe，因为 form 表单只能同步提交。上传进度也一般依赖于轮询。</p>\n<p>iframe 上传就是将 form 表单提交到 iframe 里，在 iframe 里得到服务端返回的数据，形成一种未刷新的假象。</p>\n<pre><code class=\"language-html\">&lt;!--\ntarget 设置为 iframe 的 name\n--&gt;\n&lt;form id=&quot;form&quot; action=&quot;/upload&quot; target=&quot;frame&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;\n    &lt;input type=&quot;file&quot; id=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;br /&gt;\n    &lt;input type=&quot;submit&quot; value=&quot;上传&quot; /&gt;\n&lt;/form&gt;\n\n&lt;iframe id=&quot;uploadFrame&quot; name=&quot;frame&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;\n</code></pre>\n<pre><code class=\"language-js\">window.uploadCallback = function(data) {\n    console.log(data)\n}\n\nvar form = document.getElementById('form')\nvar frame = document.getElementById('uploadFrame')\nform.onsubmit = function(e) {\n    frame.src = form.action\n\n    frame.onload = function() {\n        var db = frame.contentDocument.body\n        var txt = db.textContent\n        parent.uploadCallback(JSON.parse(txt))\n    }\n}   \n</code></pre>\n<pre><code class=\"language-js\">// 服务器返回一段 js\n// express multer 代码\napp.post('/upload', upload.single('file'), function(req, res) {\n    res.json({\n        code: 200,\n        body: req.file\n    })\n})\n</code></pre>\n<h3 id=\"html5-文件上传\">HTML5 文件上传</h3>\n<p>XHR2 出现之后，异步上传文件变的简单的多。</p>\n<p>form 表单和上面一样，target 属性去掉。</p>\n<pre><code class=\"language-js\">form.onsubmit = function(e) {\n    e.preventDefault()\n\n    // formData 提交\n    var formData = new FormData(form)\n\n    var xhr = new XMLHttpRequest()\n    xhr.open('POST', form.action, true)\n    xhr.responseType = 'json'\n\n    xhr.onload = function() { \n        if(xhr.status == 200) {\n            console.log(xhr.response)\n        }\n    }\n\n    // 监听上传进度\n    xhr.upload.onprogress = function(e) {\n        if (e.lengthComputable) {\n            console.log(e.loaded / e.total)\n        } \n    }\n\n    xhr.send(formData)\n}\n</code></pre>\n<h2 id=\"总结\">总结</h2>\n<p>重新梳理了下 XHR 的相关知识，清晰了许多。如果需要兼容 IE8 等浏览器，如果加上跨域和 jsonp，就是一个完整的 ajax 库了。比如 <a href=\"https://github.com/genify/nej/blob/master/doc/AJAX.md\" target=\"_blank\" rel=\"noopener\">NEJ 的 Ajax 模块</a>。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>前端几乎所有的业务都离不开 Ajax，页面上 <code>$.ajax</code>、<code>axios</code> 满天飞，恐怕好久没有好好的认识 XMLHttpRequest 这个对象了。XMLHttpRequest 也已经有了好多改变，本文重新认识一下这个老朋友。</p>\n<h2 id=\"xhr-流程梳理\">XHR 流程梳理</h2>\n<ul>\n<li>首先初始初始化 XMLHttpRequest <code>var xhr = new XMLHttpRequest()</code>，在其他操作之前，即可监听 xhr 的状态变化事件。</li>\n</ul>\n<pre><code class=\"language-js\">xhr.onreadystatechange = function() { /* 状态变化事件 */ }\n</code></pre>\n<ul>\n<li>调用 open 方法，初始化请求</li>\n</ul>\n<pre><code class=\"language-js\">// 请求方法，请求地址，是否异步，用户名（可选），密码（可选）\nxhr.open(method, url, async, user, password)\n</code></pre>\n<p>在调用 open 方法之后，可以重写由服务器返回的MIME type，</p>\n<pre><code class=\"language-js\">// 以前使用 xhr 提取图片常见方法\nxhr.overrideMimeType('text/plain; charset=x-user-defined')\n</code></pre>\n<ul>\n<li>修改请求头，发送请求之前可以设置请求的头部</li>\n</ul>\n<pre><code class=\"language-js\">xhr.setRequestHeader(headerName, headerValue)\n</code></pre>\n<ul>\n<li>指定响应格式（xhr2）</li>\n</ul>\n<p>以前 xhr 的响应体，只有xhr.responseText 和 xhr.responseXML，responseXML真的很少用，几乎都是 responseText，JSON.parse 之后用， xhr2 提供了设置响应格式的方法：</p>\n<pre><code class=\"language-js\">// arraybuffer\n// blob\n// document\n// json\nxhr.responseType = 'text'(默认)\n</code></pre>\n<p>设置之后，可以从 <code>xhr.response</code> 取得响应结果，<code>xhr.response</code> 的格式就是指定的格式。</p>\n<ul>\n<li>发送请求</li>\n</ul>\n<pre><code class=\"language-js\">// 要发送的数据\n// xhr.sendAsBinary() [已经废弃](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/sendAsBinary)\n// \nxhr.send()\nxhr.send(ArrayBuffer data)\nxhr.send(Blob data)\nxhr.send(Document data)\nxhr.send(DOMString? data)\nxhr.send(FormData data)\n// 发送后，可能abort\nxhr.abort()\n</code></pre>\n<ul>\n<li>处理响应结果</li>\n</ul>\n<p>xhr1 中通过监听 onreadystatechange 事件</p>\n<pre><code class=\"language-js\">xhr.onreadystatechange = function() {\n    if(xhr.readyState == 4) {\n        if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) {\n            // 请求成功\n            handleResponse(xhr.responseText) // 或者 xhr.responseXML\n        } else {\n            // 请求失败\n        }\n    } \n}\n</code></pre>\n<p>xhr2 增加了几个新的事件，监听 xhr 的进度。</p>\n<pre><code class=\"language-js\">xhr.onprogress = function() {}\nxhr.onload = function() {}\nxhr.onerror = function() {}\nxhr.abort = function() {}\n</code></pre>\n<p>同事也可以监听上传事件</p>\n<pre><code class=\"language-js\">xhr.upload.onprogress = function() {}\n</code></pre>\n<h2 id=\"实例\">实例</h2>\n<p>从实际触发看一些实例。</p>\n<h3 id=\"简单xhr2-请求\">简单xhr2 请求</h3>\n<p>重点关注不同的请求头对请求的影响。推荐 [四种常见的 POST 提交数据方式](四种常见的 POST 提交数据方式)</p>\n<pre><code class=\"language-js\">\nvar xhr = new XMLHttpRequest()\n\nxhr.onprogress = function(e) { \n    console.log('进度：' + e.loaded / e.total)\n}\nxhr.onload = function() {\n    // 请求结束\n    if(xhr.status == 200) {\n        console.log(xhr.response)\n    } else {\n        // handle error\n    }\n}\nxhr.onerror = function(err) {\n    // 不知道何时触发\n}\nxhr.abort = function() {\n    console.log('abort')\n}\n\n// express 服务器为例\n// req.query = { x: HHH }\nxhr.open('post', '/xhr2-post?' + 'x=' + encodeURIComponent('HHH'), true) \nxhr.responseType = 'json'\n\n// post 请求默认请求头为 application/x-www-form-urlencoded\n// req.body = { z: 123 }\n// 此时如果传入JSON.stringify({ y: 123 })，req.body = { '{y:123}': '' }\nxhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded')\nxhr.send('z=' + encodeURIComponent('123'))\n\n// application/json 请求头\n// req.body = { y: 123 }\n// 如果此时 send 参数传入 y=123, 得到400错误\nxhr.setRequestHeader('Content-Type', 'application/json')\nxhr.send(JSON.stringify({\n    y: 123\n}))\n\nxhr.abort() // 会触发 abort 事件\n</code></pre>\n<h3 id=\"iframe-上传\">iframe 上传</h3>\n<p>xhr2 之前，如果要实现无刷新上传只能借助于 iframe，因为 form 表单只能同步提交。上传进度也一般依赖于轮询。</p>\n<p>iframe 上传就是将 form 表单提交到 iframe 里，在 iframe 里得到服务端返回的数据，形成一种未刷新的假象。</p>\n<pre><code class=\"language-html\">&lt;!--\ntarget 设置为 iframe 的 name\n--&gt;\n&lt;form id=&quot;form&quot; action=&quot;/upload&quot; target=&quot;frame&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;\n    &lt;input type=&quot;file&quot; id=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;br /&gt;\n    &lt;input type=&quot;submit&quot; value=&quot;上传&quot; /&gt;\n&lt;/form&gt;\n\n&lt;iframe id=&quot;uploadFrame&quot; name=&quot;frame&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;\n</code></pre>\n<pre><code class=\"language-js\">window.uploadCallback = function(data) {\n    console.log(data)\n}\n\nvar form = document.getElementById('form')\nvar frame = document.getElementById('uploadFrame')\nform.onsubmit = function(e) {\n    frame.src = form.action\n\n    frame.onload = function() {\n        var db = frame.contentDocument.body\n        var txt = db.textContent\n        parent.uploadCallback(JSON.parse(txt))\n    }\n}   \n</code></pre>\n<pre><code class=\"language-js\">// 服务器返回一段 js\n// express multer 代码\napp.post('/upload', upload.single('file'), function(req, res) {\n    res.json({\n        code: 200,\n        body: req.file\n    })\n})\n</code></pre>\n<h3 id=\"html5-文件上传\">HTML5 文件上传</h3>\n<p>XHR2 出现之后，异步上传文件变的简单的多。</p>\n<p>form 表单和上面一样，target 属性去掉。</p>\n<pre><code class=\"language-js\">form.onsubmit = function(e) {\n    e.preventDefault()\n\n    // formData 提交\n    var formData = new FormData(form)\n\n    var xhr = new XMLHttpRequest()\n    xhr.open('POST', form.action, true)\n    xhr.responseType = 'json'\n\n    xhr.onload = function() { \n        if(xhr.status == 200) {\n            console.log(xhr.response)\n        }\n    }\n\n    // 监听上传进度\n    xhr.upload.onprogress = function(e) {\n        if (e.lengthComputable) {\n            console.log(e.loaded / e.total)\n        } \n    }\n\n    xhr.send(formData)\n}\n</code></pre>\n<h2 id=\"总结\">总结</h2>\n<p>重新梳理了下 XHR 的相关知识，清晰了许多。如果需要兼容 IE8 等浏览器，如果加上跨域和 jsonp，就是一个完整的 ajax 库了。比如 <a href=\"https://github.com/genify/nej/blob/master/doc/AJAX.md\" target=\"_blank\" rel=\"noopener\">NEJ 的 Ajax 模块</a>。</p>\n"},{"layout":"post","title":"Sublime Text 备份配置","banner":"assets/img/sublime.jpeg","_content":"\n一直都是 Sublime Text 3 陪伴，备份一下配置和相关插件，特此记录。\n\n## 配置列表\n\n```\n{\n    \"caret_extra_bottom\": 3,\n    \"caret_extra_top\": 3,\n    \"caret_extra_width\": 2,\n    \"color_scheme\": \"Packages/Boxy Theme/schemes/Boxy Nova.tmTheme\",\n    \"font_face\": \"Source Code Pro\",\n    \"font_size\": 15,\n    \"highlight_line\": true,\n    \"ignored_packages\":\n    [\n        \"CSS\",\n        \"Markdown\",\n        \"Vintage\"\n    ],\n    \"line_padding_bottom\": 4,\n    \"line_padding_top\": 4,\n    \"open_files_in_new_window\": false,\n    \"overlay_scroll_bars\": \"enabled\",\n    \"theme\": \"Boxy Nova.sublime-theme\",\n    \"theme_accent_cyan\": true,\n    \"theme_bar\": true,\n    \"theme_bar_logo_atomized\": true,\n    \"theme_bar_shadow_hidden\": true,\n    \"theme_button_rounded\": true,\n    \"theme_dirty_colored_always\": true,\n    \"theme_icons_materialized\": true,\n    \"theme_scrollbar_rounded\": true,\n    \"theme_sidebar_highlight_selected_text_only\": true,\n    \"theme_sidebar_highlight_text_only\": true,\n    \"theme_sidebar_indent_top_level_disabled\": true,\n    \"theme_size_md\": true,\n    \"theme_tab_highlight_text_only\": true,\n    \"theme_tab_selected_transparent\": true,\n    \"theme_tab_selected_underlined\": true,\n    \"theme_tab_size_xxl\": true,\n    \"theme_unified\": true,\n    \"translate_tabs_to_spaces\": true,\n    \"word_wrap\": true\n}\n```\n\n\n## Package Control\n\n**首先安装 [Package Control](https://packagecontrol.io/installation)**\n\n## 主题\n\n[Boxy](https://github.com/ihodev/sublime-boxy)，正像作者所说，无比性感。\n\n图标依赖 [A File Icon](https://packagecontrol.io/packages/A%20File%20Icon)\n\n## 插件\n\n* MarkDown Editing\n* SideBarFolders\n* SideBarEnhancements\n* Emmet\n* DocBlocker\n\n## 文档\n\n* [Sublime Text 非官方中文文档](http://sublime-text.readthedocs.io/en/latest/index.html)\n* [如何优雅地使用 Sublime Text](https://segmentfault.com/a/1190000004248611)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/sublime-bf.md","raw":"\nlayout: post\ntitle: Sublime Text 备份配置\nbanner: assets/img/sublime.jpeg\ntags:\n- editor\n---\n\n一直都是 Sublime Text 3 陪伴，备份一下配置和相关插件，特此记录。\n\n## 配置列表\n\n```\n{\n    \"caret_extra_bottom\": 3,\n    \"caret_extra_top\": 3,\n    \"caret_extra_width\": 2,\n    \"color_scheme\": \"Packages/Boxy Theme/schemes/Boxy Nova.tmTheme\",\n    \"font_face\": \"Source Code Pro\",\n    \"font_size\": 15,\n    \"highlight_line\": true,\n    \"ignored_packages\":\n    [\n        \"CSS\",\n        \"Markdown\",\n        \"Vintage\"\n    ],\n    \"line_padding_bottom\": 4,\n    \"line_padding_top\": 4,\n    \"open_files_in_new_window\": false,\n    \"overlay_scroll_bars\": \"enabled\",\n    \"theme\": \"Boxy Nova.sublime-theme\",\n    \"theme_accent_cyan\": true,\n    \"theme_bar\": true,\n    \"theme_bar_logo_atomized\": true,\n    \"theme_bar_shadow_hidden\": true,\n    \"theme_button_rounded\": true,\n    \"theme_dirty_colored_always\": true,\n    \"theme_icons_materialized\": true,\n    \"theme_scrollbar_rounded\": true,\n    \"theme_sidebar_highlight_selected_text_only\": true,\n    \"theme_sidebar_highlight_text_only\": true,\n    \"theme_sidebar_indent_top_level_disabled\": true,\n    \"theme_size_md\": true,\n    \"theme_tab_highlight_text_only\": true,\n    \"theme_tab_selected_transparent\": true,\n    \"theme_tab_selected_underlined\": true,\n    \"theme_tab_size_xxl\": true,\n    \"theme_unified\": true,\n    \"translate_tabs_to_spaces\": true,\n    \"word_wrap\": true\n}\n```\n\n\n## Package Control\n\n**首先安装 [Package Control](https://packagecontrol.io/installation)**\n\n## 主题\n\n[Boxy](https://github.com/ihodev/sublime-boxy)，正像作者所说，无比性感。\n\n图标依赖 [A File Icon](https://packagecontrol.io/packages/A%20File%20Icon)\n\n## 插件\n\n* MarkDown Editing\n* SideBarFolders\n* SideBarEnhancements\n* Emmet\n* DocBlocker\n\n## 文档\n\n* [Sublime Text 非官方中文文档](http://sublime-text.readthedocs.io/en/latest/index.html)\n* [如何优雅地使用 Sublime Text](https://segmentfault.com/a/1190000004248611)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"sublime-bf","published":1,"date":"2019-01-17T13:00:11.000Z","updated":"2019-01-17T13:00:11.000Z","comments":1,"photos":[],"link":"","_id":"cjr1en2ob001jha9s6hajqwoq","content":"<p>一直都是 Sublime Text 3 陪伴，备份一下配置和相关插件，特此记录。</p>\n<h2 id=\"配置列表\">配置列表</h2>\n<pre><code>{\n    &quot;caret_extra_bottom&quot;: 3,\n    &quot;caret_extra_top&quot;: 3,\n    &quot;caret_extra_width&quot;: 2,\n    &quot;color_scheme&quot;: &quot;Packages/Boxy Theme/schemes/Boxy Nova.tmTheme&quot;,\n    &quot;font_face&quot;: &quot;Source Code Pro&quot;,\n    &quot;font_size&quot;: 15,\n    &quot;highlight_line&quot;: true,\n    &quot;ignored_packages&quot;:\n    [\n        &quot;CSS&quot;,\n        &quot;Markdown&quot;,\n        &quot;Vintage&quot;\n    ],\n    &quot;line_padding_bottom&quot;: 4,\n    &quot;line_padding_top&quot;: 4,\n    &quot;open_files_in_new_window&quot;: false,\n    &quot;overlay_scroll_bars&quot;: &quot;enabled&quot;,\n    &quot;theme&quot;: &quot;Boxy Nova.sublime-theme&quot;,\n    &quot;theme_accent_cyan&quot;: true,\n    &quot;theme_bar&quot;: true,\n    &quot;theme_bar_logo_atomized&quot;: true,\n    &quot;theme_bar_shadow_hidden&quot;: true,\n    &quot;theme_button_rounded&quot;: true,\n    &quot;theme_dirty_colored_always&quot;: true,\n    &quot;theme_icons_materialized&quot;: true,\n    &quot;theme_scrollbar_rounded&quot;: true,\n    &quot;theme_sidebar_highlight_selected_text_only&quot;: true,\n    &quot;theme_sidebar_highlight_text_only&quot;: true,\n    &quot;theme_sidebar_indent_top_level_disabled&quot;: true,\n    &quot;theme_size_md&quot;: true,\n    &quot;theme_tab_highlight_text_only&quot;: true,\n    &quot;theme_tab_selected_transparent&quot;: true,\n    &quot;theme_tab_selected_underlined&quot;: true,\n    &quot;theme_tab_size_xxl&quot;: true,\n    &quot;theme_unified&quot;: true,\n    &quot;translate_tabs_to_spaces&quot;: true,\n    &quot;word_wrap&quot;: true\n}\n</code></pre>\n<h2 id=\"package-control\">Package Control</h2>\n<p><strong>首先安装 <a href=\"https://packagecontrol.io/installation\" target=\"_blank\" rel=\"noopener\">Package Control</a></strong></p>\n<h2 id=\"主题\">主题</h2>\n<p><a href=\"https://github.com/ihodev/sublime-boxy\" target=\"_blank\" rel=\"noopener\">Boxy</a>，正像作者所说，无比性感。</p>\n<p>图标依赖 <a href=\"https://packagecontrol.io/packages/A%20File%20Icon\" target=\"_blank\" rel=\"noopener\">A File Icon</a></p>\n<h2 id=\"插件\">插件</h2>\n<ul>\n<li>MarkDown Editing</li>\n<li>SideBarFolders</li>\n<li>SideBarEnhancements</li>\n<li>Emmet</li>\n<li>DocBlocker</li>\n</ul>\n<h2 id=\"文档\">文档</h2>\n<ul>\n<li><a href=\"http://sublime-text.readthedocs.io/en/latest/index.html\" target=\"_blank\" rel=\"noopener\">Sublime Text 非官方中文文档</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000004248611\" target=\"_blank\" rel=\"noopener\">如何优雅地使用 Sublime Text</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>一直都是 Sublime Text 3 陪伴，备份一下配置和相关插件，特此记录。</p>\n<h2 id=\"配置列表\">配置列表</h2>\n<pre><code>{\n    &quot;caret_extra_bottom&quot;: 3,\n    &quot;caret_extra_top&quot;: 3,\n    &quot;caret_extra_width&quot;: 2,\n    &quot;color_scheme&quot;: &quot;Packages/Boxy Theme/schemes/Boxy Nova.tmTheme&quot;,\n    &quot;font_face&quot;: &quot;Source Code Pro&quot;,\n    &quot;font_size&quot;: 15,\n    &quot;highlight_line&quot;: true,\n    &quot;ignored_packages&quot;:\n    [\n        &quot;CSS&quot;,\n        &quot;Markdown&quot;,\n        &quot;Vintage&quot;\n    ],\n    &quot;line_padding_bottom&quot;: 4,\n    &quot;line_padding_top&quot;: 4,\n    &quot;open_files_in_new_window&quot;: false,\n    &quot;overlay_scroll_bars&quot;: &quot;enabled&quot;,\n    &quot;theme&quot;: &quot;Boxy Nova.sublime-theme&quot;,\n    &quot;theme_accent_cyan&quot;: true,\n    &quot;theme_bar&quot;: true,\n    &quot;theme_bar_logo_atomized&quot;: true,\n    &quot;theme_bar_shadow_hidden&quot;: true,\n    &quot;theme_button_rounded&quot;: true,\n    &quot;theme_dirty_colored_always&quot;: true,\n    &quot;theme_icons_materialized&quot;: true,\n    &quot;theme_scrollbar_rounded&quot;: true,\n    &quot;theme_sidebar_highlight_selected_text_only&quot;: true,\n    &quot;theme_sidebar_highlight_text_only&quot;: true,\n    &quot;theme_sidebar_indent_top_level_disabled&quot;: true,\n    &quot;theme_size_md&quot;: true,\n    &quot;theme_tab_highlight_text_only&quot;: true,\n    &quot;theme_tab_selected_transparent&quot;: true,\n    &quot;theme_tab_selected_underlined&quot;: true,\n    &quot;theme_tab_size_xxl&quot;: true,\n    &quot;theme_unified&quot;: true,\n    &quot;translate_tabs_to_spaces&quot;: true,\n    &quot;word_wrap&quot;: true\n}\n</code></pre>\n<h2 id=\"package-control\">Package Control</h2>\n<p><strong>首先安装 <a href=\"https://packagecontrol.io/installation\" target=\"_blank\" rel=\"noopener\">Package Control</a></strong></p>\n<h2 id=\"主题\">主题</h2>\n<p><a href=\"https://github.com/ihodev/sublime-boxy\" target=\"_blank\" rel=\"noopener\">Boxy</a>，正像作者所说，无比性感。</p>\n<p>图标依赖 <a href=\"https://packagecontrol.io/packages/A%20File%20Icon\" target=\"_blank\" rel=\"noopener\">A File Icon</a></p>\n<h2 id=\"插件\">插件</h2>\n<ul>\n<li>MarkDown Editing</li>\n<li>SideBarFolders</li>\n<li>SideBarEnhancements</li>\n<li>Emmet</li>\n<li>DocBlocker</li>\n</ul>\n<h2 id=\"文档\">文档</h2>\n<ul>\n<li><a href=\"http://sublime-text.readthedocs.io/en/latest/index.html\" target=\"_blank\" rel=\"noopener\">Sublime Text 非官方中文文档</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000004248611\" target=\"_blank\" rel=\"noopener\">如何优雅地使用 Sublime Text</a></li>\n</ul>\n"},{"layout":"post","title":"塞尔达传说 - 荒野之息","banner":"assets/img/zelda.jpg","_content":"\n自从入手 switch 就一直沉迷于塞尔达传说 荒野之息中无法自拔，大概已经 200+ 小时了。（这不是我好久不更新技术文章的理由~斜眼~\n\nswitch，意为切换，掌机模式和 TV 模式随时切换，我觉得这才是游戏机的本质，不限制你的行为。同样荒野之息也是一样，一个广阔的海拉尔大陆，有树林、雪地、沙漠，你可以在这里任意穿梭，甚至不用去管那些主线支线，按照自己的心情在大陆上跑来跑去，收集收集材料，做做菜，换换美美的衣服。\n\n![](/posts/assets/img/zelda/2.jpeg)\n\n当然你开始做主线支线任务，会发现一个更广大的海拉尔大陆，也会发现大陆上隐藏着的百年的秘密，你作为林克，你需要找回你一百年前的回忆，找到这些回忆后，故事愈加丰满，你会想起和 mipha 公主青梅竹马的日子，和四英杰一起抗击加农的日子，守护塞尔达的日子，直到最后整个海拉尔被毁坏，四英杰被杀害，你用尽最后的力量保护公主，公主用三角力量封印住了加农，等待百年后苏醒的你。\n\n![](/posts/assets/img/zelda/3.jpeg)\n\n美轮美奂的场景，让我们不舍得关掉这个游戏，晴朗的天气我更喜欢到处转转，欣赏这个曾经无比繁荣的海拉尔大陆，也会去佐拉族看看 mipha 公主的雕像，看雕像下面小孩字跑来跑去打打闹闹，林克和 mipha 小时候是不是也是一样呢？有时候也远远看着哥布林的各种小动作，他们有自己的语言自己的庆祝，也不失为一种乐趣。\n\n![](/posts/assets/img/zelda/1.jpeg)\n\n得知塞尔达传说获得了 TGA 年度游戏大奖，一点都不惊讶，这是他应得的。\n\n最近又剁手买了 DLC，英杰之诗丰满了四英杰的性格，林克和 mipha 的关系也越来越清晰。最后以四英杰、林克、塞尔达搞笑的合影作为结尾，林克回到家，把照片挂载墙上，凝视许久，应该是想起了一百年前更多的事情。\n\n![](/posts/assets/img/zelda/4.jpg)\n\n\n\n","source":"_posts/the-legend-of-zelda-breath-of-the-wild.md","raw":"\nlayout: post\ntitle: 塞尔达传说 - 荒野之息\nbanner: assets/img/zelda.jpg\ntags: game\n---\n\n自从入手 switch 就一直沉迷于塞尔达传说 荒野之息中无法自拔，大概已经 200+ 小时了。（这不是我好久不更新技术文章的理由~斜眼~\n\nswitch，意为切换，掌机模式和 TV 模式随时切换，我觉得这才是游戏机的本质，不限制你的行为。同样荒野之息也是一样，一个广阔的海拉尔大陆，有树林、雪地、沙漠，你可以在这里任意穿梭，甚至不用去管那些主线支线，按照自己的心情在大陆上跑来跑去，收集收集材料，做做菜，换换美美的衣服。\n\n![](/posts/assets/img/zelda/2.jpeg)\n\n当然你开始做主线支线任务，会发现一个更广大的海拉尔大陆，也会发现大陆上隐藏着的百年的秘密，你作为林克，你需要找回你一百年前的回忆，找到这些回忆后，故事愈加丰满，你会想起和 mipha 公主青梅竹马的日子，和四英杰一起抗击加农的日子，守护塞尔达的日子，直到最后整个海拉尔被毁坏，四英杰被杀害，你用尽最后的力量保护公主，公主用三角力量封印住了加农，等待百年后苏醒的你。\n\n![](/posts/assets/img/zelda/3.jpeg)\n\n美轮美奂的场景，让我们不舍得关掉这个游戏，晴朗的天气我更喜欢到处转转，欣赏这个曾经无比繁荣的海拉尔大陆，也会去佐拉族看看 mipha 公主的雕像，看雕像下面小孩字跑来跑去打打闹闹，林克和 mipha 小时候是不是也是一样呢？有时候也远远看着哥布林的各种小动作，他们有自己的语言自己的庆祝，也不失为一种乐趣。\n\n![](/posts/assets/img/zelda/1.jpeg)\n\n得知塞尔达传说获得了 TGA 年度游戏大奖，一点都不惊讶，这是他应得的。\n\n最近又剁手买了 DLC，英杰之诗丰满了四英杰的性格，林克和 mipha 的关系也越来越清晰。最后以四英杰、林克、塞尔达搞笑的合影作为结尾，林克回到家，把照片挂载墙上，凝视许久，应该是想起了一百年前更多的事情。\n\n![](/posts/assets/img/zelda/4.jpg)\n\n\n\n","slug":"the-legend-of-zelda-breath-of-the-wild","published":1,"date":"2019-01-17T13:00:11.000Z","updated":"2019-01-17T13:00:11.000Z","comments":1,"photos":[],"link":"","_id":"cjr1en2oc001lha9sem2bzbqx","content":"<p>自从入手 switch 就一直沉迷于塞尔达传说 荒野之息中无法自拔，大概已经 200+ 小时了。（这不是我好久不更新技术文章的理由<sub>斜眼</sub></p>\n<p>switch，意为切换，掌机模式和 TV 模式随时切换，我觉得这才是游戏机的本质，不限制你的行为。同样荒野之息也是一样，一个广阔的海拉尔大陆，有树林、雪地、沙漠，你可以在这里任意穿梭，甚至不用去管那些主线支线，按照自己的心情在大陆上跑来跑去，收集收集材料，做做菜，换换美美的衣服。</p>\n<p><img src=\"/posts/assets/img/zelda/2.jpeg\" alt=\"\"></p>\n<p>当然你开始做主线支线任务，会发现一个更广大的海拉尔大陆，也会发现大陆上隐藏着的百年的秘密，你作为林克，你需要找回你一百年前的回忆，找到这些回忆后，故事愈加丰满，你会想起和 mipha 公主青梅竹马的日子，和四英杰一起抗击加农的日子，守护塞尔达的日子，直到最后整个海拉尔被毁坏，四英杰被杀害，你用尽最后的力量保护公主，公主用三角力量封印住了加农，等待百年后苏醒的你。</p>\n<p><img src=\"/posts/assets/img/zelda/3.jpeg\" alt=\"\"></p>\n<p>美轮美奂的场景，让我们不舍得关掉这个游戏，晴朗的天气我更喜欢到处转转，欣赏这个曾经无比繁荣的海拉尔大陆，也会去佐拉族看看 mipha 公主的雕像，看雕像下面小孩字跑来跑去打打闹闹，林克和 mipha 小时候是不是也是一样呢？有时候也远远看着哥布林的各种小动作，他们有自己的语言自己的庆祝，也不失为一种乐趣。</p>\n<p><img src=\"/posts/assets/img/zelda/1.jpeg\" alt=\"\"></p>\n<p>得知塞尔达传说获得了 TGA 年度游戏大奖，一点都不惊讶，这是他应得的。</p>\n<p>最近又剁手买了 DLC，英杰之诗丰满了四英杰的性格，林克和 mipha 的关系也越来越清晰。最后以四英杰、林克、塞尔达搞笑的合影作为结尾，林克回到家，把照片挂载墙上，凝视许久，应该是想起了一百年前更多的事情。</p>\n<p><img src=\"/posts/assets/img/zelda/4.jpg\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>自从入手 switch 就一直沉迷于塞尔达传说 荒野之息中无法自拔，大概已经 200+ 小时了。（这不是我好久不更新技术文章的理由<sub>斜眼</sub></p>\n<p>switch，意为切换，掌机模式和 TV 模式随时切换，我觉得这才是游戏机的本质，不限制你的行为。同样荒野之息也是一样，一个广阔的海拉尔大陆，有树林、雪地、沙漠，你可以在这里任意穿梭，甚至不用去管那些主线支线，按照自己的心情在大陆上跑来跑去，收集收集材料，做做菜，换换美美的衣服。</p>\n<p><img src=\"/posts/assets/img/zelda/2.jpeg\" alt=\"\"></p>\n<p>当然你开始做主线支线任务，会发现一个更广大的海拉尔大陆，也会发现大陆上隐藏着的百年的秘密，你作为林克，你需要找回你一百年前的回忆，找到这些回忆后，故事愈加丰满，你会想起和 mipha 公主青梅竹马的日子，和四英杰一起抗击加农的日子，守护塞尔达的日子，直到最后整个海拉尔被毁坏，四英杰被杀害，你用尽最后的力量保护公主，公主用三角力量封印住了加农，等待百年后苏醒的你。</p>\n<p><img src=\"/posts/assets/img/zelda/3.jpeg\" alt=\"\"></p>\n<p>美轮美奂的场景，让我们不舍得关掉这个游戏，晴朗的天气我更喜欢到处转转，欣赏这个曾经无比繁荣的海拉尔大陆，也会去佐拉族看看 mipha 公主的雕像，看雕像下面小孩字跑来跑去打打闹闹，林克和 mipha 小时候是不是也是一样呢？有时候也远远看着哥布林的各种小动作，他们有自己的语言自己的庆祝，也不失为一种乐趣。</p>\n<p><img src=\"/posts/assets/img/zelda/1.jpeg\" alt=\"\"></p>\n<p>得知塞尔达传说获得了 TGA 年度游戏大奖，一点都不惊讶，这是他应得的。</p>\n<p>最近又剁手买了 DLC，英杰之诗丰满了四英杰的性格，林克和 mipha 的关系也越来越清晰。最后以四英杰、林克、塞尔达搞笑的合影作为结尾，林克回到家，把照片挂载墙上，凝视许久，应该是想起了一百年前更多的事情。</p>\n<p><img src=\"/posts/assets/img/zelda/4.jpg\" alt=\"\"></p>\n"},{"layout":"post","title":"前端长列表渲染优化","banner":"assets/img/performance.jpg","_content":"\n对于长列表，一般的应用可以通过分页解决。然而现在很多的应用列表部分可能是滚动加载的，随着滚动，列表项越来越多，影响性能和体验，尤其是移动设备上；另一种是IM应用，像会话列表、好友列表、群成员列表通常会一次性加载。在这些情况下，对于长列表的优化就显得很有必要。\n\n[Clusterize.js](http://clusterize.js.org/)就是这样一个库，短小精悍。它会将列表划分成一个个的cluster，随着滚动只显示当前可见的cluster，并在列表的顶部和底部填充额外的高度，展示列表的真实高度。\n\n> The main idea is not to pollute DOM with all used tags. Instead of that - it splits the list to clusters, then shows elements for current scroll position and adds extra rows to top and bottom of the list to emulate full height of table so that browser shows scrollbar as for full list.\n\n不过Clusterize.js是基于DOM的，随着MVVM框架的流行，大家更多的是在操作数据，所以我基于Clusterize.js做了Clustery.js。\n\n## 如何使用 Clustery.js\n\n首先了解一下[Clusterize.js](http://clusterize.js.org/)。\n\nClusterize.js有超多的配置项、公共方法和回调函数，在操作 DOM 的时候比较有用。Clustery.js 做了大量的简化，不必再引入 Clusterize.js 自带的 css，增加了 `item_height` 的配置，显式的声明每一项的高度；`rows` 不再是 DOM 元素的数组，而是用于渲染的数据。下面是所有的配置项、回调和公共方法：\n\n```js\nthis.clustery = new Clustery({\n    scrollElem: scrollElem,\n    contentElem: contentElem,\n    rows: rows,\n    item_height: itemHeight,\n    rows_in_block: 20,\n    blocks_in_cluster: 4,\n    callbacks: {\n        shouldUpdate: function(data) {\n            _this.setRenderData(data)\n        }\n    }\n});\n\n// if you want to destroy\nthis.clustery.destroy();\n\n// if you modify itemHeight manually\nthis.clustery.refresh(item_height);\n\n// if you update data\nthis.clustery.update(newRows);\n```\n\n`callbacks`暂时只有一个回调，当需要渲染的数据改变时触发 `shouldUpdate` 方法，参数 `_data` 可能是一个对象也可能是一个数字(仅仅是 `bottom_offset` 改变)：\n\n```js\n{\n    start: 0,   // 渲染列表从start到end, 此时需要渲染arr.slice(start, end)   \n    end: 80,\n    top_offset: 1245,   // 列表顶部填充高度\n    bottom_offset: 3349 // 列表底部填充高度\n}\n```\n\n可以去 Github 中查看 [DEMO](https://github.com/zjzhome/Clustery.js)\n\n如果你对实现原理感兴趣，请继续往下看 :wink:\n\n## 实现原理\n\n为了实现随滚动只加载可见区域，Clusterize.js 引入了几个概念：\n\n```js\n{\n    rows_in_block: 0,     // 每一个block包含的rows\n    block_height: 0,      // 每一个block的高度 item_height * rows_in_block\n    blocks_in_cluster: 4, // 每个cluster包含的blocks的个数\n    rows_in_cluster: 0,   // 每一个cluster包含的rows blocks_in_cluster * rows_in_block\n    cluster_height: 0,    // 每一个cluster的高度 block_height * blocks_in_cluster\n}\n```\n\n整个列表被划分为一个个的 `cluster`，每个 `cluster` 包含多个 `block`，每个 `block`包含多个 `rows`，也就是渲染的最小单位 - 每行数据。\n\n首先要确定上述几个配置项的值。每一项的高度 `item_height` 是由用户传入的，然后需要确定的是 `row_in_block`，因为其他几个值得计算都是依赖于它的：\n\n```js\n// 我们将整个可见的区域作为一个 block\n// 除以 item_height 就得到每个 block 内包含的 rows\n\nif(!opts.rows_in_block) {\n  opts.rows_in_block = Math.ceil(this.scroll_elem.offsetHeight / opts.item_height);\n}\n```\n\n其他配置项也能轻松得到了：\n\n```js\nopts.block_height = opts.item_height * opts.rows_in_block;\nopts.rows_in_cluster = opts.blocks_in_cluster * opts.rows_in_block;\nopts.cluster_height = opts.blocks_in_cluster * opts.block_height;\n```\n\n然后就开始处理用户滚动的事件了，随着用户滚动，我们需要确定需要渲染哪个 `cluster`:\n\n```js\n// get current cluster number\n// 一个 cluster 包含多个 block, 整理减掉一个 block 的高度可以看作是缓冲\n// 在用户没有滚动到这个 cluster 的底部的时候就已经加载下个 cluster, 防止出现短暂的空白.\ngetClusterNum: function () {\n  this.options.scroll_top = this.scroll_elem.scrollTop;\n  return Math.floor(this.options.scroll_top / (this.options.cluster_height - this.options.block_height)) || 0;\n}\n```\n\n然后我们需要生成新的 cluster 进行渲染：\n\n```js\n// 其实是 getClusterNum 的一次反向运算，计算出数据从第几项开始渲染\nvar items_start = Math.max((opts.rows_in_cluster - opts.rows_in_block) * cluster_num, 0),\n  items_end = items_start + opts.rows_in_cluster,\n  top_offset = Math.max(items_start * opts.item_height, 0),\n  bottom_offset = Math.max((rows_len - items_end) * opts.item_height, 0);\n```\n\n其实我们可以看出来，每个 cluster 并不是独立的，而是重叠的，所以在快速滚动的时候，不会有空白的情况出现。\n\n最后库额外做了其他事情，把之前的数据缓存起来，滚动的后的计算结果和缓存内的比较，如果有变化，就调用用户传入的回调函数通知用户渲染数据。\n\n\n\n\n","source":"_posts/use-clustery-render-large-list.md","raw":"\nlayout: post\ntitle: 前端长列表渲染优化\nbanner: assets/img/performance.jpg\ntags: \n- JavaScript\n- performance\n---\n\n对于长列表，一般的应用可以通过分页解决。然而现在很多的应用列表部分可能是滚动加载的，随着滚动，列表项越来越多，影响性能和体验，尤其是移动设备上；另一种是IM应用，像会话列表、好友列表、群成员列表通常会一次性加载。在这些情况下，对于长列表的优化就显得很有必要。\n\n[Clusterize.js](http://clusterize.js.org/)就是这样一个库，短小精悍。它会将列表划分成一个个的cluster，随着滚动只显示当前可见的cluster，并在列表的顶部和底部填充额外的高度，展示列表的真实高度。\n\n> The main idea is not to pollute DOM with all used tags. Instead of that - it splits the list to clusters, then shows elements for current scroll position and adds extra rows to top and bottom of the list to emulate full height of table so that browser shows scrollbar as for full list.\n\n不过Clusterize.js是基于DOM的，随着MVVM框架的流行，大家更多的是在操作数据，所以我基于Clusterize.js做了Clustery.js。\n\n## 如何使用 Clustery.js\n\n首先了解一下[Clusterize.js](http://clusterize.js.org/)。\n\nClusterize.js有超多的配置项、公共方法和回调函数，在操作 DOM 的时候比较有用。Clustery.js 做了大量的简化，不必再引入 Clusterize.js 自带的 css，增加了 `item_height` 的配置，显式的声明每一项的高度；`rows` 不再是 DOM 元素的数组，而是用于渲染的数据。下面是所有的配置项、回调和公共方法：\n\n```js\nthis.clustery = new Clustery({\n    scrollElem: scrollElem,\n    contentElem: contentElem,\n    rows: rows,\n    item_height: itemHeight,\n    rows_in_block: 20,\n    blocks_in_cluster: 4,\n    callbacks: {\n        shouldUpdate: function(data) {\n            _this.setRenderData(data)\n        }\n    }\n});\n\n// if you want to destroy\nthis.clustery.destroy();\n\n// if you modify itemHeight manually\nthis.clustery.refresh(item_height);\n\n// if you update data\nthis.clustery.update(newRows);\n```\n\n`callbacks`暂时只有一个回调，当需要渲染的数据改变时触发 `shouldUpdate` 方法，参数 `_data` 可能是一个对象也可能是一个数字(仅仅是 `bottom_offset` 改变)：\n\n```js\n{\n    start: 0,   // 渲染列表从start到end, 此时需要渲染arr.slice(start, end)   \n    end: 80,\n    top_offset: 1245,   // 列表顶部填充高度\n    bottom_offset: 3349 // 列表底部填充高度\n}\n```\n\n可以去 Github 中查看 [DEMO](https://github.com/zjzhome/Clustery.js)\n\n如果你对实现原理感兴趣，请继续往下看 :wink:\n\n## 实现原理\n\n为了实现随滚动只加载可见区域，Clusterize.js 引入了几个概念：\n\n```js\n{\n    rows_in_block: 0,     // 每一个block包含的rows\n    block_height: 0,      // 每一个block的高度 item_height * rows_in_block\n    blocks_in_cluster: 4, // 每个cluster包含的blocks的个数\n    rows_in_cluster: 0,   // 每一个cluster包含的rows blocks_in_cluster * rows_in_block\n    cluster_height: 0,    // 每一个cluster的高度 block_height * blocks_in_cluster\n}\n```\n\n整个列表被划分为一个个的 `cluster`，每个 `cluster` 包含多个 `block`，每个 `block`包含多个 `rows`，也就是渲染的最小单位 - 每行数据。\n\n首先要确定上述几个配置项的值。每一项的高度 `item_height` 是由用户传入的，然后需要确定的是 `row_in_block`，因为其他几个值得计算都是依赖于它的：\n\n```js\n// 我们将整个可见的区域作为一个 block\n// 除以 item_height 就得到每个 block 内包含的 rows\n\nif(!opts.rows_in_block) {\n  opts.rows_in_block = Math.ceil(this.scroll_elem.offsetHeight / opts.item_height);\n}\n```\n\n其他配置项也能轻松得到了：\n\n```js\nopts.block_height = opts.item_height * opts.rows_in_block;\nopts.rows_in_cluster = opts.blocks_in_cluster * opts.rows_in_block;\nopts.cluster_height = opts.blocks_in_cluster * opts.block_height;\n```\n\n然后就开始处理用户滚动的事件了，随着用户滚动，我们需要确定需要渲染哪个 `cluster`:\n\n```js\n// get current cluster number\n// 一个 cluster 包含多个 block, 整理减掉一个 block 的高度可以看作是缓冲\n// 在用户没有滚动到这个 cluster 的底部的时候就已经加载下个 cluster, 防止出现短暂的空白.\ngetClusterNum: function () {\n  this.options.scroll_top = this.scroll_elem.scrollTop;\n  return Math.floor(this.options.scroll_top / (this.options.cluster_height - this.options.block_height)) || 0;\n}\n```\n\n然后我们需要生成新的 cluster 进行渲染：\n\n```js\n// 其实是 getClusterNum 的一次反向运算，计算出数据从第几项开始渲染\nvar items_start = Math.max((opts.rows_in_cluster - opts.rows_in_block) * cluster_num, 0),\n  items_end = items_start + opts.rows_in_cluster,\n  top_offset = Math.max(items_start * opts.item_height, 0),\n  bottom_offset = Math.max((rows_len - items_end) * opts.item_height, 0);\n```\n\n其实我们可以看出来，每个 cluster 并不是独立的，而是重叠的，所以在快速滚动的时候，不会有空白的情况出现。\n\n最后库额外做了其他事情，把之前的数据缓存起来，滚动的后的计算结果和缓存内的比较，如果有变化，就调用用户传入的回调函数通知用户渲染数据。\n\n\n\n\n","slug":"use-clustery-render-large-list","published":1,"date":"2019-01-17T13:00:11.000Z","updated":"2019-01-17T13:00:11.000Z","comments":1,"photos":[],"link":"","_id":"cjr1en2od001mha9sg0hzm7e3","content":"<p>对于长列表，一般的应用可以通过分页解决。然而现在很多的应用列表部分可能是滚动加载的，随着滚动，列表项越来越多，影响性能和体验，尤其是移动设备上；另一种是IM应用，像会话列表、好友列表、群成员列表通常会一次性加载。在这些情况下，对于长列表的优化就显得很有必要。</p>\n<p><a href=\"http://clusterize.js.org/\" target=\"_blank\" rel=\"noopener\">Clusterize.js</a>就是这样一个库，短小精悍。它会将列表划分成一个个的cluster，随着滚动只显示当前可见的cluster，并在列表的顶部和底部填充额外的高度，展示列表的真实高度。</p>\n<blockquote>\n<p>The main idea is not to pollute DOM with all used tags. Instead of that - it splits the list to clusters, then shows elements for current scroll position and adds extra rows to top and bottom of the list to emulate full height of table so that browser shows scrollbar as for full list.</p>\n</blockquote>\n<p>不过Clusterize.js是基于DOM的，随着MVVM框架的流行，大家更多的是在操作数据，所以我基于Clusterize.js做了Clustery.js。</p>\n<h2 id=\"如何使用-clustery-js\">如何使用 Clustery.js</h2>\n<p>首先了解一下<a href=\"http://clusterize.js.org/\" target=\"_blank\" rel=\"noopener\">Clusterize.js</a>。</p>\n<p>Clusterize.js有超多的配置项、公共方法和回调函数，在操作 DOM 的时候比较有用。Clustery.js 做了大量的简化，不必再引入 Clusterize.js 自带的 css，增加了 <code>item_height</code> 的配置，显式的声明每一项的高度；<code>rows</code> 不再是 DOM 元素的数组，而是用于渲染的数据。下面是所有的配置项、回调和公共方法：</p>\n<pre><code class=\"language-js\">this.clustery = new Clustery({\n    scrollElem: scrollElem,\n    contentElem: contentElem,\n    rows: rows,\n    item_height: itemHeight,\n    rows_in_block: 20,\n    blocks_in_cluster: 4,\n    callbacks: {\n        shouldUpdate: function(data) {\n            _this.setRenderData(data)\n        }\n    }\n});\n\n// if you want to destroy\nthis.clustery.destroy();\n\n// if you modify itemHeight manually\nthis.clustery.refresh(item_height);\n\n// if you update data\nthis.clustery.update(newRows);\n</code></pre>\n<p><code>callbacks</code>暂时只有一个回调，当需要渲染的数据改变时触发 <code>shouldUpdate</code> 方法，参数 <code>_data</code> 可能是一个对象也可能是一个数字(仅仅是 <code>bottom_offset</code> 改变)：</p>\n<pre><code class=\"language-js\">{\n    start: 0,   // 渲染列表从start到end, 此时需要渲染arr.slice(start, end)   \n    end: 80,\n    top_offset: 1245,   // 列表顶部填充高度\n    bottom_offset: 3349 // 列表底部填充高度\n}\n</code></pre>\n<p>可以去 Github 中查看 <a href=\"https://github.com/zjzhome/Clustery.js\" target=\"_blank\" rel=\"noopener\">DEMO</a></p>\n<p>如果你对实现原理感兴趣，请继续往下看 😉</p>\n<h2 id=\"实现原理\">实现原理</h2>\n<p>为了实现随滚动只加载可见区域，Clusterize.js 引入了几个概念：</p>\n<pre><code class=\"language-js\">{\n    rows_in_block: 0,     // 每一个block包含的rows\n    block_height: 0,      // 每一个block的高度 item_height * rows_in_block\n    blocks_in_cluster: 4, // 每个cluster包含的blocks的个数\n    rows_in_cluster: 0,   // 每一个cluster包含的rows blocks_in_cluster * rows_in_block\n    cluster_height: 0,    // 每一个cluster的高度 block_height * blocks_in_cluster\n}\n</code></pre>\n<p>整个列表被划分为一个个的 <code>cluster</code>，每个 <code>cluster</code> 包含多个 <code>block</code>，每个 <code>block</code>包含多个 <code>rows</code>，也就是渲染的最小单位 - 每行数据。</p>\n<p>首先要确定上述几个配置项的值。每一项的高度 <code>item_height</code> 是由用户传入的，然后需要确定的是 <code>row_in_block</code>，因为其他几个值得计算都是依赖于它的：</p>\n<pre><code class=\"language-js\">// 我们将整个可见的区域作为一个 block\n// 除以 item_height 就得到每个 block 内包含的 rows\n\nif(!opts.rows_in_block) {\n  opts.rows_in_block = Math.ceil(this.scroll_elem.offsetHeight / opts.item_height);\n}\n</code></pre>\n<p>其他配置项也能轻松得到了：</p>\n<pre><code class=\"language-js\">opts.block_height = opts.item_height * opts.rows_in_block;\nopts.rows_in_cluster = opts.blocks_in_cluster * opts.rows_in_block;\nopts.cluster_height = opts.blocks_in_cluster * opts.block_height;\n</code></pre>\n<p>然后就开始处理用户滚动的事件了，随着用户滚动，我们需要确定需要渲染哪个 <code>cluster</code>:</p>\n<pre><code class=\"language-js\">// get current cluster number\n// 一个 cluster 包含多个 block, 整理减掉一个 block 的高度可以看作是缓冲\n// 在用户没有滚动到这个 cluster 的底部的时候就已经加载下个 cluster, 防止出现短暂的空白.\ngetClusterNum: function () {\n  this.options.scroll_top = this.scroll_elem.scrollTop;\n  return Math.floor(this.options.scroll_top / (this.options.cluster_height - this.options.block_height)) || 0;\n}\n</code></pre>\n<p>然后我们需要生成新的 cluster 进行渲染：</p>\n<pre><code class=\"language-js\">// 其实是 getClusterNum 的一次反向运算，计算出数据从第几项开始渲染\nvar items_start = Math.max((opts.rows_in_cluster - opts.rows_in_block) * cluster_num, 0),\n  items_end = items_start + opts.rows_in_cluster,\n  top_offset = Math.max(items_start * opts.item_height, 0),\n  bottom_offset = Math.max((rows_len - items_end) * opts.item_height, 0);\n</code></pre>\n<p>其实我们可以看出来，每个 cluster 并不是独立的，而是重叠的，所以在快速滚动的时候，不会有空白的情况出现。</p>\n<p>最后库额外做了其他事情，把之前的数据缓存起来，滚动的后的计算结果和缓存内的比较，如果有变化，就调用用户传入的回调函数通知用户渲染数据。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>对于长列表，一般的应用可以通过分页解决。然而现在很多的应用列表部分可能是滚动加载的，随着滚动，列表项越来越多，影响性能和体验，尤其是移动设备上；另一种是IM应用，像会话列表、好友列表、群成员列表通常会一次性加载。在这些情况下，对于长列表的优化就显得很有必要。</p>\n<p><a href=\"http://clusterize.js.org/\" target=\"_blank\" rel=\"noopener\">Clusterize.js</a>就是这样一个库，短小精悍。它会将列表划分成一个个的cluster，随着滚动只显示当前可见的cluster，并在列表的顶部和底部填充额外的高度，展示列表的真实高度。</p>\n<blockquote>\n<p>The main idea is not to pollute DOM with all used tags. Instead of that - it splits the list to clusters, then shows elements for current scroll position and adds extra rows to top and bottom of the list to emulate full height of table so that browser shows scrollbar as for full list.</p>\n</blockquote>\n<p>不过Clusterize.js是基于DOM的，随着MVVM框架的流行，大家更多的是在操作数据，所以我基于Clusterize.js做了Clustery.js。</p>\n<h2 id=\"如何使用-clustery-js\">如何使用 Clustery.js</h2>\n<p>首先了解一下<a href=\"http://clusterize.js.org/\" target=\"_blank\" rel=\"noopener\">Clusterize.js</a>。</p>\n<p>Clusterize.js有超多的配置项、公共方法和回调函数，在操作 DOM 的时候比较有用。Clustery.js 做了大量的简化，不必再引入 Clusterize.js 自带的 css，增加了 <code>item_height</code> 的配置，显式的声明每一项的高度；<code>rows</code> 不再是 DOM 元素的数组，而是用于渲染的数据。下面是所有的配置项、回调和公共方法：</p>\n<pre><code class=\"language-js\">this.clustery = new Clustery({\n    scrollElem: scrollElem,\n    contentElem: contentElem,\n    rows: rows,\n    item_height: itemHeight,\n    rows_in_block: 20,\n    blocks_in_cluster: 4,\n    callbacks: {\n        shouldUpdate: function(data) {\n            _this.setRenderData(data)\n        }\n    }\n});\n\n// if you want to destroy\nthis.clustery.destroy();\n\n// if you modify itemHeight manually\nthis.clustery.refresh(item_height);\n\n// if you update data\nthis.clustery.update(newRows);\n</code></pre>\n<p><code>callbacks</code>暂时只有一个回调，当需要渲染的数据改变时触发 <code>shouldUpdate</code> 方法，参数 <code>_data</code> 可能是一个对象也可能是一个数字(仅仅是 <code>bottom_offset</code> 改变)：</p>\n<pre><code class=\"language-js\">{\n    start: 0,   // 渲染列表从start到end, 此时需要渲染arr.slice(start, end)   \n    end: 80,\n    top_offset: 1245,   // 列表顶部填充高度\n    bottom_offset: 3349 // 列表底部填充高度\n}\n</code></pre>\n<p>可以去 Github 中查看 <a href=\"https://github.com/zjzhome/Clustery.js\" target=\"_blank\" rel=\"noopener\">DEMO</a></p>\n<p>如果你对实现原理感兴趣，请继续往下看 😉</p>\n<h2 id=\"实现原理\">实现原理</h2>\n<p>为了实现随滚动只加载可见区域，Clusterize.js 引入了几个概念：</p>\n<pre><code class=\"language-js\">{\n    rows_in_block: 0,     // 每一个block包含的rows\n    block_height: 0,      // 每一个block的高度 item_height * rows_in_block\n    blocks_in_cluster: 4, // 每个cluster包含的blocks的个数\n    rows_in_cluster: 0,   // 每一个cluster包含的rows blocks_in_cluster * rows_in_block\n    cluster_height: 0,    // 每一个cluster的高度 block_height * blocks_in_cluster\n}\n</code></pre>\n<p>整个列表被划分为一个个的 <code>cluster</code>，每个 <code>cluster</code> 包含多个 <code>block</code>，每个 <code>block</code>包含多个 <code>rows</code>，也就是渲染的最小单位 - 每行数据。</p>\n<p>首先要确定上述几个配置项的值。每一项的高度 <code>item_height</code> 是由用户传入的，然后需要确定的是 <code>row_in_block</code>，因为其他几个值得计算都是依赖于它的：</p>\n<pre><code class=\"language-js\">// 我们将整个可见的区域作为一个 block\n// 除以 item_height 就得到每个 block 内包含的 rows\n\nif(!opts.rows_in_block) {\n  opts.rows_in_block = Math.ceil(this.scroll_elem.offsetHeight / opts.item_height);\n}\n</code></pre>\n<p>其他配置项也能轻松得到了：</p>\n<pre><code class=\"language-js\">opts.block_height = opts.item_height * opts.rows_in_block;\nopts.rows_in_cluster = opts.blocks_in_cluster * opts.rows_in_block;\nopts.cluster_height = opts.blocks_in_cluster * opts.block_height;\n</code></pre>\n<p>然后就开始处理用户滚动的事件了，随着用户滚动，我们需要确定需要渲染哪个 <code>cluster</code>:</p>\n<pre><code class=\"language-js\">// get current cluster number\n// 一个 cluster 包含多个 block, 整理减掉一个 block 的高度可以看作是缓冲\n// 在用户没有滚动到这个 cluster 的底部的时候就已经加载下个 cluster, 防止出现短暂的空白.\ngetClusterNum: function () {\n  this.options.scroll_top = this.scroll_elem.scrollTop;\n  return Math.floor(this.options.scroll_top / (this.options.cluster_height - this.options.block_height)) || 0;\n}\n</code></pre>\n<p>然后我们需要生成新的 cluster 进行渲染：</p>\n<pre><code class=\"language-js\">// 其实是 getClusterNum 的一次反向运算，计算出数据从第几项开始渲染\nvar items_start = Math.max((opts.rows_in_cluster - opts.rows_in_block) * cluster_num, 0),\n  items_end = items_start + opts.rows_in_cluster,\n  top_offset = Math.max(items_start * opts.item_height, 0),\n  bottom_offset = Math.max((rows_len - items_end) * opts.item_height, 0);\n</code></pre>\n<p>其实我们可以看出来，每个 cluster 并不是独立的，而是重叠的，所以在快速滚动的时候，不会有空白的情况出现。</p>\n<p>最后库额外做了其他事情，把之前的数据缓存起来，滚动的后的计算结果和缓存内的比较，如果有变化，就调用用户传入的回调函数通知用户渲染数据。</p>\n"},{"layout":"post","title":"详解 Webpack（上）","banner":"assets/img/webpack.jpg","label":"译","_content":"\nJavaScript 模块打包工具已经出现有一段时间了。RequireJS 在2009年完成了第一次提交，然后 Browserify 随之出现，从那时候起相继出现了各种模块打包工具。在这些里面，*webpack*脱颖而出。如果你还不熟悉它，我希望这篇文章可以帮你开始使用这个强大的工具。\n\n## 什么是模块打包工具\n\n在大多数语言中（包括 ECMAScript 2015+，JavaScript 的最新标准，但还没有被浏览器广泛支持），你可以将代码分割成多个文件，然后将这些文件导入到你的应用中，来使用他们所包含的功能。浏览器并没有内建这样的功能，所以模块打包工具如果要实现这些功能，有以下几种方式：异步加载模块，在加载完成后执行；或者是将所有需要的文件合并成一个 JavaScript 文件，在 HTML 里通过 `<script>` 标签加载。\n\n不使用模块管理和打包工具，你也可以手动合并你的文件，然后使用数不清的 `<script>` 标签引入，不过这样做缺点也很明显：\n\n* 你需要保证需要加载的文件的顺序，包括文件的依赖关系以及你要保证不要加载那些你不需要的文件。\n* 越多的 `<script>` 的标签意味着要加载你的代码需要更多的服务器请求，影响性能。\n* 很明显，这需要大量的手动操作，而不是让计算机来做处理。\n\n大多数的模块打包工具可以很简单的和 npm 或者 Bower 集成，这样你就可以为你的应用添加第三方依赖。你只需要安装并且用一行代码导入到你的应用中。然后运行打包工具，你的应用代码就和第三方代码合并到一起；或者你配置正确，你可以把你所有的依赖代码打包到另外一个文件里，这样当你更新了应用的代码，用户更新应用代码的缓存时候，就不必重新下载这些依赖库的代码。\n\n## 为什么选择 Webpack\n\n现在你已经基本了解 webpack 的作用了，但为什么你要选择 webpack，有这么几个原因：\n\n* 其中一个优势是相对来说它比较新，所以它能够避免之前的工具们存在的一些缺陷和问题。\n* 上手简单。如果你只是想要把所有 JavaScript 文件打包成一个文件，而不做其他事情，你甚至都不需要配置文件。\n* 它的插件系统可以做更多的事情，使得它更加强大，所以，或许构建工具，一个 webpack 足够了。\n\n我见过一些其他和 webpack 功能类似的打包和构建工具，但 webpack 更胜一筹：当你遇到困难时你可以去庞大的社区寻找帮助。Browserify 的社区也挺大，但是它缺少一些 webpack 具有的潜在的必需的特性。我把所有的赞誉都给了 webpack，你们一定等我开始 show my code 了，开始吧 ~\n\n## 安装 Webpack\n\n在使用 webpack 之前，我们首先需要安装它。我假设你已经安装了 Nodejs 和 npm，如果你还没安装他们，查看 [Nodejs 官网](https://nodejs.org/)。\n\n有两种方式来安装 webpack（其实其他命令行程序也是一样）：全局安装和局部安装。如果你选择全局安装，你可以在任意目录下使用，但是它不会作为你局部依赖存在，并且你不能在不同的项目之间切换 webpack 的版本（一些项目可能需要更新一点的版本，你可能不得不等一等再升级）。所以对于命令行程序我更倾向于局部安装，然后使用相对路径或者 [npm scripts](https://docs.npmjs.com/misc/scripts) 来运行程序。如果你没有局部安装过命令行程序，你可以读一下我写的一篇文章，关于摆脱[全局安装 npm 包](https://www.joezimjs.com/javascript/no-more-global-npm-packages/)。\n\n接下来我们会使用 npm scripts 来进行我们的例子，所以我们依然局部安装 webpack。首先为了试验和学习 webpack，我们先创建一个目录。你可以克隆我 [github 上的仓库](https://github.com/joezimjs/webpack-Introduction-Tutorial)，在接下来的学习中你可以切换分支；或者你可以重新创建一个新的项目，然后使用我仓库中的代码作为比较。\n\n通过命令行进入你的项目目录，使用 `npm init` 初始化项目，除非你要把项目发布到 npm 上，否则，你填入什么项目信息并不重要。\n\n这时候你项目里增加了一个 `package.json` 文件（通过`npm init`创建），你可以把依赖保存在这里。所以我们使用 npm 安装 webpack 为项目的一个依赖项：`npm install webpack -D`。（使用 `-D` 代表这是一个开发依赖，保存在 `package.json` 的 `devDependencies` 里，你也可以使用 `--save-dev` ）。\n\n在使用 webpack 在之前，我们需要创建一个简单的应用。首先我们安装 [lodash](http://www.lodash.com/)，这样我们的应用就有一个依赖：`npm install lodash -S`（`-S` 同 `--save`），然后我们创建一个名为 `src` 的目录，在里面创建一个文件： `main.js`：\n\n```js\nvar map = require('lodash/map');\n\nfunction square(n) {\n    return n*n;\n}\n\nconsole.log(map([1,2,3,4,5,6], square));\n```\n\n很简单对不对？我们创建一个从1到6的数字数据，然后使用 loadsh 的 map 方法将原数组每一项平方得到一个新的数组。最后我们通过 console 打印出新数组。这个文件可以使用 Nodejs 运行，运行 `node src/main.js` 输出结果为 `[ 1, 4, 9, 16, 25, 36 ]`。\n\n但是我们想将这段短小的代码和我们需要的 lodash 代码打包，并且可以在浏览器运行，webpack 可以做到么？我们该怎么做？\n\n## 使用 Webpack 命令行\n\n使用 webpack 最简单的方法就是直接命令行运行，而不用去花费时间去写一个配置文件。最简单的 webpack 命令行，不必使用配置文件，只需要输入文件路径和输出文件路径两个参数。Webpack 会读取输入文件，遍历依赖树，将所有文件打包成一个文件，输出到你指定的输出文件路径。在这个例子中，我们的输入路径是 `src/main.js`，我们想把打包文件输出到 `dist/bundle.js`，所以我们来创建一个 npm scripts 来做这件事情（我们没有全局安装 webpack，所有不能直接从命令行运行），在 `package.json` 中，编辑 `scripts` ：\n\n```json\n\"scripts\": {\n\"build\": \"webpack src/main.js dist/bundle.js\"\n}\n```\n\n现在，运行 `npm run build`，webpack开始工作，当运行完毕——不会很长时间——会生成一个新的 `dist/bundle.js` 文件。你可以在 nodejs 或者 浏览器中运行打包后的文件，你会得到同样的输出结果。\n\n在继续探索 webpack 之前，我们先完善一下构建脚本：重新构建之前先删除 `dist` 目录及其内容，并且增加一些脚本来运行打包后的文件。首先我们安装 `del-cli` 来删除目录，这样不会让使用不同系统的人感到苦恼（不要恨我，我用的 windows）；运行`npm install -D`安装。然后我们更新 npm scripts：\n\n```json\n\"scripts\": {\n  \"prebuild\": \"del-cli dist -f\",\n  \"build\": \"webpack src/main.js dist/bundle.js\",\n  \"execute\": \"node dist/bundle.js\",\n  \"start\": \"npm run build -s && npm run execute -s\"\n}\n```\n\n`build` 命令和之前一样，增加了 `prebuild` 来做一些清理工作，这个命令每次都会先于 `build` 运行，同时增加 `execute` 命令，使用 nodejs 运行打包后的脚本。然后使用 `start` 运行所有的命令（`-s` 可以让 npm scripts 不会输出一些无用的信息）。运行 `npm srart`，你可以看到 webpack 的输出，开平方后的数组打印在了控制台上。恭喜你，你完成了之前我提高的仓库的 `example1` 分支的所有工作。\n\n## 使用配置文件\n\n虽然我们愉快的使用命令开始使用 webpack，但当我们开始使用 webpack 更多的特性的时候，你会把所有传进命令行的配置项都移入配置文件中，使用配置文件，功能更强大，代码更加易读。因为它是用 JavaScript 写成的。\n\n让我们创建一个配置文件。在你项目的根目录，创建一个名为 `webpack.config.js` 的文件，这是 webpack 默认查找的文件。你也可以给 webpack 传入 `--config [filename]`，告诉 webpack你想使用不同名字或者其他目录的配置文件。\n\n在本教程中，我们使用标准的文件名。现在我们使用配置文件来完成上面我们使用命令行完成的任务。我们在配置文件中添加几行代码：\n\n```js\nmodule.exports = {\n    entry: './src/main.js',\n    output: {\n        path: './dist',\n        filename: 'bundle.js'\n    }\n};\n```\n\n就像在命令行中一样，我们指明了输出文件和输入文件。这是一个 JavaScript 文件，不是 JSON，所有我们需要到处配置对象 - 使用 `module.exports`。现在可能看起来不如命令行中优雅，不过读到文章最后，你会对这个决定感到欣喜的。\n\n现在我们可以从 `package.json` 中移除传给 webpack 的命令行参数了，你的 scripts 看起来应该是这样：\n\n```json\n\"scripts\": {\n  \"prebuild\": \"del-cli dist -f\",\n  \"build\": \"webpack\",\n  \"execute\": \"node dist/bundle.js\",\n  \"start\": \"npm run build -s && npm run execute -s\"\n}\n```\n\n你依然可以运行 `npm start`，并得到相同的结果。这样我们就完成了 `example2` 分支的内容。\n\n## 使用 Loaders\n\n主要有两种方法来增强 Webpack 的能力：loaders 和 plugins。插件我们将稍后讨论。现在我们将关注点放在 loaders 上，loaders 可以用来对特定类型的文件进行转化和操作。你可以将多个 loader 串起来对同一个文件进行处理。例如，你可以使用 [ESLint](http://eslint.org/)对所有扩展名是 `.js` 的文件进行检查，并且使用 [Babel](https://babeljs.io/)将他们从 ES2015 的语法编译为 ES5，如果 ESLint 出现警告就会在控制台打印出来，如果遇到错误，就会中断 Webpack 操作。\n\n说回我们的小程序，我们不会安装任何检查工具，但我们会安装 Babel，把我们的代码编译为 ES5。当然，我们需要先写点 ES2015 的代码，我们把 `main.js` 的内容改为：\n\n```js\nimport { map } from 'lodash';\n\nconsole.log(map([1,2,3,4,5,6], n => n*n));\n```\n\n这段代码本质上做了和之前相同的事情，但是（1）我们使用了箭头函数，而不是名为`square`的方法，并且（2）我们使用了 `import` 语法来引入的 lodash 的 map 方法。这样就会把整个 lodash 文件打包进来，而不是通过 `lodash/map` 只引入 `map` 相关的方法。如果你愿意，你可以把代码第一行改为 `import map from lodash/map` , 但是我这么做有这么几点原因：\n\n* 在大型应用中，你或许会引入很大块的lodash，这和全部引入也差不多。\n* 如果你使用 Backbone.js，很难做到每次单独引入方法，因为没有文档告诉你 Backbone.js 到底需要多少个方法。\n* 在下一个版本的 webpack 中，会引入一项新的技术 - tree-shaking，可以排除掉没有用到的模块，所以还是达到了上面的目的。\n* 我想把这个作为例子，来告诉你刚才我提到的这一点（*译者注： 应该是 tree-shaking 这一点*）。\n\n（注意：Lodash 可以使用上述两种方法引入，是因为它的开发者使之可以这么做，而不是所有的库都可以这么做）\n\n不管怎么说，我们使用了一些 ES2015 的语法，我们需要将其编译为 ES5，这样就可以在老旧的浏览器中使用了（[ES2015在新的浏览器的支持](http://kangax.github.io/compat-table/es6/)还是很喜人的）。我们需要 Babel 及其附属来配合 webpack 工作，至少需要 [babel-core](https://www.npmjs.com/package/babel-core)（Babel的核心，承担大部分工作）、[babel-loader](https://www.npmjs.com/package/babel-loader)（基于 babel-core 的 webpack loader）、[babel-preset-2015](https://www.npmjs.com/package/babel-loader)（包含了 ES2015 编译到 ES5 的规则），我们还需要 [babel-plugin-transform-runtime](https://www.npmjs.com/package/babel-plugin-transform-runtime)和[babel-polyfill](https://www.npmjs.com/package/babel-polyfill)。这俩都是用来在你的代码加 polyfill 或者添加 helper 方法，用途差不多。不过我全部添加到项目里，你会看见他们是如何工作的，如果你想更多的了解他们，请求阅读文档： [polyfill](http://babeljs.io/docs/usage/polyfill/) 和 [runtime transform](http://babeljs.io/docs/plugins/transform-runtime/)。\n\n一股脑的安装：`npm i -D babel-core babel-loader babel-preset-es2015 babel-plugin-transform-runtime babel-polyfill`，然后在配置文件中使用他们，首先需要一块地方配置 loaders，更新你的 webpack.config.js：\n\n```js\nmodule.exports = {\n    entry: './src/main.js',\n    output: {\n        path: './dist',\n        filename: 'bundle.js'\n    },\n    module: {\n        rules: [\n            …\n        ]\n    }\n};\n```\n\n我们添加了一个属性 `module`，里面包含 `rules` 属性，rules属性是一个数组，包含了你所用的的所有 loader 的配置。接下来我们会在这里添加 babel-loader，对每个 loader 来说，我们至少需要设置两个选项：`test` 和 `loader`，`test` 通常是一个正则表达式，来匹配每个文件的绝对路径，不过一般我们只是匹配文件的扩展名，例如，`/\\.js$/` 匹配扩展名为 `.js` 的文件；如果你想在应用中使用 React，设置 `/\\.jsx?$/`，就会匹配 `.js` 和 `.jsx`。现在我们需要设置 `loader`，也就是 `test` 匹配到的文件需要使用的 loader。\n\nloader 通过传入 loader 的名字来指定，loader 的名字有短横线分割，比如 `'babel-loader!eslint-loader'`。webpack 从右向左读取，`esling-loader` 会先于 `babel-loader` 执行。如果你想给 loader 设置选项，使用查询字符串语法。例如给 babel 设置 `fakeoption` 为 `true`，我们需要把之前的例子改为 `babel-loader?fakeoption=true!eslint-loader`，你也可以使用 `use` 选项传入 loaders 的数组，如果你觉得这样更加简单更加易读。例如，最后的一个例子就变成：` use: ['babel-loader?fakeoption=true', 'eslint-loader']`，如果你增强可读性，可以写成多行。\n\n*译者注: 上文其实是 webpack1 和 webpack2 的区别：[https://doc.webpack-china.org/guides/migrating/#-loaders](https://doc.webpack-china.org/guides/migrating/#-loaders)*\n\n因为我们只用到了 babel-loader，loader 的配置如下：\n\n```js\nrules: [\n    { test: /\\.jsx?$/, loader: 'babel-loader' }\n]\n```\n\n如果只用到了一个 loader，这里有另外一种方式去设置 loader 的选项，不是之前提到的查询字符串的方式：使用 `options` 选项，它可以使用 key-value 的形式，对于例子中的 `fakeOptions`，我们可以这样配置：\n\n```js\nrules: [\n    {\n        test: /\\.jsx?$/,\n        loader: 'babel-loader',\n        options: {\n            fakeoption: true\n        }\n    }\n]\n```\n\n我们用这种语法来为 babel-loader 设置几个选项\n\n```js\nrules: [\n    {\n        test: /\\.jsx?$/,\n        loader: 'babel-loader',\n        options: {\n            plugins: ['transform-runtime'],\n            presets: ['es2015']\n        }\n    }\n]\n```\n\n我们设置了 `presets` ，这样所有的 ES2015的特性都会被编译为 ES5，我们还设置了 transform-runtime 插件。上文提到，这个插件不是必需的，在这里只是展示如何使用它。另一种方式是使用 `.babelrc` 来配置这些选项，但这样我就不能给你们展示如何在 webpack 中配置了。通常来说，我还是建议使用 `.babelrc`，但在我们的项目中还是保持在 webpack 中配置。\n\n还有一件配置需要告诉 babel-loader。我们需要告诉 babel 不要处理 `node_modules` 目录，这样可以提高打包速速。增加 `exclude` 选项，告诉 loader 不要处理这个目录下的文件。`exclude` 也是一个正则表达式，所以我们设置为 `/node_modules/`：\n\n```js\nrules: [\n    {\n        test: /\\.jsx?$/,\n        loader: 'babel-loader',\n        exclude: /node_modules/,\n        options: {\n            plugins: ['transform-runtime'],\n            presets: ['es2015']\n        }\n    }\n]\n```\n\n此外，也可以使用 `include` 的属性，表示我们只是用 `src` 目录，不过我想还是先不这么做。重新执行 `npm start`，得到可以在浏览器运行的 ES5 代码。如果你决定使用 `babel-polyfill` 代替 transform-runtime 插件，你需要做一些改变。首先，删除 `plugins: ['transform-runtime]`（如果之后你也不需要它了，可以通过 npm 卸载掉），然后修改 webpack 的 `entry`：\n\n```js\nentry: [\n    'babel-polyfill',\n    './src/main.js'\n],\n```\n\n我们使用一个数组声明了多入口文件，而不是单一入口，新的入口文件就是这个 polyfill。这样就可以使得 polyfill 在打包文件之前，这样就保证了在我们处理代码之前，polyfill是存在的。\n\n如果不在配置文件中配置，我们需要在 `src/main.js` 的文件头部添加一行 `import 'babel-polyfill;`，和在配置文件中效果是一样的。我之所以放在配置文件中是因为在最后一个例子中会用到，并且这也是一个展示合并多个入口文件到一个文件的好例子。好了，这就是 `example3` 分支的所有内容，再一次运行 `npm start` 验证一下。\n\n## 使用 Handlebars Loader\n\n让我们添加另外一个 loader：Handlebars loader，Handlebars loader会把模板编译为一个方法，当你引入一个 handlebars 模板的时候，这个编译后的方法会被引入 JavaScript 文件中，这也是我喜欢 loaders 的一个原因：你可以引入非 JavaScript 文件，当它们全部打包后，可以和 JavaScript 以前使用。另一个例子是你可以使用 loader 引入一个图片，并且可以把图片转换为 base64 编码的 url，JavaScript 就可以把它内联到页面中。如果你把多个 loader 串联起来，其中一个 loader 甚至可以对图片进行优化到一个比较小的尺寸。\n\n通常来说，首先需要安装 loader：`npm install -D handlebars-loader`。使用之前，要先安装 HandleBars：`npm install -D handlebars`。这样你就可以控制 Handlebars 的版本，而不用去同步 loader 的版本，做到单独升级。\n\n现在我们都安装了，在`src`目录下创建一个 `numberlist.hbs` 模板文件：\n*译者注：因为模板会导致博客解析错误，所以我给两个大括号之前加了斜线。。。*\n\n```html\n<ul>\n  {\\{#each numbers as |number i|}}\n    <li>{{number}}</li>\n  {\\{/each}}\n</ul>\n```\n\n这个模板接受一个数组（从变量名字来看是个数字，当然不是数字也能用），创建一个无序的列表。\n\n现在调整 JavaScript 文件，使用这个模板输出一个列表，而不是仅仅打印到控制台上，`main.js` 现在看起来是这样：\n\n```js\nimport { map } from 'lodash';\nimport template from './numberlist.hbs';\n\nlet numbers = map([1,2,3,4,5,6], n => n*n);\n\nconsole.log(template({numbers}));\n```\n\n遗憾的是，现在并不能正常工作，因为 webpack 不能识别 `numberslist.hbs`，它不是 JavaScript 文件。我们可以在 `import` 语句中添加一点东西来使用 Handlebars loader：\n\n```js\nimport { map } from 'lodash';\nimport template from 'handlebars-loader!./numberlist.hbs';\n\nlet numbers = map([1,2,3,4,5,6], n => n*n);\n\nconsole.log(template({numbers}));\n```\n\n通过在文件路径的前面加一个 loader 的名字，用惊叹号分割开，这样 webpack 就能使用 loader 来处理这个文件了。这样做的话，我们不用在配置文件中做任何事情。然而，在一个大型项目中，你可能加载多个模板，所以在配置文件中做会更有效，这样就不用对每个加载的模板路径前面加上 `handlebars!`，更新配置为：\n\n```js\nrules: [\n    {/* babel loader config… */},\n    { test: /\\.hbs$/, loader: 'handlebars-loader' }\n]\n```\n\n很简单。我们要做的就是告诉 webpack 使用 handlerbars-loader 来处理所有 `.hbs` 后缀的文件。这样我们就做完了 `example4` 分支中的所有事情，现在运行 `npm start`，你会看见 webpack 打包输出：\n\n```html\n<ul>\n<li>1</li>\n<li>4</li>\n<li>9</li>\n<li>16</li>\n<li>25</li>\n<li>36</li>\n</ul>\n```\n\n---\n\n文章是在太长，分成上下两部分。\n原文地址：[A Detailed Introduction To Webpack](https://www.smashingmagazine.com/2017/02/a-detailed-introduction-to-webpack/)\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/a-detailed-introduction-to-webpack-1.md","raw":"\nlayout: post\ntitle: 详解 Webpack（上）\nbanner: assets/img/webpack.jpg\nlabel: 译\ntags: webpack\n---\n\nJavaScript 模块打包工具已经出现有一段时间了。RequireJS 在2009年完成了第一次提交，然后 Browserify 随之出现，从那时候起相继出现了各种模块打包工具。在这些里面，*webpack*脱颖而出。如果你还不熟悉它，我希望这篇文章可以帮你开始使用这个强大的工具。\n\n## 什么是模块打包工具\n\n在大多数语言中（包括 ECMAScript 2015+，JavaScript 的最新标准，但还没有被浏览器广泛支持），你可以将代码分割成多个文件，然后将这些文件导入到你的应用中，来使用他们所包含的功能。浏览器并没有内建这样的功能，所以模块打包工具如果要实现这些功能，有以下几种方式：异步加载模块，在加载完成后执行；或者是将所有需要的文件合并成一个 JavaScript 文件，在 HTML 里通过 `<script>` 标签加载。\n\n不使用模块管理和打包工具，你也可以手动合并你的文件，然后使用数不清的 `<script>` 标签引入，不过这样做缺点也很明显：\n\n* 你需要保证需要加载的文件的顺序，包括文件的依赖关系以及你要保证不要加载那些你不需要的文件。\n* 越多的 `<script>` 的标签意味着要加载你的代码需要更多的服务器请求，影响性能。\n* 很明显，这需要大量的手动操作，而不是让计算机来做处理。\n\n大多数的模块打包工具可以很简单的和 npm 或者 Bower 集成，这样你就可以为你的应用添加第三方依赖。你只需要安装并且用一行代码导入到你的应用中。然后运行打包工具，你的应用代码就和第三方代码合并到一起；或者你配置正确，你可以把你所有的依赖代码打包到另外一个文件里，这样当你更新了应用的代码，用户更新应用代码的缓存时候，就不必重新下载这些依赖库的代码。\n\n## 为什么选择 Webpack\n\n现在你已经基本了解 webpack 的作用了，但为什么你要选择 webpack，有这么几个原因：\n\n* 其中一个优势是相对来说它比较新，所以它能够避免之前的工具们存在的一些缺陷和问题。\n* 上手简单。如果你只是想要把所有 JavaScript 文件打包成一个文件，而不做其他事情，你甚至都不需要配置文件。\n* 它的插件系统可以做更多的事情，使得它更加强大，所以，或许构建工具，一个 webpack 足够了。\n\n我见过一些其他和 webpack 功能类似的打包和构建工具，但 webpack 更胜一筹：当你遇到困难时你可以去庞大的社区寻找帮助。Browserify 的社区也挺大，但是它缺少一些 webpack 具有的潜在的必需的特性。我把所有的赞誉都给了 webpack，你们一定等我开始 show my code 了，开始吧 ~\n\n## 安装 Webpack\n\n在使用 webpack 之前，我们首先需要安装它。我假设你已经安装了 Nodejs 和 npm，如果你还没安装他们，查看 [Nodejs 官网](https://nodejs.org/)。\n\n有两种方式来安装 webpack（其实其他命令行程序也是一样）：全局安装和局部安装。如果你选择全局安装，你可以在任意目录下使用，但是它不会作为你局部依赖存在，并且你不能在不同的项目之间切换 webpack 的版本（一些项目可能需要更新一点的版本，你可能不得不等一等再升级）。所以对于命令行程序我更倾向于局部安装，然后使用相对路径或者 [npm scripts](https://docs.npmjs.com/misc/scripts) 来运行程序。如果你没有局部安装过命令行程序，你可以读一下我写的一篇文章，关于摆脱[全局安装 npm 包](https://www.joezimjs.com/javascript/no-more-global-npm-packages/)。\n\n接下来我们会使用 npm scripts 来进行我们的例子，所以我们依然局部安装 webpack。首先为了试验和学习 webpack，我们先创建一个目录。你可以克隆我 [github 上的仓库](https://github.com/joezimjs/webpack-Introduction-Tutorial)，在接下来的学习中你可以切换分支；或者你可以重新创建一个新的项目，然后使用我仓库中的代码作为比较。\n\n通过命令行进入你的项目目录，使用 `npm init` 初始化项目，除非你要把项目发布到 npm 上，否则，你填入什么项目信息并不重要。\n\n这时候你项目里增加了一个 `package.json` 文件（通过`npm init`创建），你可以把依赖保存在这里。所以我们使用 npm 安装 webpack 为项目的一个依赖项：`npm install webpack -D`。（使用 `-D` 代表这是一个开发依赖，保存在 `package.json` 的 `devDependencies` 里，你也可以使用 `--save-dev` ）。\n\n在使用 webpack 在之前，我们需要创建一个简单的应用。首先我们安装 [lodash](http://www.lodash.com/)，这样我们的应用就有一个依赖：`npm install lodash -S`（`-S` 同 `--save`），然后我们创建一个名为 `src` 的目录，在里面创建一个文件： `main.js`：\n\n```js\nvar map = require('lodash/map');\n\nfunction square(n) {\n    return n*n;\n}\n\nconsole.log(map([1,2,3,4,5,6], square));\n```\n\n很简单对不对？我们创建一个从1到6的数字数据，然后使用 loadsh 的 map 方法将原数组每一项平方得到一个新的数组。最后我们通过 console 打印出新数组。这个文件可以使用 Nodejs 运行，运行 `node src/main.js` 输出结果为 `[ 1, 4, 9, 16, 25, 36 ]`。\n\n但是我们想将这段短小的代码和我们需要的 lodash 代码打包，并且可以在浏览器运行，webpack 可以做到么？我们该怎么做？\n\n## 使用 Webpack 命令行\n\n使用 webpack 最简单的方法就是直接命令行运行，而不用去花费时间去写一个配置文件。最简单的 webpack 命令行，不必使用配置文件，只需要输入文件路径和输出文件路径两个参数。Webpack 会读取输入文件，遍历依赖树，将所有文件打包成一个文件，输出到你指定的输出文件路径。在这个例子中，我们的输入路径是 `src/main.js`，我们想把打包文件输出到 `dist/bundle.js`，所以我们来创建一个 npm scripts 来做这件事情（我们没有全局安装 webpack，所有不能直接从命令行运行），在 `package.json` 中，编辑 `scripts` ：\n\n```json\n\"scripts\": {\n\"build\": \"webpack src/main.js dist/bundle.js\"\n}\n```\n\n现在，运行 `npm run build`，webpack开始工作，当运行完毕——不会很长时间——会生成一个新的 `dist/bundle.js` 文件。你可以在 nodejs 或者 浏览器中运行打包后的文件，你会得到同样的输出结果。\n\n在继续探索 webpack 之前，我们先完善一下构建脚本：重新构建之前先删除 `dist` 目录及其内容，并且增加一些脚本来运行打包后的文件。首先我们安装 `del-cli` 来删除目录，这样不会让使用不同系统的人感到苦恼（不要恨我，我用的 windows）；运行`npm install -D`安装。然后我们更新 npm scripts：\n\n```json\n\"scripts\": {\n  \"prebuild\": \"del-cli dist -f\",\n  \"build\": \"webpack src/main.js dist/bundle.js\",\n  \"execute\": \"node dist/bundle.js\",\n  \"start\": \"npm run build -s && npm run execute -s\"\n}\n```\n\n`build` 命令和之前一样，增加了 `prebuild` 来做一些清理工作，这个命令每次都会先于 `build` 运行，同时增加 `execute` 命令，使用 nodejs 运行打包后的脚本。然后使用 `start` 运行所有的命令（`-s` 可以让 npm scripts 不会输出一些无用的信息）。运行 `npm srart`，你可以看到 webpack 的输出，开平方后的数组打印在了控制台上。恭喜你，你完成了之前我提高的仓库的 `example1` 分支的所有工作。\n\n## 使用配置文件\n\n虽然我们愉快的使用命令开始使用 webpack，但当我们开始使用 webpack 更多的特性的时候，你会把所有传进命令行的配置项都移入配置文件中，使用配置文件，功能更强大，代码更加易读。因为它是用 JavaScript 写成的。\n\n让我们创建一个配置文件。在你项目的根目录，创建一个名为 `webpack.config.js` 的文件，这是 webpack 默认查找的文件。你也可以给 webpack 传入 `--config [filename]`，告诉 webpack你想使用不同名字或者其他目录的配置文件。\n\n在本教程中，我们使用标准的文件名。现在我们使用配置文件来完成上面我们使用命令行完成的任务。我们在配置文件中添加几行代码：\n\n```js\nmodule.exports = {\n    entry: './src/main.js',\n    output: {\n        path: './dist',\n        filename: 'bundle.js'\n    }\n};\n```\n\n就像在命令行中一样，我们指明了输出文件和输入文件。这是一个 JavaScript 文件，不是 JSON，所有我们需要到处配置对象 - 使用 `module.exports`。现在可能看起来不如命令行中优雅，不过读到文章最后，你会对这个决定感到欣喜的。\n\n现在我们可以从 `package.json` 中移除传给 webpack 的命令行参数了，你的 scripts 看起来应该是这样：\n\n```json\n\"scripts\": {\n  \"prebuild\": \"del-cli dist -f\",\n  \"build\": \"webpack\",\n  \"execute\": \"node dist/bundle.js\",\n  \"start\": \"npm run build -s && npm run execute -s\"\n}\n```\n\n你依然可以运行 `npm start`，并得到相同的结果。这样我们就完成了 `example2` 分支的内容。\n\n## 使用 Loaders\n\n主要有两种方法来增强 Webpack 的能力：loaders 和 plugins。插件我们将稍后讨论。现在我们将关注点放在 loaders 上，loaders 可以用来对特定类型的文件进行转化和操作。你可以将多个 loader 串起来对同一个文件进行处理。例如，你可以使用 [ESLint](http://eslint.org/)对所有扩展名是 `.js` 的文件进行检查，并且使用 [Babel](https://babeljs.io/)将他们从 ES2015 的语法编译为 ES5，如果 ESLint 出现警告就会在控制台打印出来，如果遇到错误，就会中断 Webpack 操作。\n\n说回我们的小程序，我们不会安装任何检查工具，但我们会安装 Babel，把我们的代码编译为 ES5。当然，我们需要先写点 ES2015 的代码，我们把 `main.js` 的内容改为：\n\n```js\nimport { map } from 'lodash';\n\nconsole.log(map([1,2,3,4,5,6], n => n*n));\n```\n\n这段代码本质上做了和之前相同的事情，但是（1）我们使用了箭头函数，而不是名为`square`的方法，并且（2）我们使用了 `import` 语法来引入的 lodash 的 map 方法。这样就会把整个 lodash 文件打包进来，而不是通过 `lodash/map` 只引入 `map` 相关的方法。如果你愿意，你可以把代码第一行改为 `import map from lodash/map` , 但是我这么做有这么几点原因：\n\n* 在大型应用中，你或许会引入很大块的lodash，这和全部引入也差不多。\n* 如果你使用 Backbone.js，很难做到每次单独引入方法，因为没有文档告诉你 Backbone.js 到底需要多少个方法。\n* 在下一个版本的 webpack 中，会引入一项新的技术 - tree-shaking，可以排除掉没有用到的模块，所以还是达到了上面的目的。\n* 我想把这个作为例子，来告诉你刚才我提到的这一点（*译者注： 应该是 tree-shaking 这一点*）。\n\n（注意：Lodash 可以使用上述两种方法引入，是因为它的开发者使之可以这么做，而不是所有的库都可以这么做）\n\n不管怎么说，我们使用了一些 ES2015 的语法，我们需要将其编译为 ES5，这样就可以在老旧的浏览器中使用了（[ES2015在新的浏览器的支持](http://kangax.github.io/compat-table/es6/)还是很喜人的）。我们需要 Babel 及其附属来配合 webpack 工作，至少需要 [babel-core](https://www.npmjs.com/package/babel-core)（Babel的核心，承担大部分工作）、[babel-loader](https://www.npmjs.com/package/babel-loader)（基于 babel-core 的 webpack loader）、[babel-preset-2015](https://www.npmjs.com/package/babel-loader)（包含了 ES2015 编译到 ES5 的规则），我们还需要 [babel-plugin-transform-runtime](https://www.npmjs.com/package/babel-plugin-transform-runtime)和[babel-polyfill](https://www.npmjs.com/package/babel-polyfill)。这俩都是用来在你的代码加 polyfill 或者添加 helper 方法，用途差不多。不过我全部添加到项目里，你会看见他们是如何工作的，如果你想更多的了解他们，请求阅读文档： [polyfill](http://babeljs.io/docs/usage/polyfill/) 和 [runtime transform](http://babeljs.io/docs/plugins/transform-runtime/)。\n\n一股脑的安装：`npm i -D babel-core babel-loader babel-preset-es2015 babel-plugin-transform-runtime babel-polyfill`，然后在配置文件中使用他们，首先需要一块地方配置 loaders，更新你的 webpack.config.js：\n\n```js\nmodule.exports = {\n    entry: './src/main.js',\n    output: {\n        path: './dist',\n        filename: 'bundle.js'\n    },\n    module: {\n        rules: [\n            …\n        ]\n    }\n};\n```\n\n我们添加了一个属性 `module`，里面包含 `rules` 属性，rules属性是一个数组，包含了你所用的的所有 loader 的配置。接下来我们会在这里添加 babel-loader，对每个 loader 来说，我们至少需要设置两个选项：`test` 和 `loader`，`test` 通常是一个正则表达式，来匹配每个文件的绝对路径，不过一般我们只是匹配文件的扩展名，例如，`/\\.js$/` 匹配扩展名为 `.js` 的文件；如果你想在应用中使用 React，设置 `/\\.jsx?$/`，就会匹配 `.js` 和 `.jsx`。现在我们需要设置 `loader`，也就是 `test` 匹配到的文件需要使用的 loader。\n\nloader 通过传入 loader 的名字来指定，loader 的名字有短横线分割，比如 `'babel-loader!eslint-loader'`。webpack 从右向左读取，`esling-loader` 会先于 `babel-loader` 执行。如果你想给 loader 设置选项，使用查询字符串语法。例如给 babel 设置 `fakeoption` 为 `true`，我们需要把之前的例子改为 `babel-loader?fakeoption=true!eslint-loader`，你也可以使用 `use` 选项传入 loaders 的数组，如果你觉得这样更加简单更加易读。例如，最后的一个例子就变成：` use: ['babel-loader?fakeoption=true', 'eslint-loader']`，如果你增强可读性，可以写成多行。\n\n*译者注: 上文其实是 webpack1 和 webpack2 的区别：[https://doc.webpack-china.org/guides/migrating/#-loaders](https://doc.webpack-china.org/guides/migrating/#-loaders)*\n\n因为我们只用到了 babel-loader，loader 的配置如下：\n\n```js\nrules: [\n    { test: /\\.jsx?$/, loader: 'babel-loader' }\n]\n```\n\n如果只用到了一个 loader，这里有另外一种方式去设置 loader 的选项，不是之前提到的查询字符串的方式：使用 `options` 选项，它可以使用 key-value 的形式，对于例子中的 `fakeOptions`，我们可以这样配置：\n\n```js\nrules: [\n    {\n        test: /\\.jsx?$/,\n        loader: 'babel-loader',\n        options: {\n            fakeoption: true\n        }\n    }\n]\n```\n\n我们用这种语法来为 babel-loader 设置几个选项\n\n```js\nrules: [\n    {\n        test: /\\.jsx?$/,\n        loader: 'babel-loader',\n        options: {\n            plugins: ['transform-runtime'],\n            presets: ['es2015']\n        }\n    }\n]\n```\n\n我们设置了 `presets` ，这样所有的 ES2015的特性都会被编译为 ES5，我们还设置了 transform-runtime 插件。上文提到，这个插件不是必需的，在这里只是展示如何使用它。另一种方式是使用 `.babelrc` 来配置这些选项，但这样我就不能给你们展示如何在 webpack 中配置了。通常来说，我还是建议使用 `.babelrc`，但在我们的项目中还是保持在 webpack 中配置。\n\n还有一件配置需要告诉 babel-loader。我们需要告诉 babel 不要处理 `node_modules` 目录，这样可以提高打包速速。增加 `exclude` 选项，告诉 loader 不要处理这个目录下的文件。`exclude` 也是一个正则表达式，所以我们设置为 `/node_modules/`：\n\n```js\nrules: [\n    {\n        test: /\\.jsx?$/,\n        loader: 'babel-loader',\n        exclude: /node_modules/,\n        options: {\n            plugins: ['transform-runtime'],\n            presets: ['es2015']\n        }\n    }\n]\n```\n\n此外，也可以使用 `include` 的属性，表示我们只是用 `src` 目录，不过我想还是先不这么做。重新执行 `npm start`，得到可以在浏览器运行的 ES5 代码。如果你决定使用 `babel-polyfill` 代替 transform-runtime 插件，你需要做一些改变。首先，删除 `plugins: ['transform-runtime]`（如果之后你也不需要它了，可以通过 npm 卸载掉），然后修改 webpack 的 `entry`：\n\n```js\nentry: [\n    'babel-polyfill',\n    './src/main.js'\n],\n```\n\n我们使用一个数组声明了多入口文件，而不是单一入口，新的入口文件就是这个 polyfill。这样就可以使得 polyfill 在打包文件之前，这样就保证了在我们处理代码之前，polyfill是存在的。\n\n如果不在配置文件中配置，我们需要在 `src/main.js` 的文件头部添加一行 `import 'babel-polyfill;`，和在配置文件中效果是一样的。我之所以放在配置文件中是因为在最后一个例子中会用到，并且这也是一个展示合并多个入口文件到一个文件的好例子。好了，这就是 `example3` 分支的所有内容，再一次运行 `npm start` 验证一下。\n\n## 使用 Handlebars Loader\n\n让我们添加另外一个 loader：Handlebars loader，Handlebars loader会把模板编译为一个方法，当你引入一个 handlebars 模板的时候，这个编译后的方法会被引入 JavaScript 文件中，这也是我喜欢 loaders 的一个原因：你可以引入非 JavaScript 文件，当它们全部打包后，可以和 JavaScript 以前使用。另一个例子是你可以使用 loader 引入一个图片，并且可以把图片转换为 base64 编码的 url，JavaScript 就可以把它内联到页面中。如果你把多个 loader 串联起来，其中一个 loader 甚至可以对图片进行优化到一个比较小的尺寸。\n\n通常来说，首先需要安装 loader：`npm install -D handlebars-loader`。使用之前，要先安装 HandleBars：`npm install -D handlebars`。这样你就可以控制 Handlebars 的版本，而不用去同步 loader 的版本，做到单独升级。\n\n现在我们都安装了，在`src`目录下创建一个 `numberlist.hbs` 模板文件：\n*译者注：因为模板会导致博客解析错误，所以我给两个大括号之前加了斜线。。。*\n\n```html\n<ul>\n  {\\{#each numbers as |number i|}}\n    <li>{{number}}</li>\n  {\\{/each}}\n</ul>\n```\n\n这个模板接受一个数组（从变量名字来看是个数字，当然不是数字也能用），创建一个无序的列表。\n\n现在调整 JavaScript 文件，使用这个模板输出一个列表，而不是仅仅打印到控制台上，`main.js` 现在看起来是这样：\n\n```js\nimport { map } from 'lodash';\nimport template from './numberlist.hbs';\n\nlet numbers = map([1,2,3,4,5,6], n => n*n);\n\nconsole.log(template({numbers}));\n```\n\n遗憾的是，现在并不能正常工作，因为 webpack 不能识别 `numberslist.hbs`，它不是 JavaScript 文件。我们可以在 `import` 语句中添加一点东西来使用 Handlebars loader：\n\n```js\nimport { map } from 'lodash';\nimport template from 'handlebars-loader!./numberlist.hbs';\n\nlet numbers = map([1,2,3,4,5,6], n => n*n);\n\nconsole.log(template({numbers}));\n```\n\n通过在文件路径的前面加一个 loader 的名字，用惊叹号分割开，这样 webpack 就能使用 loader 来处理这个文件了。这样做的话，我们不用在配置文件中做任何事情。然而，在一个大型项目中，你可能加载多个模板，所以在配置文件中做会更有效，这样就不用对每个加载的模板路径前面加上 `handlebars!`，更新配置为：\n\n```js\nrules: [\n    {/* babel loader config… */},\n    { test: /\\.hbs$/, loader: 'handlebars-loader' }\n]\n```\n\n很简单。我们要做的就是告诉 webpack 使用 handlerbars-loader 来处理所有 `.hbs` 后缀的文件。这样我们就做完了 `example4` 分支中的所有事情，现在运行 `npm start`，你会看见 webpack 打包输出：\n\n```html\n<ul>\n<li>1</li>\n<li>4</li>\n<li>9</li>\n<li>16</li>\n<li>25</li>\n<li>36</li>\n</ul>\n```\n\n---\n\n文章是在太长，分成上下两部分。\n原文地址：[A Detailed Introduction To Webpack](https://www.smashingmagazine.com/2017/02/a-detailed-introduction-to-webpack/)\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"a-detailed-introduction-to-webpack-1","published":1,"date":"2019-01-17T13:00:11.000Z","updated":"2019-01-17T13:00:11.000Z","comments":1,"photos":[],"link":"","_id":"cjr1en2oo001yha9sxbvdgada","content":"<p>JavaScript 模块打包工具已经出现有一段时间了。RequireJS 在2009年完成了第一次提交，然后 Browserify 随之出现，从那时候起相继出现了各种模块打包工具。在这些里面，<em>webpack</em>脱颖而出。如果你还不熟悉它，我希望这篇文章可以帮你开始使用这个强大的工具。</p>\n<h2 id=\"什么是模块打包工具\">什么是模块打包工具</h2>\n<p>在大多数语言中（包括 ECMAScript 2015+，JavaScript 的最新标准，但还没有被浏览器广泛支持），你可以将代码分割成多个文件，然后将这些文件导入到你的应用中，来使用他们所包含的功能。浏览器并没有内建这样的功能，所以模块打包工具如果要实现这些功能，有以下几种方式：异步加载模块，在加载完成后执行；或者是将所有需要的文件合并成一个 JavaScript 文件，在 HTML 里通过 <code>&lt;script&gt;</code> 标签加载。</p>\n<p>不使用模块管理和打包工具，你也可以手动合并你的文件，然后使用数不清的 <code>&lt;script&gt;</code> 标签引入，不过这样做缺点也很明显：</p>\n<ul>\n<li>你需要保证需要加载的文件的顺序，包括文件的依赖关系以及你要保证不要加载那些你不需要的文件。</li>\n<li>越多的 <code>&lt;script&gt;</code> 的标签意味着要加载你的代码需要更多的服务器请求，影响性能。</li>\n<li>很明显，这需要大量的手动操作，而不是让计算机来做处理。</li>\n</ul>\n<p>大多数的模块打包工具可以很简单的和 npm 或者 Bower 集成，这样你就可以为你的应用添加第三方依赖。你只需要安装并且用一行代码导入到你的应用中。然后运行打包工具，你的应用代码就和第三方代码合并到一起；或者你配置正确，你可以把你所有的依赖代码打包到另外一个文件里，这样当你更新了应用的代码，用户更新应用代码的缓存时候，就不必重新下载这些依赖库的代码。</p>\n<h2 id=\"为什么选择-webpack\">为什么选择 Webpack</h2>\n<p>现在你已经基本了解 webpack 的作用了，但为什么你要选择 webpack，有这么几个原因：</p>\n<ul>\n<li>其中一个优势是相对来说它比较新，所以它能够避免之前的工具们存在的一些缺陷和问题。</li>\n<li>上手简单。如果你只是想要把所有 JavaScript 文件打包成一个文件，而不做其他事情，你甚至都不需要配置文件。</li>\n<li>它的插件系统可以做更多的事情，使得它更加强大，所以，或许构建工具，一个 webpack 足够了。</li>\n</ul>\n<p>我见过一些其他和 webpack 功能类似的打包和构建工具，但 webpack 更胜一筹：当你遇到困难时你可以去庞大的社区寻找帮助。Browserify 的社区也挺大，但是它缺少一些 webpack 具有的潜在的必需的特性。我把所有的赞誉都给了 webpack，你们一定等我开始 show my code 了，开始吧 ~</p>\n<h2 id=\"安装-webpack\">安装 Webpack</h2>\n<p>在使用 webpack 之前，我们首先需要安装它。我假设你已经安装了 Nodejs 和 npm，如果你还没安装他们，查看 <a href=\"https://nodejs.org/\" target=\"_blank\" rel=\"noopener\">Nodejs 官网</a>。</p>\n<p>有两种方式来安装 webpack（其实其他命令行程序也是一样）：全局安装和局部安装。如果你选择全局安装，你可以在任意目录下使用，但是它不会作为你局部依赖存在，并且你不能在不同的项目之间切换 webpack 的版本（一些项目可能需要更新一点的版本，你可能不得不等一等再升级）。所以对于命令行程序我更倾向于局部安装，然后使用相对路径或者 <a href=\"https://docs.npmjs.com/misc/scripts\" target=\"_blank\" rel=\"noopener\">npm scripts</a> 来运行程序。如果你没有局部安装过命令行程序，你可以读一下我写的一篇文章，关于摆脱<a href=\"https://www.joezimjs.com/javascript/no-more-global-npm-packages/\" target=\"_blank\" rel=\"noopener\">全局安装 npm 包</a>。</p>\n<p>接下来我们会使用 npm scripts 来进行我们的例子，所以我们依然局部安装 webpack。首先为了试验和学习 webpack，我们先创建一个目录。你可以克隆我 <a href=\"https://github.com/joezimjs/webpack-Introduction-Tutorial\" target=\"_blank\" rel=\"noopener\">github 上的仓库</a>，在接下来的学习中你可以切换分支；或者你可以重新创建一个新的项目，然后使用我仓库中的代码作为比较。</p>\n<p>通过命令行进入你的项目目录，使用 <code>npm init</code> 初始化项目，除非你要把项目发布到 npm 上，否则，你填入什么项目信息并不重要。</p>\n<p>这时候你项目里增加了一个 <code>package.json</code> 文件（通过<code>npm init</code>创建），你可以把依赖保存在这里。所以我们使用 npm 安装 webpack 为项目的一个依赖项：<code>npm install webpack -D</code>。（使用 <code>-D</code> 代表这是一个开发依赖，保存在 <code>package.json</code> 的 <code>devDependencies</code> 里，你也可以使用 <code>--save-dev</code> ）。</p>\n<p>在使用 webpack 在之前，我们需要创建一个简单的应用。首先我们安装 <a href=\"http://www.lodash.com/\" target=\"_blank\" rel=\"noopener\">lodash</a>，这样我们的应用就有一个依赖：<code>npm install lodash -S</code>（<code>-S</code> 同 <code>--save</code>），然后我们创建一个名为 <code>src</code> 的目录，在里面创建一个文件： <code>main.js</code>：</p>\n<pre><code class=\"language-js\">var map = require('lodash/map');\n\nfunction square(n) {\n    return n*n;\n}\n\nconsole.log(map([1,2,3,4,5,6], square));\n</code></pre>\n<p>很简单对不对？我们创建一个从1到6的数字数据，然后使用 loadsh 的 map 方法将原数组每一项平方得到一个新的数组。最后我们通过 console 打印出新数组。这个文件可以使用 Nodejs 运行，运行 <code>node src/main.js</code> 输出结果为 <code>[ 1, 4, 9, 16, 25, 36 ]</code>。</p>\n<p>但是我们想将这段短小的代码和我们需要的 lodash 代码打包，并且可以在浏览器运行，webpack 可以做到么？我们该怎么做？</p>\n<h2 id=\"使用-webpack-命令行\">使用 Webpack 命令行</h2>\n<p>使用 webpack 最简单的方法就是直接命令行运行，而不用去花费时间去写一个配置文件。最简单的 webpack 命令行，不必使用配置文件，只需要输入文件路径和输出文件路径两个参数。Webpack 会读取输入文件，遍历依赖树，将所有文件打包成一个文件，输出到你指定的输出文件路径。在这个例子中，我们的输入路径是 <code>src/main.js</code>，我们想把打包文件输出到 <code>dist/bundle.js</code>，所以我们来创建一个 npm scripts 来做这件事情（我们没有全局安装 webpack，所有不能直接从命令行运行），在 <code>package.json</code> 中，编辑 <code>scripts</code> ：</p>\n<pre><code class=\"language-json\">&quot;scripts&quot;: {\n&quot;build&quot;: &quot;webpack src/main.js dist/bundle.js&quot;\n}\n</code></pre>\n<p>现在，运行 <code>npm run build</code>，webpack开始工作，当运行完毕——不会很长时间——会生成一个新的 <code>dist/bundle.js</code> 文件。你可以在 nodejs 或者 浏览器中运行打包后的文件，你会得到同样的输出结果。</p>\n<p>在继续探索 webpack 之前，我们先完善一下构建脚本：重新构建之前先删除 <code>dist</code> 目录及其内容，并且增加一些脚本来运行打包后的文件。首先我们安装 <code>del-cli</code> 来删除目录，这样不会让使用不同系统的人感到苦恼（不要恨我，我用的 windows）；运行<code>npm install -D</code>安装。然后我们更新 npm scripts：</p>\n<pre><code class=\"language-json\">&quot;scripts&quot;: {\n  &quot;prebuild&quot;: &quot;del-cli dist -f&quot;,\n  &quot;build&quot;: &quot;webpack src/main.js dist/bundle.js&quot;,\n  &quot;execute&quot;: &quot;node dist/bundle.js&quot;,\n  &quot;start&quot;: &quot;npm run build -s &amp;&amp; npm run execute -s&quot;\n}\n</code></pre>\n<p><code>build</code> 命令和之前一样，增加了 <code>prebuild</code> 来做一些清理工作，这个命令每次都会先于 <code>build</code> 运行，同时增加 <code>execute</code> 命令，使用 nodejs 运行打包后的脚本。然后使用 <code>start</code> 运行所有的命令（<code>-s</code> 可以让 npm scripts 不会输出一些无用的信息）。运行 <code>npm srart</code>，你可以看到 webpack 的输出，开平方后的数组打印在了控制台上。恭喜你，你完成了之前我提高的仓库的 <code>example1</code> 分支的所有工作。</p>\n<h2 id=\"使用配置文件\">使用配置文件</h2>\n<p>虽然我们愉快的使用命令开始使用 webpack，但当我们开始使用 webpack 更多的特性的时候，你会把所有传进命令行的配置项都移入配置文件中，使用配置文件，功能更强大，代码更加易读。因为它是用 JavaScript 写成的。</p>\n<p>让我们创建一个配置文件。在你项目的根目录，创建一个名为 <code>webpack.config.js</code> 的文件，这是 webpack 默认查找的文件。你也可以给 webpack 传入 <code>--config [filename]</code>，告诉 webpack你想使用不同名字或者其他目录的配置文件。</p>\n<p>在本教程中，我们使用标准的文件名。现在我们使用配置文件来完成上面我们使用命令行完成的任务。我们在配置文件中添加几行代码：</p>\n<pre><code class=\"language-js\">module.exports = {\n    entry: './src/main.js',\n    output: {\n        path: './dist',\n        filename: 'bundle.js'\n    }\n};\n</code></pre>\n<p>就像在命令行中一样，我们指明了输出文件和输入文件。这是一个 JavaScript 文件，不是 JSON，所有我们需要到处配置对象 - 使用 <code>module.exports</code>。现在可能看起来不如命令行中优雅，不过读到文章最后，你会对这个决定感到欣喜的。</p>\n<p>现在我们可以从 <code>package.json</code> 中移除传给 webpack 的命令行参数了，你的 scripts 看起来应该是这样：</p>\n<pre><code class=\"language-json\">&quot;scripts&quot;: {\n  &quot;prebuild&quot;: &quot;del-cli dist -f&quot;,\n  &quot;build&quot;: &quot;webpack&quot;,\n  &quot;execute&quot;: &quot;node dist/bundle.js&quot;,\n  &quot;start&quot;: &quot;npm run build -s &amp;&amp; npm run execute -s&quot;\n}\n</code></pre>\n<p>你依然可以运行 <code>npm start</code>，并得到相同的结果。这样我们就完成了 <code>example2</code> 分支的内容。</p>\n<h2 id=\"使用-loaders\">使用 Loaders</h2>\n<p>主要有两种方法来增强 Webpack 的能力：loaders 和 plugins。插件我们将稍后讨论。现在我们将关注点放在 loaders 上，loaders 可以用来对特定类型的文件进行转化和操作。你可以将多个 loader 串起来对同一个文件进行处理。例如，你可以使用 <a href=\"http://eslint.org/\" target=\"_blank\" rel=\"noopener\">ESLint</a>对所有扩展名是 <code>.js</code> 的文件进行检查，并且使用 <a href=\"https://babeljs.io/\" target=\"_blank\" rel=\"noopener\">Babel</a>将他们从 ES2015 的语法编译为 ES5，如果 ESLint 出现警告就会在控制台打印出来，如果遇到错误，就会中断 Webpack 操作。</p>\n<p>说回我们的小程序，我们不会安装任何检查工具，但我们会安装 Babel，把我们的代码编译为 ES5。当然，我们需要先写点 ES2015 的代码，我们把 <code>main.js</code> 的内容改为：</p>\n<pre><code class=\"language-js\">import { map } from 'lodash';\n\nconsole.log(map([1,2,3,4,5,6], n =&gt; n*n));\n</code></pre>\n<p>这段代码本质上做了和之前相同的事情，但是（1）我们使用了箭头函数，而不是名为<code>square</code>的方法，并且（2）我们使用了 <code>import</code> 语法来引入的 lodash 的 map 方法。这样就会把整个 lodash 文件打包进来，而不是通过 <code>lodash/map</code> 只引入 <code>map</code> 相关的方法。如果你愿意，你可以把代码第一行改为 <code>import map from lodash/map</code> , 但是我这么做有这么几点原因：</p>\n<ul>\n<li>在大型应用中，你或许会引入很大块的lodash，这和全部引入也差不多。</li>\n<li>如果你使用 Backbone.js，很难做到每次单独引入方法，因为没有文档告诉你 Backbone.js 到底需要多少个方法。</li>\n<li>在下一个版本的 webpack 中，会引入一项新的技术 - tree-shaking，可以排除掉没有用到的模块，所以还是达到了上面的目的。</li>\n<li>我想把这个作为例子，来告诉你刚才我提到的这一点（<em>译者注： 应该是 tree-shaking 这一点</em>）。</li>\n</ul>\n<p>（注意：Lodash 可以使用上述两种方法引入，是因为它的开发者使之可以这么做，而不是所有的库都可以这么做）</p>\n<p>不管怎么说，我们使用了一些 ES2015 的语法，我们需要将其编译为 ES5，这样就可以在老旧的浏览器中使用了（<a href=\"http://kangax.github.io/compat-table/es6/\" target=\"_blank\" rel=\"noopener\">ES2015在新的浏览器的支持</a>还是很喜人的）。我们需要 Babel 及其附属来配合 webpack 工作，至少需要 <a href=\"https://www.npmjs.com/package/babel-core\" target=\"_blank\" rel=\"noopener\">babel-core</a>（Babel的核心，承担大部分工作）、<a href=\"https://www.npmjs.com/package/babel-loader\" target=\"_blank\" rel=\"noopener\">babel-loader</a>（基于 babel-core 的 webpack loader）、<a href=\"https://www.npmjs.com/package/babel-loader\" target=\"_blank\" rel=\"noopener\">babel-preset-2015</a>（包含了 ES2015 编译到 ES5 的规则），我们还需要 <a href=\"https://www.npmjs.com/package/babel-plugin-transform-runtime\" target=\"_blank\" rel=\"noopener\">babel-plugin-transform-runtime</a>和<a href=\"https://www.npmjs.com/package/babel-polyfill\" target=\"_blank\" rel=\"noopener\">babel-polyfill</a>。这俩都是用来在你的代码加 polyfill 或者添加 helper 方法，用途差不多。不过我全部添加到项目里，你会看见他们是如何工作的，如果你想更多的了解他们，请求阅读文档： <a href=\"http://babeljs.io/docs/usage/polyfill/\" target=\"_blank\" rel=\"noopener\">polyfill</a> 和 <a href=\"http://babeljs.io/docs/plugins/transform-runtime/\" target=\"_blank\" rel=\"noopener\">runtime transform</a>。</p>\n<p>一股脑的安装：<code>npm i -D babel-core babel-loader babel-preset-es2015 babel-plugin-transform-runtime babel-polyfill</code>，然后在配置文件中使用他们，首先需要一块地方配置 loaders，更新你的 webpack.config.js：</p>\n<pre><code class=\"language-js\">module.exports = {\n    entry: './src/main.js',\n    output: {\n        path: './dist',\n        filename: 'bundle.js'\n    },\n    module: {\n        rules: [\n            …\n        ]\n    }\n};\n</code></pre>\n<p>我们添加了一个属性 <code>module</code>，里面包含 <code>rules</code> 属性，rules属性是一个数组，包含了你所用的的所有 loader 的配置。接下来我们会在这里添加 babel-loader，对每个 loader 来说，我们至少需要设置两个选项：<code>test</code> 和 <code>loader</code>，<code>test</code> 通常是一个正则表达式，来匹配每个文件的绝对路径，不过一般我们只是匹配文件的扩展名，例如，<code>/\\.js$/</code> 匹配扩展名为 <code>.js</code> 的文件；如果你想在应用中使用 React，设置 <code>/\\.jsx?$/</code>，就会匹配 <code>.js</code> 和 <code>.jsx</code>。现在我们需要设置 <code>loader</code>，也就是 <code>test</code> 匹配到的文件需要使用的 loader。</p>\n<p>loader 通过传入 loader 的名字来指定，loader 的名字有短横线分割，比如 <code>'babel-loader!eslint-loader'</code>。webpack 从右向左读取，<code>esling-loader</code> 会先于 <code>babel-loader</code> 执行。如果你想给 loader 设置选项，使用查询字符串语法。例如给 babel 设置 <code>fakeoption</code> 为 <code>true</code>，我们需要把之前的例子改为 <code>babel-loader?fakeoption=true!eslint-loader</code>，你也可以使用 <code>use</code> 选项传入 loaders 的数组，如果你觉得这样更加简单更加易读。例如，最后的一个例子就变成：<code>use: ['babel-loader?fakeoption=true', 'eslint-loader']</code>，如果你增强可读性，可以写成多行。</p>\n<p><em>译者注: 上文其实是 webpack1 和 webpack2 的区别：<a href=\"https://doc.webpack-china.org/guides/migrating/#-loaders\" target=\"_blank\" rel=\"noopener\">https://doc.webpack-china.org/guides/migrating/#-loaders</a></em></p>\n<p>因为我们只用到了 babel-loader，loader 的配置如下：</p>\n<pre><code class=\"language-js\">rules: [\n    { test: /\\.jsx?$/, loader: 'babel-loader' }\n]\n</code></pre>\n<p>如果只用到了一个 loader，这里有另外一种方式去设置 loader 的选项，不是之前提到的查询字符串的方式：使用 <code>options</code> 选项，它可以使用 key-value 的形式，对于例子中的 <code>fakeOptions</code>，我们可以这样配置：</p>\n<pre><code class=\"language-js\">rules: [\n    {\n        test: /\\.jsx?$/,\n        loader: 'babel-loader',\n        options: {\n            fakeoption: true\n        }\n    }\n]\n</code></pre>\n<p>我们用这种语法来为 babel-loader 设置几个选项</p>\n<pre><code class=\"language-js\">rules: [\n    {\n        test: /\\.jsx?$/,\n        loader: 'babel-loader',\n        options: {\n            plugins: ['transform-runtime'],\n            presets: ['es2015']\n        }\n    }\n]\n</code></pre>\n<p>我们设置了 <code>presets</code> ，这样所有的 ES2015的特性都会被编译为 ES5，我们还设置了 transform-runtime 插件。上文提到，这个插件不是必需的，在这里只是展示如何使用它。另一种方式是使用 <code>.babelrc</code> 来配置这些选项，但这样我就不能给你们展示如何在 webpack 中配置了。通常来说，我还是建议使用 <code>.babelrc</code>，但在我们的项目中还是保持在 webpack 中配置。</p>\n<p>还有一件配置需要告诉 babel-loader。我们需要告诉 babel 不要处理 <code>node_modules</code> 目录，这样可以提高打包速速。增加 <code>exclude</code> 选项，告诉 loader 不要处理这个目录下的文件。<code>exclude</code> 也是一个正则表达式，所以我们设置为 <code>/node_modules/</code>：</p>\n<pre><code class=\"language-js\">rules: [\n    {\n        test: /\\.jsx?$/,\n        loader: 'babel-loader',\n        exclude: /node_modules/,\n        options: {\n            plugins: ['transform-runtime'],\n            presets: ['es2015']\n        }\n    }\n]\n</code></pre>\n<p>此外，也可以使用 <code>include</code> 的属性，表示我们只是用 <code>src</code> 目录，不过我想还是先不这么做。重新执行 <code>npm start</code>，得到可以在浏览器运行的 ES5 代码。如果你决定使用 <code>babel-polyfill</code> 代替 transform-runtime 插件，你需要做一些改变。首先，删除 <code>plugins: ['transform-runtime]</code>（如果之后你也不需要它了，可以通过 npm 卸载掉），然后修改 webpack 的 <code>entry</code>：</p>\n<pre><code class=\"language-js\">entry: [\n    'babel-polyfill',\n    './src/main.js'\n],\n</code></pre>\n<p>我们使用一个数组声明了多入口文件，而不是单一入口，新的入口文件就是这个 polyfill。这样就可以使得 polyfill 在打包文件之前，这样就保证了在我们处理代码之前，polyfill是存在的。</p>\n<p>如果不在配置文件中配置，我们需要在 <code>src/main.js</code> 的文件头部添加一行 <code>import 'babel-polyfill;</code>，和在配置文件中效果是一样的。我之所以放在配置文件中是因为在最后一个例子中会用到，并且这也是一个展示合并多个入口文件到一个文件的好例子。好了，这就是 <code>example3</code> 分支的所有内容，再一次运行 <code>npm start</code> 验证一下。</p>\n<h2 id=\"使用-handlebars-loader\">使用 Handlebars Loader</h2>\n<p>让我们添加另外一个 loader：Handlebars loader，Handlebars loader会把模板编译为一个方法，当你引入一个 handlebars 模板的时候，这个编译后的方法会被引入 JavaScript 文件中，这也是我喜欢 loaders 的一个原因：你可以引入非 JavaScript 文件，当它们全部打包后，可以和 JavaScript 以前使用。另一个例子是你可以使用 loader 引入一个图片，并且可以把图片转换为 base64 编码的 url，JavaScript 就可以把它内联到页面中。如果你把多个 loader 串联起来，其中一个 loader 甚至可以对图片进行优化到一个比较小的尺寸。</p>\n<p>通常来说，首先需要安装 loader：<code>npm install -D handlebars-loader</code>。使用之前，要先安装 HandleBars：<code>npm install -D handlebars</code>。这样你就可以控制 Handlebars 的版本，而不用去同步 loader 的版本，做到单独升级。</p>\n<p>现在我们都安装了，在<code>src</code>目录下创建一个 <code>numberlist.hbs</code> 模板文件：<br>\n<em>译者注：因为模板会导致博客解析错误，所以我给两个大括号之前加了斜线。。。</em></p>\n<pre><code class=\"language-html\">&lt;ul&gt;\n  {\\{#each numbers as |number i|}}\n    &lt;li&gt;{{number}}&lt;/li&gt;\n  {\\{/each}}\n&lt;/ul&gt;\n</code></pre>\n<p>这个模板接受一个数组（从变量名字来看是个数字，当然不是数字也能用），创建一个无序的列表。</p>\n<p>现在调整 JavaScript 文件，使用这个模板输出一个列表，而不是仅仅打印到控制台上，<code>main.js</code> 现在看起来是这样：</p>\n<pre><code class=\"language-js\">import { map } from 'lodash';\nimport template from './numberlist.hbs';\n\nlet numbers = map([1,2,3,4,5,6], n =&gt; n*n);\n\nconsole.log(template({numbers}));\n</code></pre>\n<p>遗憾的是，现在并不能正常工作，因为 webpack 不能识别 <code>numberslist.hbs</code>，它不是 JavaScript 文件。我们可以在 <code>import</code> 语句中添加一点东西来使用 Handlebars loader：</p>\n<pre><code class=\"language-js\">import { map } from 'lodash';\nimport template from 'handlebars-loader!./numberlist.hbs';\n\nlet numbers = map([1,2,3,4,5,6], n =&gt; n*n);\n\nconsole.log(template({numbers}));\n</code></pre>\n<p>通过在文件路径的前面加一个 loader 的名字，用惊叹号分割开，这样 webpack 就能使用 loader 来处理这个文件了。这样做的话，我们不用在配置文件中做任何事情。然而，在一个大型项目中，你可能加载多个模板，所以在配置文件中做会更有效，这样就不用对每个加载的模板路径前面加上 <code>handlebars!</code>，更新配置为：</p>\n<pre><code class=\"language-js\">rules: [\n    {/* babel loader config… */},\n    { test: /\\.hbs$/, loader: 'handlebars-loader' }\n]\n</code></pre>\n<p>很简单。我们要做的就是告诉 webpack 使用 handlerbars-loader 来处理所有 <code>.hbs</code> 后缀的文件。这样我们就做完了 <code>example4</code> 分支中的所有事情，现在运行 <code>npm start</code>，你会看见 webpack 打包输出：</p>\n<pre><code class=\"language-html\">&lt;ul&gt;\n&lt;li&gt;1&lt;/li&gt;\n&lt;li&gt;4&lt;/li&gt;\n&lt;li&gt;9&lt;/li&gt;\n&lt;li&gt;16&lt;/li&gt;\n&lt;li&gt;25&lt;/li&gt;\n&lt;li&gt;36&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n<hr>\n<p>文章是在太长，分成上下两部分。<br>\n原文地址：<a href=\"https://www.smashingmagazine.com/2017/02/a-detailed-introduction-to-webpack/\" target=\"_blank\" rel=\"noopener\">A Detailed Introduction To Webpack</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>JavaScript 模块打包工具已经出现有一段时间了。RequireJS 在2009年完成了第一次提交，然后 Browserify 随之出现，从那时候起相继出现了各种模块打包工具。在这些里面，<em>webpack</em>脱颖而出。如果你还不熟悉它，我希望这篇文章可以帮你开始使用这个强大的工具。</p>\n<h2 id=\"什么是模块打包工具\">什么是模块打包工具</h2>\n<p>在大多数语言中（包括 ECMAScript 2015+，JavaScript 的最新标准，但还没有被浏览器广泛支持），你可以将代码分割成多个文件，然后将这些文件导入到你的应用中，来使用他们所包含的功能。浏览器并没有内建这样的功能，所以模块打包工具如果要实现这些功能，有以下几种方式：异步加载模块，在加载完成后执行；或者是将所有需要的文件合并成一个 JavaScript 文件，在 HTML 里通过 <code>&lt;script&gt;</code> 标签加载。</p>\n<p>不使用模块管理和打包工具，你也可以手动合并你的文件，然后使用数不清的 <code>&lt;script&gt;</code> 标签引入，不过这样做缺点也很明显：</p>\n<ul>\n<li>你需要保证需要加载的文件的顺序，包括文件的依赖关系以及你要保证不要加载那些你不需要的文件。</li>\n<li>越多的 <code>&lt;script&gt;</code> 的标签意味着要加载你的代码需要更多的服务器请求，影响性能。</li>\n<li>很明显，这需要大量的手动操作，而不是让计算机来做处理。</li>\n</ul>\n<p>大多数的模块打包工具可以很简单的和 npm 或者 Bower 集成，这样你就可以为你的应用添加第三方依赖。你只需要安装并且用一行代码导入到你的应用中。然后运行打包工具，你的应用代码就和第三方代码合并到一起；或者你配置正确，你可以把你所有的依赖代码打包到另外一个文件里，这样当你更新了应用的代码，用户更新应用代码的缓存时候，就不必重新下载这些依赖库的代码。</p>\n<h2 id=\"为什么选择-webpack\">为什么选择 Webpack</h2>\n<p>现在你已经基本了解 webpack 的作用了，但为什么你要选择 webpack，有这么几个原因：</p>\n<ul>\n<li>其中一个优势是相对来说它比较新，所以它能够避免之前的工具们存在的一些缺陷和问题。</li>\n<li>上手简单。如果你只是想要把所有 JavaScript 文件打包成一个文件，而不做其他事情，你甚至都不需要配置文件。</li>\n<li>它的插件系统可以做更多的事情，使得它更加强大，所以，或许构建工具，一个 webpack 足够了。</li>\n</ul>\n<p>我见过一些其他和 webpack 功能类似的打包和构建工具，但 webpack 更胜一筹：当你遇到困难时你可以去庞大的社区寻找帮助。Browserify 的社区也挺大，但是它缺少一些 webpack 具有的潜在的必需的特性。我把所有的赞誉都给了 webpack，你们一定等我开始 show my code 了，开始吧 ~</p>\n<h2 id=\"安装-webpack\">安装 Webpack</h2>\n<p>在使用 webpack 之前，我们首先需要安装它。我假设你已经安装了 Nodejs 和 npm，如果你还没安装他们，查看 <a href=\"https://nodejs.org/\" target=\"_blank\" rel=\"noopener\">Nodejs 官网</a>。</p>\n<p>有两种方式来安装 webpack（其实其他命令行程序也是一样）：全局安装和局部安装。如果你选择全局安装，你可以在任意目录下使用，但是它不会作为你局部依赖存在，并且你不能在不同的项目之间切换 webpack 的版本（一些项目可能需要更新一点的版本，你可能不得不等一等再升级）。所以对于命令行程序我更倾向于局部安装，然后使用相对路径或者 <a href=\"https://docs.npmjs.com/misc/scripts\" target=\"_blank\" rel=\"noopener\">npm scripts</a> 来运行程序。如果你没有局部安装过命令行程序，你可以读一下我写的一篇文章，关于摆脱<a href=\"https://www.joezimjs.com/javascript/no-more-global-npm-packages/\" target=\"_blank\" rel=\"noopener\">全局安装 npm 包</a>。</p>\n<p>接下来我们会使用 npm scripts 来进行我们的例子，所以我们依然局部安装 webpack。首先为了试验和学习 webpack，我们先创建一个目录。你可以克隆我 <a href=\"https://github.com/joezimjs/webpack-Introduction-Tutorial\" target=\"_blank\" rel=\"noopener\">github 上的仓库</a>，在接下来的学习中你可以切换分支；或者你可以重新创建一个新的项目，然后使用我仓库中的代码作为比较。</p>\n<p>通过命令行进入你的项目目录，使用 <code>npm init</code> 初始化项目，除非你要把项目发布到 npm 上，否则，你填入什么项目信息并不重要。</p>\n<p>这时候你项目里增加了一个 <code>package.json</code> 文件（通过<code>npm init</code>创建），你可以把依赖保存在这里。所以我们使用 npm 安装 webpack 为项目的一个依赖项：<code>npm install webpack -D</code>。（使用 <code>-D</code> 代表这是一个开发依赖，保存在 <code>package.json</code> 的 <code>devDependencies</code> 里，你也可以使用 <code>--save-dev</code> ）。</p>\n<p>在使用 webpack 在之前，我们需要创建一个简单的应用。首先我们安装 <a href=\"http://www.lodash.com/\" target=\"_blank\" rel=\"noopener\">lodash</a>，这样我们的应用就有一个依赖：<code>npm install lodash -S</code>（<code>-S</code> 同 <code>--save</code>），然后我们创建一个名为 <code>src</code> 的目录，在里面创建一个文件： <code>main.js</code>：</p>\n<pre><code class=\"language-js\">var map = require('lodash/map');\n\nfunction square(n) {\n    return n*n;\n}\n\nconsole.log(map([1,2,3,4,5,6], square));\n</code></pre>\n<p>很简单对不对？我们创建一个从1到6的数字数据，然后使用 loadsh 的 map 方法将原数组每一项平方得到一个新的数组。最后我们通过 console 打印出新数组。这个文件可以使用 Nodejs 运行，运行 <code>node src/main.js</code> 输出结果为 <code>[ 1, 4, 9, 16, 25, 36 ]</code>。</p>\n<p>但是我们想将这段短小的代码和我们需要的 lodash 代码打包，并且可以在浏览器运行，webpack 可以做到么？我们该怎么做？</p>\n<h2 id=\"使用-webpack-命令行\">使用 Webpack 命令行</h2>\n<p>使用 webpack 最简单的方法就是直接命令行运行，而不用去花费时间去写一个配置文件。最简单的 webpack 命令行，不必使用配置文件，只需要输入文件路径和输出文件路径两个参数。Webpack 会读取输入文件，遍历依赖树，将所有文件打包成一个文件，输出到你指定的输出文件路径。在这个例子中，我们的输入路径是 <code>src/main.js</code>，我们想把打包文件输出到 <code>dist/bundle.js</code>，所以我们来创建一个 npm scripts 来做这件事情（我们没有全局安装 webpack，所有不能直接从命令行运行），在 <code>package.json</code> 中，编辑 <code>scripts</code> ：</p>\n<pre><code class=\"language-json\">&quot;scripts&quot;: {\n&quot;build&quot;: &quot;webpack src/main.js dist/bundle.js&quot;\n}\n</code></pre>\n<p>现在，运行 <code>npm run build</code>，webpack开始工作，当运行完毕——不会很长时间——会生成一个新的 <code>dist/bundle.js</code> 文件。你可以在 nodejs 或者 浏览器中运行打包后的文件，你会得到同样的输出结果。</p>\n<p>在继续探索 webpack 之前，我们先完善一下构建脚本：重新构建之前先删除 <code>dist</code> 目录及其内容，并且增加一些脚本来运行打包后的文件。首先我们安装 <code>del-cli</code> 来删除目录，这样不会让使用不同系统的人感到苦恼（不要恨我，我用的 windows）；运行<code>npm install -D</code>安装。然后我们更新 npm scripts：</p>\n<pre><code class=\"language-json\">&quot;scripts&quot;: {\n  &quot;prebuild&quot;: &quot;del-cli dist -f&quot;,\n  &quot;build&quot;: &quot;webpack src/main.js dist/bundle.js&quot;,\n  &quot;execute&quot;: &quot;node dist/bundle.js&quot;,\n  &quot;start&quot;: &quot;npm run build -s &amp;&amp; npm run execute -s&quot;\n}\n</code></pre>\n<p><code>build</code> 命令和之前一样，增加了 <code>prebuild</code> 来做一些清理工作，这个命令每次都会先于 <code>build</code> 运行，同时增加 <code>execute</code> 命令，使用 nodejs 运行打包后的脚本。然后使用 <code>start</code> 运行所有的命令（<code>-s</code> 可以让 npm scripts 不会输出一些无用的信息）。运行 <code>npm srart</code>，你可以看到 webpack 的输出，开平方后的数组打印在了控制台上。恭喜你，你完成了之前我提高的仓库的 <code>example1</code> 分支的所有工作。</p>\n<h2 id=\"使用配置文件\">使用配置文件</h2>\n<p>虽然我们愉快的使用命令开始使用 webpack，但当我们开始使用 webpack 更多的特性的时候，你会把所有传进命令行的配置项都移入配置文件中，使用配置文件，功能更强大，代码更加易读。因为它是用 JavaScript 写成的。</p>\n<p>让我们创建一个配置文件。在你项目的根目录，创建一个名为 <code>webpack.config.js</code> 的文件，这是 webpack 默认查找的文件。你也可以给 webpack 传入 <code>--config [filename]</code>，告诉 webpack你想使用不同名字或者其他目录的配置文件。</p>\n<p>在本教程中，我们使用标准的文件名。现在我们使用配置文件来完成上面我们使用命令行完成的任务。我们在配置文件中添加几行代码：</p>\n<pre><code class=\"language-js\">module.exports = {\n    entry: './src/main.js',\n    output: {\n        path: './dist',\n        filename: 'bundle.js'\n    }\n};\n</code></pre>\n<p>就像在命令行中一样，我们指明了输出文件和输入文件。这是一个 JavaScript 文件，不是 JSON，所有我们需要到处配置对象 - 使用 <code>module.exports</code>。现在可能看起来不如命令行中优雅，不过读到文章最后，你会对这个决定感到欣喜的。</p>\n<p>现在我们可以从 <code>package.json</code> 中移除传给 webpack 的命令行参数了，你的 scripts 看起来应该是这样：</p>\n<pre><code class=\"language-json\">&quot;scripts&quot;: {\n  &quot;prebuild&quot;: &quot;del-cli dist -f&quot;,\n  &quot;build&quot;: &quot;webpack&quot;,\n  &quot;execute&quot;: &quot;node dist/bundle.js&quot;,\n  &quot;start&quot;: &quot;npm run build -s &amp;&amp; npm run execute -s&quot;\n}\n</code></pre>\n<p>你依然可以运行 <code>npm start</code>，并得到相同的结果。这样我们就完成了 <code>example2</code> 分支的内容。</p>\n<h2 id=\"使用-loaders\">使用 Loaders</h2>\n<p>主要有两种方法来增强 Webpack 的能力：loaders 和 plugins。插件我们将稍后讨论。现在我们将关注点放在 loaders 上，loaders 可以用来对特定类型的文件进行转化和操作。你可以将多个 loader 串起来对同一个文件进行处理。例如，你可以使用 <a href=\"http://eslint.org/\" target=\"_blank\" rel=\"noopener\">ESLint</a>对所有扩展名是 <code>.js</code> 的文件进行检查，并且使用 <a href=\"https://babeljs.io/\" target=\"_blank\" rel=\"noopener\">Babel</a>将他们从 ES2015 的语法编译为 ES5，如果 ESLint 出现警告就会在控制台打印出来，如果遇到错误，就会中断 Webpack 操作。</p>\n<p>说回我们的小程序，我们不会安装任何检查工具，但我们会安装 Babel，把我们的代码编译为 ES5。当然，我们需要先写点 ES2015 的代码，我们把 <code>main.js</code> 的内容改为：</p>\n<pre><code class=\"language-js\">import { map } from 'lodash';\n\nconsole.log(map([1,2,3,4,5,6], n =&gt; n*n));\n</code></pre>\n<p>这段代码本质上做了和之前相同的事情，但是（1）我们使用了箭头函数，而不是名为<code>square</code>的方法，并且（2）我们使用了 <code>import</code> 语法来引入的 lodash 的 map 方法。这样就会把整个 lodash 文件打包进来，而不是通过 <code>lodash/map</code> 只引入 <code>map</code> 相关的方法。如果你愿意，你可以把代码第一行改为 <code>import map from lodash/map</code> , 但是我这么做有这么几点原因：</p>\n<ul>\n<li>在大型应用中，你或许会引入很大块的lodash，这和全部引入也差不多。</li>\n<li>如果你使用 Backbone.js，很难做到每次单独引入方法，因为没有文档告诉你 Backbone.js 到底需要多少个方法。</li>\n<li>在下一个版本的 webpack 中，会引入一项新的技术 - tree-shaking，可以排除掉没有用到的模块，所以还是达到了上面的目的。</li>\n<li>我想把这个作为例子，来告诉你刚才我提到的这一点（<em>译者注： 应该是 tree-shaking 这一点</em>）。</li>\n</ul>\n<p>（注意：Lodash 可以使用上述两种方法引入，是因为它的开发者使之可以这么做，而不是所有的库都可以这么做）</p>\n<p>不管怎么说，我们使用了一些 ES2015 的语法，我们需要将其编译为 ES5，这样就可以在老旧的浏览器中使用了（<a href=\"http://kangax.github.io/compat-table/es6/\" target=\"_blank\" rel=\"noopener\">ES2015在新的浏览器的支持</a>还是很喜人的）。我们需要 Babel 及其附属来配合 webpack 工作，至少需要 <a href=\"https://www.npmjs.com/package/babel-core\" target=\"_blank\" rel=\"noopener\">babel-core</a>（Babel的核心，承担大部分工作）、<a href=\"https://www.npmjs.com/package/babel-loader\" target=\"_blank\" rel=\"noopener\">babel-loader</a>（基于 babel-core 的 webpack loader）、<a href=\"https://www.npmjs.com/package/babel-loader\" target=\"_blank\" rel=\"noopener\">babel-preset-2015</a>（包含了 ES2015 编译到 ES5 的规则），我们还需要 <a href=\"https://www.npmjs.com/package/babel-plugin-transform-runtime\" target=\"_blank\" rel=\"noopener\">babel-plugin-transform-runtime</a>和<a href=\"https://www.npmjs.com/package/babel-polyfill\" target=\"_blank\" rel=\"noopener\">babel-polyfill</a>。这俩都是用来在你的代码加 polyfill 或者添加 helper 方法，用途差不多。不过我全部添加到项目里，你会看见他们是如何工作的，如果你想更多的了解他们，请求阅读文档： <a href=\"http://babeljs.io/docs/usage/polyfill/\" target=\"_blank\" rel=\"noopener\">polyfill</a> 和 <a href=\"http://babeljs.io/docs/plugins/transform-runtime/\" target=\"_blank\" rel=\"noopener\">runtime transform</a>。</p>\n<p>一股脑的安装：<code>npm i -D babel-core babel-loader babel-preset-es2015 babel-plugin-transform-runtime babel-polyfill</code>，然后在配置文件中使用他们，首先需要一块地方配置 loaders，更新你的 webpack.config.js：</p>\n<pre><code class=\"language-js\">module.exports = {\n    entry: './src/main.js',\n    output: {\n        path: './dist',\n        filename: 'bundle.js'\n    },\n    module: {\n        rules: [\n            …\n        ]\n    }\n};\n</code></pre>\n<p>我们添加了一个属性 <code>module</code>，里面包含 <code>rules</code> 属性，rules属性是一个数组，包含了你所用的的所有 loader 的配置。接下来我们会在这里添加 babel-loader，对每个 loader 来说，我们至少需要设置两个选项：<code>test</code> 和 <code>loader</code>，<code>test</code> 通常是一个正则表达式，来匹配每个文件的绝对路径，不过一般我们只是匹配文件的扩展名，例如，<code>/\\.js$/</code> 匹配扩展名为 <code>.js</code> 的文件；如果你想在应用中使用 React，设置 <code>/\\.jsx?$/</code>，就会匹配 <code>.js</code> 和 <code>.jsx</code>。现在我们需要设置 <code>loader</code>，也就是 <code>test</code> 匹配到的文件需要使用的 loader。</p>\n<p>loader 通过传入 loader 的名字来指定，loader 的名字有短横线分割，比如 <code>'babel-loader!eslint-loader'</code>。webpack 从右向左读取，<code>esling-loader</code> 会先于 <code>babel-loader</code> 执行。如果你想给 loader 设置选项，使用查询字符串语法。例如给 babel 设置 <code>fakeoption</code> 为 <code>true</code>，我们需要把之前的例子改为 <code>babel-loader?fakeoption=true!eslint-loader</code>，你也可以使用 <code>use</code> 选项传入 loaders 的数组，如果你觉得这样更加简单更加易读。例如，最后的一个例子就变成：<code>use: ['babel-loader?fakeoption=true', 'eslint-loader']</code>，如果你增强可读性，可以写成多行。</p>\n<p><em>译者注: 上文其实是 webpack1 和 webpack2 的区别：<a href=\"https://doc.webpack-china.org/guides/migrating/#-loaders\" target=\"_blank\" rel=\"noopener\">https://doc.webpack-china.org/guides/migrating/#-loaders</a></em></p>\n<p>因为我们只用到了 babel-loader，loader 的配置如下：</p>\n<pre><code class=\"language-js\">rules: [\n    { test: /\\.jsx?$/, loader: 'babel-loader' }\n]\n</code></pre>\n<p>如果只用到了一个 loader，这里有另外一种方式去设置 loader 的选项，不是之前提到的查询字符串的方式：使用 <code>options</code> 选项，它可以使用 key-value 的形式，对于例子中的 <code>fakeOptions</code>，我们可以这样配置：</p>\n<pre><code class=\"language-js\">rules: [\n    {\n        test: /\\.jsx?$/,\n        loader: 'babel-loader',\n        options: {\n            fakeoption: true\n        }\n    }\n]\n</code></pre>\n<p>我们用这种语法来为 babel-loader 设置几个选项</p>\n<pre><code class=\"language-js\">rules: [\n    {\n        test: /\\.jsx?$/,\n        loader: 'babel-loader',\n        options: {\n            plugins: ['transform-runtime'],\n            presets: ['es2015']\n        }\n    }\n]\n</code></pre>\n<p>我们设置了 <code>presets</code> ，这样所有的 ES2015的特性都会被编译为 ES5，我们还设置了 transform-runtime 插件。上文提到，这个插件不是必需的，在这里只是展示如何使用它。另一种方式是使用 <code>.babelrc</code> 来配置这些选项，但这样我就不能给你们展示如何在 webpack 中配置了。通常来说，我还是建议使用 <code>.babelrc</code>，但在我们的项目中还是保持在 webpack 中配置。</p>\n<p>还有一件配置需要告诉 babel-loader。我们需要告诉 babel 不要处理 <code>node_modules</code> 目录，这样可以提高打包速速。增加 <code>exclude</code> 选项，告诉 loader 不要处理这个目录下的文件。<code>exclude</code> 也是一个正则表达式，所以我们设置为 <code>/node_modules/</code>：</p>\n<pre><code class=\"language-js\">rules: [\n    {\n        test: /\\.jsx?$/,\n        loader: 'babel-loader',\n        exclude: /node_modules/,\n        options: {\n            plugins: ['transform-runtime'],\n            presets: ['es2015']\n        }\n    }\n]\n</code></pre>\n<p>此外，也可以使用 <code>include</code> 的属性，表示我们只是用 <code>src</code> 目录，不过我想还是先不这么做。重新执行 <code>npm start</code>，得到可以在浏览器运行的 ES5 代码。如果你决定使用 <code>babel-polyfill</code> 代替 transform-runtime 插件，你需要做一些改变。首先，删除 <code>plugins: ['transform-runtime]</code>（如果之后你也不需要它了，可以通过 npm 卸载掉），然后修改 webpack 的 <code>entry</code>：</p>\n<pre><code class=\"language-js\">entry: [\n    'babel-polyfill',\n    './src/main.js'\n],\n</code></pre>\n<p>我们使用一个数组声明了多入口文件，而不是单一入口，新的入口文件就是这个 polyfill。这样就可以使得 polyfill 在打包文件之前，这样就保证了在我们处理代码之前，polyfill是存在的。</p>\n<p>如果不在配置文件中配置，我们需要在 <code>src/main.js</code> 的文件头部添加一行 <code>import 'babel-polyfill;</code>，和在配置文件中效果是一样的。我之所以放在配置文件中是因为在最后一个例子中会用到，并且这也是一个展示合并多个入口文件到一个文件的好例子。好了，这就是 <code>example3</code> 分支的所有内容，再一次运行 <code>npm start</code> 验证一下。</p>\n<h2 id=\"使用-handlebars-loader\">使用 Handlebars Loader</h2>\n<p>让我们添加另外一个 loader：Handlebars loader，Handlebars loader会把模板编译为一个方法，当你引入一个 handlebars 模板的时候，这个编译后的方法会被引入 JavaScript 文件中，这也是我喜欢 loaders 的一个原因：你可以引入非 JavaScript 文件，当它们全部打包后，可以和 JavaScript 以前使用。另一个例子是你可以使用 loader 引入一个图片，并且可以把图片转换为 base64 编码的 url，JavaScript 就可以把它内联到页面中。如果你把多个 loader 串联起来，其中一个 loader 甚至可以对图片进行优化到一个比较小的尺寸。</p>\n<p>通常来说，首先需要安装 loader：<code>npm install -D handlebars-loader</code>。使用之前，要先安装 HandleBars：<code>npm install -D handlebars</code>。这样你就可以控制 Handlebars 的版本，而不用去同步 loader 的版本，做到单独升级。</p>\n<p>现在我们都安装了，在<code>src</code>目录下创建一个 <code>numberlist.hbs</code> 模板文件：<br>\n<em>译者注：因为模板会导致博客解析错误，所以我给两个大括号之前加了斜线。。。</em></p>\n<pre><code class=\"language-html\">&lt;ul&gt;\n  {\\{#each numbers as |number i|}}\n    &lt;li&gt;{{number}}&lt;/li&gt;\n  {\\{/each}}\n&lt;/ul&gt;\n</code></pre>\n<p>这个模板接受一个数组（从变量名字来看是个数字，当然不是数字也能用），创建一个无序的列表。</p>\n<p>现在调整 JavaScript 文件，使用这个模板输出一个列表，而不是仅仅打印到控制台上，<code>main.js</code> 现在看起来是这样：</p>\n<pre><code class=\"language-js\">import { map } from 'lodash';\nimport template from './numberlist.hbs';\n\nlet numbers = map([1,2,3,4,5,6], n =&gt; n*n);\n\nconsole.log(template({numbers}));\n</code></pre>\n<p>遗憾的是，现在并不能正常工作，因为 webpack 不能识别 <code>numberslist.hbs</code>，它不是 JavaScript 文件。我们可以在 <code>import</code> 语句中添加一点东西来使用 Handlebars loader：</p>\n<pre><code class=\"language-js\">import { map } from 'lodash';\nimport template from 'handlebars-loader!./numberlist.hbs';\n\nlet numbers = map([1,2,3,4,5,6], n =&gt; n*n);\n\nconsole.log(template({numbers}));\n</code></pre>\n<p>通过在文件路径的前面加一个 loader 的名字，用惊叹号分割开，这样 webpack 就能使用 loader 来处理这个文件了。这样做的话，我们不用在配置文件中做任何事情。然而，在一个大型项目中，你可能加载多个模板，所以在配置文件中做会更有效，这样就不用对每个加载的模板路径前面加上 <code>handlebars!</code>，更新配置为：</p>\n<pre><code class=\"language-js\">rules: [\n    {/* babel loader config… */},\n    { test: /\\.hbs$/, loader: 'handlebars-loader' }\n]\n</code></pre>\n<p>很简单。我们要做的就是告诉 webpack 使用 handlerbars-loader 来处理所有 <code>.hbs</code> 后缀的文件。这样我们就做完了 <code>example4</code> 分支中的所有事情，现在运行 <code>npm start</code>，你会看见 webpack 打包输出：</p>\n<pre><code class=\"language-html\">&lt;ul&gt;\n&lt;li&gt;1&lt;/li&gt;\n&lt;li&gt;4&lt;/li&gt;\n&lt;li&gt;9&lt;/li&gt;\n&lt;li&gt;16&lt;/li&gt;\n&lt;li&gt;25&lt;/li&gt;\n&lt;li&gt;36&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n<hr>\n<p>文章是在太长，分成上下两部分。<br>\n原文地址：<a href=\"https://www.smashingmagazine.com/2017/02/a-detailed-introduction-to-webpack/\" target=\"_blank\" rel=\"noopener\">A Detailed Introduction To Webpack</a></p>\n"},{"layout":"post","title":"如何使用 ES6 中的参数","banner":"assets/img/es6.jpg","label":"译","_content":"\nECMAScript 6（或者叫 ECMAScript 2015）是 ECMAScript 的最新标准，极大的提高了 JavaScript 中处理参数的能力。现在我们可以使用 rest 参数（rest parameters）、默认值（default values）和解构（destructuring）以及其他许多新的特性。本文我们将探索参数(arguments)和参数(parameter)的方方面面，看一下ES6是如何对他们改进和提升的。\n\n## Arguments 和 Parameters \n\narguments 和 Parameters 的含义通常是可以互换的。尽管如此，为了本文的目标，还是要做出区分。在大多数的标准中，函数声明时给出的叫做 parameters（或者叫 formal parameters），而传递给函数的叫做的 arguments（或者叫 actual arguments），看下面的函数：\n\n```js\nfunction foo(param1, param2) {\n    // do something\n}\nfoo(10, 20);\n```\n\n在这个函数中，`param1` 和 `param2` 是函数的 parameters，而传递给函数的值（`10` 和 `20`）是 arguments。\n\n**译者注：本文后面不再区分 arguments 和 parameters，统一译作参数。:joy:**\n\n## 扩展运算符（...) \n\n在 ES5 中，`apply()` 方法可以很方便将数组作为参数传递给函数，经常用于使用 `Math.max()` 来取得数组的最大值。看下面的代码段：\n\n```js\nvar myArray = [5, 10, 50];\nMath.max(myArray);    // Error: NaN\nMath.max.apply(Math, myArray);    // 50\n```\n\n\n`Math.max()` 方法不支持数组，只接受数字作为参数。当数组传递给函数，函数会抛出错误。但是当使用 `apply()` 方法后，数组变成了一个个单独的数组传递给了函数，所以 `Math.max()` 就能够正确的执行了。\n\n幸运的是，ES6 给我们带来了扩展运算符，我们就不必再继续使用 `apply()` 方法了。我们可以将表达式轻松的展开为多个参数。\n\n```js\nvar myArray = [5, 10, 50];\nMath.max(...myArray);    // 50\n```\n\n在这里我们通过扩展运算符将 `myArray` 展开成了一个个单独的值。虽然 ES5 中我们可以通过 `apply()` 方法来模拟扩展运算符，但是语法上让人迷惑，并且缺少可扩展性。扩展运算符不仅易于使用，还带来了许多新的特性。比如，你可以在函数调用时多次使用扩展运算符，并且还可以和其他参数混合在一起。\n\n```js\nfunction myFunction() {\n  for(var i in arguments){\n    console.log(arguments[i]);\n  }\n}\nvar params = [10, 15];\nmyFunction(5, ...params, 20, ...[25]);    // 5 10 15 20 25\n```\n\n扩展运算符另一大好处就是他可以很容易的和构造函数（constructor）一起使用：\n\n```js\nnew Date(...[2016, 5, 6]);    // Mon Jun 06 2016 00:00:00 GMT-0700 (Pacific Daylight Time)\n```\n\n当前我们可以使用 ES5 来重写上面的代码，不过我们需要一个复杂的方法来避免一个类型错误：\n\n```js\nnew Date.apply(null, [2016, 4, 24]);    // TypeError: Date.apply is not a constructor\nnew (Function.prototype.bind.apply(Date, [null].concat([2016, 5, 6])));   // Mon Jun 06 2016 00:00:00 GMT-0700 (Pacific Daylight Time)\n```\n\n## REST 参数\n\nrest 参数和扩展运算符是一样的语法，但是他不是将数组展开成一个个的参数，而是将一个个参数转换为数组。\n\n**译者注：rest 参数和扩展运算符虽然一样的语法，在这里你就可以看出作者强调的 arguments 和 parameters 的区别了。扩展运算符用于函数调用的参数（arguments）中，而 rest 参数用于函数声明的参数（parameters）中。**\n\n```js\nfunction myFunction(...options) {\n     return options;\n}\nmyFunction('a', 'b', 'c');      // [\"a\", \"b\", \"c\"]\n```\n\n如果没有提供参数，rest 参数会被设置为空数组：\n\n```\nfunction myFunction(...options) {\n     return options;\n}\nmyFunction();      // []\n```\n\n当创建可见函数（接受数量可变的参数的函数）的时候，rest 参数就显得十分有用。因为 rest 参数是一个数组，所以可以很方便的替换 `arguments` 对象（将会在下文讨论）。看下面一个使用 ES5 编写的方法：\n\n```js\nfunction checkSubstrings(string) {\n  for (var i = 1; i < arguments.length; i++) {\n    if (string.indexOf(arguments[i]) === -1) {\n      return false;\n    }\n  }\n  return true;\n}\ncheckSubstrings('this is a string', 'is', 'this');   // true\n```\n\n\n这个函数的作用是检查一个字符串是否包含指定的一系列字符串。这个函数的第一个问题就是，我们必须查看函数体才知道函数接受多个参数。另外 `arguments` 的迭代必须从 1 开始，因为 `arguments[0]` 是第一个参数。如果我们稍后给第一参数之后再添加参数，或许我们就忘记更新这个循环了。使用 rest 参数，我们可以很轻易的避开这个问题：\n\n```js\nfunction checkSubstrings(string, ...keys) {\n  for (var key of keys) {\n    if (string.indexOf(key) === -1) {\n      return false;\n    }\n  }\n  return true;\n}\ncheckSubstrings('this is a string', 'is', 'this');   // true\n```\n\n函数的输出和上一个函数一样。再重复一次，`string` 参数作为第一个参数传入，剩下的参数被塞进一个数组并且赋值给了变量 `keys`。\n\n使用 rest 参数代替 `arguments` 不仅提高了代码的可读性，并且避免了 JavaScript 中的[性能问题](https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments)。尽管如此，rest 参数并不能无限制使用，举个例子，它只能是最后一个参数，否则会导致语法错误。\n\n```js\nfunction logArguments(a, ...params, b) {\n        console.log(a, params, b);\n}\nlogArguments(5, 10, 15);    // SyntaxError: parameter after rest parameter\n```\n\n另一个限制方法声明时只允许一个 rest 参数：\n\n```js\nfunction logArguments(...param1, ...param2) {\n}\nlogArguments(5, 10, 15);    // SyntaxError: parameter after rest parameter\n```\n\n\n## 默认值\n\n### ES5 中的默认参数\n\nES5 中 JavaScript 并不支持默认值，但这里有个很简单的实现，使用 `OR`\n运算符（`||`），我们可以很容易的模拟默认参数，看下面的代码：\n\n```js\nfunction foo(param1, param2) {\n   param1 = param1 || 10;\n   param2 = param2 || 10;\n   console.log(param1, param2);\n}\nfoo(5, 5);  // 5 5\nfoo(5);    // 5 10\nfoo();    // 10 10\n```\n\n这个函数期望接收两个参数，但当无参数调用时，它会使用默认值。在函数内，缺失的参数自动设置为 undefined，所以我们检查这些参数，并给他们设置默认值。为了检测缺失的参数并设置默认值，我们使用 `OR` 运算符（`||`）。这个运算符首先检查第一个值，如果是 [truthy](https://developer.mozilla.org/en-US/docs/Glossary/Truthy)，运算符会返回它，否则返回第二个参数。\n\n这种方法在函数内很常用，但也存在瑕疵。如果传递 `0` 或者 `null` 也会返回默认值。因为它们被认为是 falsy 值。所以如果我们确实需要给函数传递 `0` 或者 `null`，我们需要换种方法来检测参数是否缺失：\n\n```js\nfunction foo(param1, param2) {\n  if(param1 === undefined){\n    param1 = 10;\n  }\n  if(param2 === undefined){\n    param2 = 10;\n  }\n  console.log(param1, param2);\n}\nfoo(0, null);    // 0, null\nfoo();    // 10, 10\n```\n\n在这个函数中，通过检查参数的类型是否为 undefined 来确定是否要赋予默认值。这种方法代码量稍微大一些，但更安全，可以让我们给函数传递 `0` 或者 `null`。\n\n### ES6 中的默认参数\n\nES6 中，我们不必再检查参数是否为 undefined 来模拟默认参数，我们可以直接将默认参数函数声明中。\n\n```js\nfunction foo(a = 10, b = 10) {\n  console.log(a, b);\n}\nfoo(5);    // 5 10\nfoo(0, null);    // 0 null\n```\n\n正如你所看到的，忽略参数返回了默认值，但传递 `0` 或者 `null` 并没有。我们甚至可以使用函数来产生参数的默认值：\n\n```js\nfunction getParam() {\n    alert(\"getParam was called\");\n    return 3;\n}\nfunction multiply(param1, param2 = getParam()) {\n    return param1 * param2;\n}\nmultiply(2, 5);     // 10\nmultiply(2);     // 6 (also displays an alert dialog)\n```\n\n需要注意的是，只有缺少第二个参数的时候，`gegParam` 方法才会执行，所以当我们使用两个参数 `multiply()` 的时候并不会弹出 alert。\n\n默认参数另一个有意思的特性是在方法声明是可以引用其他参数和变量作为默认参数：\n\n```js\nfunction myFunction(a=10, b=a) {\n     console.log('a = ' + a + '; b = '  + b);\n}\nmyFunction();     // a=10; b=10\nmyFunction(22);    // a=22; b=22\nmyFunction(2, 4);    // a=2; b=4\n```\n\n甚至可以在函数声明的时候执行操作符：\n\n```js\nfunction myFunction(a, b = ++a, c = a*b) {\n     console.log(c);\n}\nmyFunction(5);    // 36\n```\n\n注意：不像其他语言，JavaScript 是在调用时才计算默认参数的：\n\n```js\nfunction add(value, array = []) {\n  array.push(value);\n  return array;\n}\nadd(5);    // [5]\nadd(6);    // [6], not [5, 6]\n```\n\n## 解构赋值\n\n解构赋值是 ES6 的新特性，让我们可以从数组或者对象中提取值并赋值给变量，语法上类似于对象和数组字面量。当给函数传参时，这种语法清晰且易于理解并且很实用。\n\n在 ES5 中，经常使用配置对象来处理大量的的可选参数，尤其是属性的顺序无关紧要的时候，看下面的函数：\n\n```js\nfunction initiateTransfer(options) {\n    var  protocol = options.protocol,\n        port = options.port,\n        delay = options.delay,\n        retries = options.retries,\n        timeout = options.timeout,\n        log = options.log;\n    // code to initiate transfer\n}\noptions = {\n  protocol: 'http',\n  port: 800,\n  delay: 150,\n  retries: 10,\n  timeout: 500,\n  log: true\n};\ninitiateTransfer(options);\n```\n\n这种模式 JavaScript 开发者经常使用，并且很好用。但我们必须进入函数体内才知道到底需要多少参数，使用解构参数赋值，我们可以在函数声明时很清晰的指定需要的参数。\n\n```js\nfunction initiateTransfer({protocol, port, delay, retries, timeout, log}) {\n     // code to initiate transfer\n};\nvar options = {\n  protocol: 'http',\n  port: 800,\n  delay: 150,\n  retries: 10,\n  timeout: 500,\n  log: true\n}\ninitiateTransfer(options);\n```\n\n在这个函数中，我们使用了对象解构模式，而不是一个配置型对象，让我们的代码更加清晰易读。\n\n我们也可以混用解构参数和普通参数：\n\n```js\nfunction initiateTransfer(param1, {protocol, port, delay, retries, timeout, log}) {\n     // code to initiate transfer\n}\ninitiateTransfer('some value', options);\n```\n\n需要注意，如果函数调用时解构参数缺失会抛出一个类型错误：\n\n```js\nfunction initiateTransfer({protocol, port, delay, retries, timeout, log}) {\n     // code to initiate transfer\n}\ninitiateTransfer();  // TypeError: Cannot match against 'undefined' or 'null'\n```\n\n当我们的参数是必须的，这种行为我们是想要的，但是如果我们期望参数可选呢？为阻止这种错误，我们需要给解构参数赋一个默认值：\n\n```js\nfunction initiateTransfer({protocol, port, delay, retries, timeout, log} = {}) {\n     // code to initiate transfer\n}\ninitiateTransfer();    // no error\n```\n\n\n在这个函数中，我们给解构参数赋了一个空对象作为默认值。现在如果函数调用时没有赋予参数，不会抛出错误。\n\n我们也可以给解构参数每个属性都赋默认值：\n\n```js\nfunction initiateTransfer({\n    protocol = 'http',\n    port = 800,\n    delay = 150,\n    retries = 10,\n    timeout = 500,\n    log = true\n}) {\n     // code to initiate transfer\n}\n```\n\n在这个例子中，每个属性都被赋予默认值，就无需在函数体内手动检查 undefined 的参数再赋予默认值。\n\n## 参数传递\n\n函数传参有两种方式：引用传递和值传递。如果是引用传递，修改参数会引起全局的变化，如果是值传递，只会引起函数内的变化。\n\n在一些语言中，像 Visual Basic 和 PowerShell，我们可以选择声明是值传递还是引用传递，但 JavaScript 不是这样。\n\n### 值传递\n\n严格来说，JavaScript只能值传递。当我们通过值传递给函数传参，就在函数作用域内创建了这个值得副本。所以任何值得变化都只会反映在函数内部。看下面的例子：\n\n```js\nvar a = 5;\nfunction increment(a) {\n    a = ++a;\n    console.log(a);\n}\nincrement(a);   // 6\nconsole.log(a);    // 5\n```\n\n在这里，在函数内部修改修改参数并不会影响到原始值。所以在函数外打印这个变量，得到的结果始终是 `5`。\n\n### 引用传递\n\n在 JavaScript 中，所有的都是值传递，但是当我们传递一个变量指向一个对象（包括数组），这个“值”就指向了这个对象，改变了对象的某个属相也会引起其关联对象的改变。\n\n看这个函数：\n\n```js\nfunction foo(param){\n    param.bar = 'new value';\n}\nobj = {\n    bar : 'value'\n}\nconsole.log(obj.bar);   // value\nfoo(obj);\nconsole.log(obj.bar);   // new value\n```\n\n正如你看到的，对象的属性在函数体内部被修改，但是却影响到了函数外部的对象。\n\n当我们传递一个非原始的值，像数组或者对象，程序会在内存中创建一个对象，指向原始地址。如果被修改，原始值也会随之修改。\n\n## 类型检查和缺失或多余参数\n\n在强类型的语言中，我们必须在函数声明时声明参数的类型，但 JavaScript 中没有这种特性，在 JavaScript 中，并不关心传递给函数的参数的类型和个数。\n\n假设我们有一个函数，仅接受一个参数。当我们调用这个函数的使用，我们并不限制到底传递给函数多少个参数，甚至可以选择不传，都不会产生错误。\n\n参数的个数可以分为两种情况：\n\n* #### 参数缺失\n  缺失的变量赋值为 undefined\n* #### 参数过多\n  多余的参数会被忽略，但可以从 arguments 变量中取到（下文即将讨论）。\n\n## 强制参数\n\n函数调用中如果函数缺失，它会被设置为 undefined。我们可以利用这一点，如果参数缺失就抛出错误：\n\n```js\nfunction foo(mandatory, optional) {\n    if (mandatory === undefined) {\n        throw new Error('Missing parameter: mandatory');\n    }\n}\n```\n\n在 ES6 中，我们可以更近一步，使用默认参数来设置强制参数：\n\n```js\nfunction throwError() {\n    throw new Error('Missing parameter');\n}\nfunction foo(param1 = throwError(), param2 = throwError()) {\n    // do something\n}\nfoo(10, 20);    // ok\nfoo(10);   // Error: missing parameter\n```\n\n## arguments 对象\n\n在 ES4 的时候默认参数就被加入，来代替 `arguments` 对象，但 ES4 并没有实现。随着 ES6 的发布，JavaScript 现在官方支持了默认参数。但并没有取消支持 `arguments` 的计划。\n\n`arguments` 对象是一个类数组的对象，可以在所有的函数中取到。`arguments` 通过数字索引来获取传入的参数，而不是通过参数的名字。这个对象允许我们给函数传入任意多的参数。看下面的代码判断：\n\n```js\nfunction checkParams(param1) {\n    console.log(param1);    // 2\n    console.log(arguments[0], arguments[1]);    // 2 3\n    console.log(param1 + arguments[0]);    // 4\n}\ncheckParams(2, 3);\n```\n\n\n这个函数期望传入一个参数，当我们传入两个参数调用它的时候，我们通过 `param1` 或者 `arguments[0]` 来获取第一个参数，但第二个参数只能通过 `arguments[1]` 获取。也即是说，`arguments` 对象可以和有命名的参数一起使用。\n\n`arguments` 对象包含了所有传入函数的参数，并且索引的起始是 `1`。当我们希望获取更多的参数的时候，我们会使用 `arguments[2]` 、`arguments[3]` 等等。\n\n我们可以跳过所有的参数命名设置，仅仅使用 `arguments` 对象：\n\n```js\nfunction checkParams() {\n    console.log(arguments[1], arguments[0], arguments[2]);\n}\ncheckParams(2, 4, 6);  // 4 2 6\n```\n\n\n实际上，命名的参数是一种方便，但不是必需的。同样的，rest 参数也可以用来显示传入的参数：\n\n```js\nfunction checkParams(...params) {\n    console.log(params[1], params[0], params[2]);    // 4 2 6\n    console.log(arguments[1], arguments[0], arguments[2]);    // 4 2 6\n}\ncheckParams(2, 4, 6);\n```\n\n`arguments` 对象是一个类数组对象，但是缺少像 `slice` 和 `foreach` 等方法。为了在 `arguments` 对象上使用这些方法，需要将其转换为真实的数组：\n\n```js\nfunction sort() {\n    var a = Array.prototype.slice.call(arguments);\n    return a.sort();\n}\nsort(40, 20, 50, 30);    // [20, 30, 40, 50]\n```\n\n在这个函数中，使用 `Array.prototype.slice.call()` 快速将 `arguments` 对象转换为数组。然后使用 `sort` 方法进行排序。\n\nES6 有一种更直接的方法，`Array.from()`，ES6 新增的方法，用来通过类数组对象创建一个新的数组。\n\n```js\nfunction sort() {\n    var a = Array.from(arguments);\n    return a.sort();\n}\nsort(40, 20, 50, 30);    // [20, 30, 40, 50]\n```\n\n## length 属性\n\n虽然 arguments 对象并不是严格意义的数组，但它有一个 `length` 属性，可以用来检查传递给函数的参数的个数。\n\n```js\nfunction countArguments() {\n    console.log(arguments.length);\n}\ncountArguments();    // 0\ncountArguments(10, null, \"string\");    // 3\n```\n\n通过使用 `length` 属性，我们可以更好的控制参数的数量。比如说，如果一个函数需要两个参数，我们就可以使用 `length` 属性来检查参数数量，如果少于期望数量就抛出错误。\n\n```js\nfunction foo(param1, param2) {\n    if (arguments.length < 2) {\n        throw new Error(\"This function expects at least two arguments\");\n    } else if (arguments.length === 2) {\n        // do something\n    }\n}\n```\n\n\nrest 参数是数组，所以他也有 `length` 属性，我们用 ES6 来重写上面的方法：\n\n```js\nfunction foo(...params) {\n  if (params.length < 2) {\n        throw new Error(\"This function expects at least two arguments\");\n    } else if (params.length === 2) {\n        // do something\n    }\n}\n```\n\n## Callee 和 Caller 属性\n\n`callee` 属性指向当前正在运行的函数，而 `caller` 指向调用当前正在运行函数的函数。在 ES5 严格模式下，这些属性是被废弃掉的，如果要访问它们会抛出错误。\n\n`arguments.callee` 属性在递归函数（递归函数是一个普通函数，通过它的签名指向自身）下很有用，尤其是函数的签名不可用时（也就是匿名函数）。因为匿名函数没有名字，唯一指向自身的方法就是通过 `arguments.callee`。\n\n```js\nvar result = (function(n) {\n  if (n <= 1) {\n    return 1;\n  } else {\n    return n * arguments.callee(n - 1);\n  }\n})(4);   // 24\n```\n\n## 严格模式和非严格模式下的 arguments\n\n在 ES5 非严格模式下， `arguments` 对象有一个不常用的特性：它保持和命名参数值同步。\n\n```js\nfunction foo(param) {\n   console.log(param === arguments[0]);    // true\n   arguments[0] = 500;\n   console.log(param === arguments[0]);    // true\n   return param\n}\nfoo(200);    // 500\n```\n\n在函数内部，一个新的值赋给 `arguments[0]`。因为 `arguments` 一直和命名参数的值保持同步，`arguments[0]` 的改变也会引起 `param` 的改变。事实上，他们是同个变量的不同名称。在 ES5 严格模式下，这种令人迷惑的特性被移除了：\n\n```js\n\"use strict\";\nfunction foo(param) {\n   console.log(param === arguments[0]);    // true\n   arguments[0] = 500;\n   console.log(param === arguments[0]);    // false\n   return param\n}\nfoo(200);   // 200\n```\n\n这次，`arguments[0]` 的改变没有影响到 `param`，并且输出和期望一样。ES6下，输出结果和 ES5 的严格模式是一致的。但是请记住，在函数声明时使用了默认参数，`arguments` 不受影响。\n\n```js\nfunction foo(param1, param2 = 10, param3 = 20) {\n   console.log(param1 === arguments[0]);    // true\n   console.log(param2 === arguments[1]);    // true\n   console.log(param3 === arguments[2]);    // false\n   console.log(arguments[2]);    // undefined\n   console.log(param3);    // 20\n}\nfoo('string1', 'string2');\n```\n\n\n在这个函数中，尽管 `param3` 有默认值，但他和 `arguments[2]` 并不相等，因为只有两个参数传入了函数。也就是说，设置默认参数并不影响 arguments 对象。\n\n## 结论\n\nES6 给 JavaScript 带来了许多大大小小的改进。越来越多的开发者开始使用 ES6，而且很多所有的特性都可以无障碍使用。本文我们学习了 ES6 是如何提升JavaScript 处理参数的能力的。但我们仅仅学了 ES6 的一点皮毛。更多的有趣的特性等着我们去挖掘！\n\n* [ECMAScript 6 Compatibility Table](https://kangax.github.io/compat-table/es6/), Juriy Zaytsev\n* “[ECMAScript 2015 Language Specification](http://www.ecma-international.org/ecma-262/6.0/),” ECMA International\n\n--- \n\n看下时间现在正好是23：23，几乎用了一个下午和晚上把这篇文章读完又翻译完，这篇文章结合 ES5 和 ES6 来讲解，收益颇多。不过翻译水平有限，求多提意见多多指教 ~\n\n原文地址： [How To Use Arguments And Parameters In ECMAScript 6](https://www.smashingmagazine.com/2016/07/how-to-use-arguments-and-parameters-in-ecmascript-6/)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/how-to-use-arguments-and-parameters-in-es6.md","raw":"\nlayout: post\ntitle: 如何使用 ES6 中的参数\nbanner: assets/img/es6.jpg\nlabel: 译\ntags: ES6\n---\n\nECMAScript 6（或者叫 ECMAScript 2015）是 ECMAScript 的最新标准，极大的提高了 JavaScript 中处理参数的能力。现在我们可以使用 rest 参数（rest parameters）、默认值（default values）和解构（destructuring）以及其他许多新的特性。本文我们将探索参数(arguments)和参数(parameter)的方方面面，看一下ES6是如何对他们改进和提升的。\n\n## Arguments 和 Parameters \n\narguments 和 Parameters 的含义通常是可以互换的。尽管如此，为了本文的目标，还是要做出区分。在大多数的标准中，函数声明时给出的叫做 parameters（或者叫 formal parameters），而传递给函数的叫做的 arguments（或者叫 actual arguments），看下面的函数：\n\n```js\nfunction foo(param1, param2) {\n    // do something\n}\nfoo(10, 20);\n```\n\n在这个函数中，`param1` 和 `param2` 是函数的 parameters，而传递给函数的值（`10` 和 `20`）是 arguments。\n\n**译者注：本文后面不再区分 arguments 和 parameters，统一译作参数。:joy:**\n\n## 扩展运算符（...) \n\n在 ES5 中，`apply()` 方法可以很方便将数组作为参数传递给函数，经常用于使用 `Math.max()` 来取得数组的最大值。看下面的代码段：\n\n```js\nvar myArray = [5, 10, 50];\nMath.max(myArray);    // Error: NaN\nMath.max.apply(Math, myArray);    // 50\n```\n\n\n`Math.max()` 方法不支持数组，只接受数字作为参数。当数组传递给函数，函数会抛出错误。但是当使用 `apply()` 方法后，数组变成了一个个单独的数组传递给了函数，所以 `Math.max()` 就能够正确的执行了。\n\n幸运的是，ES6 给我们带来了扩展运算符，我们就不必再继续使用 `apply()` 方法了。我们可以将表达式轻松的展开为多个参数。\n\n```js\nvar myArray = [5, 10, 50];\nMath.max(...myArray);    // 50\n```\n\n在这里我们通过扩展运算符将 `myArray` 展开成了一个个单独的值。虽然 ES5 中我们可以通过 `apply()` 方法来模拟扩展运算符，但是语法上让人迷惑，并且缺少可扩展性。扩展运算符不仅易于使用，还带来了许多新的特性。比如，你可以在函数调用时多次使用扩展运算符，并且还可以和其他参数混合在一起。\n\n```js\nfunction myFunction() {\n  for(var i in arguments){\n    console.log(arguments[i]);\n  }\n}\nvar params = [10, 15];\nmyFunction(5, ...params, 20, ...[25]);    // 5 10 15 20 25\n```\n\n扩展运算符另一大好处就是他可以很容易的和构造函数（constructor）一起使用：\n\n```js\nnew Date(...[2016, 5, 6]);    // Mon Jun 06 2016 00:00:00 GMT-0700 (Pacific Daylight Time)\n```\n\n当前我们可以使用 ES5 来重写上面的代码，不过我们需要一个复杂的方法来避免一个类型错误：\n\n```js\nnew Date.apply(null, [2016, 4, 24]);    // TypeError: Date.apply is not a constructor\nnew (Function.prototype.bind.apply(Date, [null].concat([2016, 5, 6])));   // Mon Jun 06 2016 00:00:00 GMT-0700 (Pacific Daylight Time)\n```\n\n## REST 参数\n\nrest 参数和扩展运算符是一样的语法，但是他不是将数组展开成一个个的参数，而是将一个个参数转换为数组。\n\n**译者注：rest 参数和扩展运算符虽然一样的语法，在这里你就可以看出作者强调的 arguments 和 parameters 的区别了。扩展运算符用于函数调用的参数（arguments）中，而 rest 参数用于函数声明的参数（parameters）中。**\n\n```js\nfunction myFunction(...options) {\n     return options;\n}\nmyFunction('a', 'b', 'c');      // [\"a\", \"b\", \"c\"]\n```\n\n如果没有提供参数，rest 参数会被设置为空数组：\n\n```\nfunction myFunction(...options) {\n     return options;\n}\nmyFunction();      // []\n```\n\n当创建可见函数（接受数量可变的参数的函数）的时候，rest 参数就显得十分有用。因为 rest 参数是一个数组，所以可以很方便的替换 `arguments` 对象（将会在下文讨论）。看下面一个使用 ES5 编写的方法：\n\n```js\nfunction checkSubstrings(string) {\n  for (var i = 1; i < arguments.length; i++) {\n    if (string.indexOf(arguments[i]) === -1) {\n      return false;\n    }\n  }\n  return true;\n}\ncheckSubstrings('this is a string', 'is', 'this');   // true\n```\n\n\n这个函数的作用是检查一个字符串是否包含指定的一系列字符串。这个函数的第一个问题就是，我们必须查看函数体才知道函数接受多个参数。另外 `arguments` 的迭代必须从 1 开始，因为 `arguments[0]` 是第一个参数。如果我们稍后给第一参数之后再添加参数，或许我们就忘记更新这个循环了。使用 rest 参数，我们可以很轻易的避开这个问题：\n\n```js\nfunction checkSubstrings(string, ...keys) {\n  for (var key of keys) {\n    if (string.indexOf(key) === -1) {\n      return false;\n    }\n  }\n  return true;\n}\ncheckSubstrings('this is a string', 'is', 'this');   // true\n```\n\n函数的输出和上一个函数一样。再重复一次，`string` 参数作为第一个参数传入，剩下的参数被塞进一个数组并且赋值给了变量 `keys`。\n\n使用 rest 参数代替 `arguments` 不仅提高了代码的可读性，并且避免了 JavaScript 中的[性能问题](https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments)。尽管如此，rest 参数并不能无限制使用，举个例子，它只能是最后一个参数，否则会导致语法错误。\n\n```js\nfunction logArguments(a, ...params, b) {\n        console.log(a, params, b);\n}\nlogArguments(5, 10, 15);    // SyntaxError: parameter after rest parameter\n```\n\n另一个限制方法声明时只允许一个 rest 参数：\n\n```js\nfunction logArguments(...param1, ...param2) {\n}\nlogArguments(5, 10, 15);    // SyntaxError: parameter after rest parameter\n```\n\n\n## 默认值\n\n### ES5 中的默认参数\n\nES5 中 JavaScript 并不支持默认值，但这里有个很简单的实现，使用 `OR`\n运算符（`||`），我们可以很容易的模拟默认参数，看下面的代码：\n\n```js\nfunction foo(param1, param2) {\n   param1 = param1 || 10;\n   param2 = param2 || 10;\n   console.log(param1, param2);\n}\nfoo(5, 5);  // 5 5\nfoo(5);    // 5 10\nfoo();    // 10 10\n```\n\n这个函数期望接收两个参数，但当无参数调用时，它会使用默认值。在函数内，缺失的参数自动设置为 undefined，所以我们检查这些参数，并给他们设置默认值。为了检测缺失的参数并设置默认值，我们使用 `OR` 运算符（`||`）。这个运算符首先检查第一个值，如果是 [truthy](https://developer.mozilla.org/en-US/docs/Glossary/Truthy)，运算符会返回它，否则返回第二个参数。\n\n这种方法在函数内很常用，但也存在瑕疵。如果传递 `0` 或者 `null` 也会返回默认值。因为它们被认为是 falsy 值。所以如果我们确实需要给函数传递 `0` 或者 `null`，我们需要换种方法来检测参数是否缺失：\n\n```js\nfunction foo(param1, param2) {\n  if(param1 === undefined){\n    param1 = 10;\n  }\n  if(param2 === undefined){\n    param2 = 10;\n  }\n  console.log(param1, param2);\n}\nfoo(0, null);    // 0, null\nfoo();    // 10, 10\n```\n\n在这个函数中，通过检查参数的类型是否为 undefined 来确定是否要赋予默认值。这种方法代码量稍微大一些，但更安全，可以让我们给函数传递 `0` 或者 `null`。\n\n### ES6 中的默认参数\n\nES6 中，我们不必再检查参数是否为 undefined 来模拟默认参数，我们可以直接将默认参数函数声明中。\n\n```js\nfunction foo(a = 10, b = 10) {\n  console.log(a, b);\n}\nfoo(5);    // 5 10\nfoo(0, null);    // 0 null\n```\n\n正如你所看到的，忽略参数返回了默认值，但传递 `0` 或者 `null` 并没有。我们甚至可以使用函数来产生参数的默认值：\n\n```js\nfunction getParam() {\n    alert(\"getParam was called\");\n    return 3;\n}\nfunction multiply(param1, param2 = getParam()) {\n    return param1 * param2;\n}\nmultiply(2, 5);     // 10\nmultiply(2);     // 6 (also displays an alert dialog)\n```\n\n需要注意的是，只有缺少第二个参数的时候，`gegParam` 方法才会执行，所以当我们使用两个参数 `multiply()` 的时候并不会弹出 alert。\n\n默认参数另一个有意思的特性是在方法声明是可以引用其他参数和变量作为默认参数：\n\n```js\nfunction myFunction(a=10, b=a) {\n     console.log('a = ' + a + '; b = '  + b);\n}\nmyFunction();     // a=10; b=10\nmyFunction(22);    // a=22; b=22\nmyFunction(2, 4);    // a=2; b=4\n```\n\n甚至可以在函数声明的时候执行操作符：\n\n```js\nfunction myFunction(a, b = ++a, c = a*b) {\n     console.log(c);\n}\nmyFunction(5);    // 36\n```\n\n注意：不像其他语言，JavaScript 是在调用时才计算默认参数的：\n\n```js\nfunction add(value, array = []) {\n  array.push(value);\n  return array;\n}\nadd(5);    // [5]\nadd(6);    // [6], not [5, 6]\n```\n\n## 解构赋值\n\n解构赋值是 ES6 的新特性，让我们可以从数组或者对象中提取值并赋值给变量，语法上类似于对象和数组字面量。当给函数传参时，这种语法清晰且易于理解并且很实用。\n\n在 ES5 中，经常使用配置对象来处理大量的的可选参数，尤其是属性的顺序无关紧要的时候，看下面的函数：\n\n```js\nfunction initiateTransfer(options) {\n    var  protocol = options.protocol,\n        port = options.port,\n        delay = options.delay,\n        retries = options.retries,\n        timeout = options.timeout,\n        log = options.log;\n    // code to initiate transfer\n}\noptions = {\n  protocol: 'http',\n  port: 800,\n  delay: 150,\n  retries: 10,\n  timeout: 500,\n  log: true\n};\ninitiateTransfer(options);\n```\n\n这种模式 JavaScript 开发者经常使用，并且很好用。但我们必须进入函数体内才知道到底需要多少参数，使用解构参数赋值，我们可以在函数声明时很清晰的指定需要的参数。\n\n```js\nfunction initiateTransfer({protocol, port, delay, retries, timeout, log}) {\n     // code to initiate transfer\n};\nvar options = {\n  protocol: 'http',\n  port: 800,\n  delay: 150,\n  retries: 10,\n  timeout: 500,\n  log: true\n}\ninitiateTransfer(options);\n```\n\n在这个函数中，我们使用了对象解构模式，而不是一个配置型对象，让我们的代码更加清晰易读。\n\n我们也可以混用解构参数和普通参数：\n\n```js\nfunction initiateTransfer(param1, {protocol, port, delay, retries, timeout, log}) {\n     // code to initiate transfer\n}\ninitiateTransfer('some value', options);\n```\n\n需要注意，如果函数调用时解构参数缺失会抛出一个类型错误：\n\n```js\nfunction initiateTransfer({protocol, port, delay, retries, timeout, log}) {\n     // code to initiate transfer\n}\ninitiateTransfer();  // TypeError: Cannot match against 'undefined' or 'null'\n```\n\n当我们的参数是必须的，这种行为我们是想要的，但是如果我们期望参数可选呢？为阻止这种错误，我们需要给解构参数赋一个默认值：\n\n```js\nfunction initiateTransfer({protocol, port, delay, retries, timeout, log} = {}) {\n     // code to initiate transfer\n}\ninitiateTransfer();    // no error\n```\n\n\n在这个函数中，我们给解构参数赋了一个空对象作为默认值。现在如果函数调用时没有赋予参数，不会抛出错误。\n\n我们也可以给解构参数每个属性都赋默认值：\n\n```js\nfunction initiateTransfer({\n    protocol = 'http',\n    port = 800,\n    delay = 150,\n    retries = 10,\n    timeout = 500,\n    log = true\n}) {\n     // code to initiate transfer\n}\n```\n\n在这个例子中，每个属性都被赋予默认值，就无需在函数体内手动检查 undefined 的参数再赋予默认值。\n\n## 参数传递\n\n函数传参有两种方式：引用传递和值传递。如果是引用传递，修改参数会引起全局的变化，如果是值传递，只会引起函数内的变化。\n\n在一些语言中，像 Visual Basic 和 PowerShell，我们可以选择声明是值传递还是引用传递，但 JavaScript 不是这样。\n\n### 值传递\n\n严格来说，JavaScript只能值传递。当我们通过值传递给函数传参，就在函数作用域内创建了这个值得副本。所以任何值得变化都只会反映在函数内部。看下面的例子：\n\n```js\nvar a = 5;\nfunction increment(a) {\n    a = ++a;\n    console.log(a);\n}\nincrement(a);   // 6\nconsole.log(a);    // 5\n```\n\n在这里，在函数内部修改修改参数并不会影响到原始值。所以在函数外打印这个变量，得到的结果始终是 `5`。\n\n### 引用传递\n\n在 JavaScript 中，所有的都是值传递，但是当我们传递一个变量指向一个对象（包括数组），这个“值”就指向了这个对象，改变了对象的某个属相也会引起其关联对象的改变。\n\n看这个函数：\n\n```js\nfunction foo(param){\n    param.bar = 'new value';\n}\nobj = {\n    bar : 'value'\n}\nconsole.log(obj.bar);   // value\nfoo(obj);\nconsole.log(obj.bar);   // new value\n```\n\n正如你看到的，对象的属性在函数体内部被修改，但是却影响到了函数外部的对象。\n\n当我们传递一个非原始的值，像数组或者对象，程序会在内存中创建一个对象，指向原始地址。如果被修改，原始值也会随之修改。\n\n## 类型检查和缺失或多余参数\n\n在强类型的语言中，我们必须在函数声明时声明参数的类型，但 JavaScript 中没有这种特性，在 JavaScript 中，并不关心传递给函数的参数的类型和个数。\n\n假设我们有一个函数，仅接受一个参数。当我们调用这个函数的使用，我们并不限制到底传递给函数多少个参数，甚至可以选择不传，都不会产生错误。\n\n参数的个数可以分为两种情况：\n\n* #### 参数缺失\n  缺失的变量赋值为 undefined\n* #### 参数过多\n  多余的参数会被忽略，但可以从 arguments 变量中取到（下文即将讨论）。\n\n## 强制参数\n\n函数调用中如果函数缺失，它会被设置为 undefined。我们可以利用这一点，如果参数缺失就抛出错误：\n\n```js\nfunction foo(mandatory, optional) {\n    if (mandatory === undefined) {\n        throw new Error('Missing parameter: mandatory');\n    }\n}\n```\n\n在 ES6 中，我们可以更近一步，使用默认参数来设置强制参数：\n\n```js\nfunction throwError() {\n    throw new Error('Missing parameter');\n}\nfunction foo(param1 = throwError(), param2 = throwError()) {\n    // do something\n}\nfoo(10, 20);    // ok\nfoo(10);   // Error: missing parameter\n```\n\n## arguments 对象\n\n在 ES4 的时候默认参数就被加入，来代替 `arguments` 对象，但 ES4 并没有实现。随着 ES6 的发布，JavaScript 现在官方支持了默认参数。但并没有取消支持 `arguments` 的计划。\n\n`arguments` 对象是一个类数组的对象，可以在所有的函数中取到。`arguments` 通过数字索引来获取传入的参数，而不是通过参数的名字。这个对象允许我们给函数传入任意多的参数。看下面的代码判断：\n\n```js\nfunction checkParams(param1) {\n    console.log(param1);    // 2\n    console.log(arguments[0], arguments[1]);    // 2 3\n    console.log(param1 + arguments[0]);    // 4\n}\ncheckParams(2, 3);\n```\n\n\n这个函数期望传入一个参数，当我们传入两个参数调用它的时候，我们通过 `param1` 或者 `arguments[0]` 来获取第一个参数，但第二个参数只能通过 `arguments[1]` 获取。也即是说，`arguments` 对象可以和有命名的参数一起使用。\n\n`arguments` 对象包含了所有传入函数的参数，并且索引的起始是 `1`。当我们希望获取更多的参数的时候，我们会使用 `arguments[2]` 、`arguments[3]` 等等。\n\n我们可以跳过所有的参数命名设置，仅仅使用 `arguments` 对象：\n\n```js\nfunction checkParams() {\n    console.log(arguments[1], arguments[0], arguments[2]);\n}\ncheckParams(2, 4, 6);  // 4 2 6\n```\n\n\n实际上，命名的参数是一种方便，但不是必需的。同样的，rest 参数也可以用来显示传入的参数：\n\n```js\nfunction checkParams(...params) {\n    console.log(params[1], params[0], params[2]);    // 4 2 6\n    console.log(arguments[1], arguments[0], arguments[2]);    // 4 2 6\n}\ncheckParams(2, 4, 6);\n```\n\n`arguments` 对象是一个类数组对象，但是缺少像 `slice` 和 `foreach` 等方法。为了在 `arguments` 对象上使用这些方法，需要将其转换为真实的数组：\n\n```js\nfunction sort() {\n    var a = Array.prototype.slice.call(arguments);\n    return a.sort();\n}\nsort(40, 20, 50, 30);    // [20, 30, 40, 50]\n```\n\n在这个函数中，使用 `Array.prototype.slice.call()` 快速将 `arguments` 对象转换为数组。然后使用 `sort` 方法进行排序。\n\nES6 有一种更直接的方法，`Array.from()`，ES6 新增的方法，用来通过类数组对象创建一个新的数组。\n\n```js\nfunction sort() {\n    var a = Array.from(arguments);\n    return a.sort();\n}\nsort(40, 20, 50, 30);    // [20, 30, 40, 50]\n```\n\n## length 属性\n\n虽然 arguments 对象并不是严格意义的数组，但它有一个 `length` 属性，可以用来检查传递给函数的参数的个数。\n\n```js\nfunction countArguments() {\n    console.log(arguments.length);\n}\ncountArguments();    // 0\ncountArguments(10, null, \"string\");    // 3\n```\n\n通过使用 `length` 属性，我们可以更好的控制参数的数量。比如说，如果一个函数需要两个参数，我们就可以使用 `length` 属性来检查参数数量，如果少于期望数量就抛出错误。\n\n```js\nfunction foo(param1, param2) {\n    if (arguments.length < 2) {\n        throw new Error(\"This function expects at least two arguments\");\n    } else if (arguments.length === 2) {\n        // do something\n    }\n}\n```\n\n\nrest 参数是数组，所以他也有 `length` 属性，我们用 ES6 来重写上面的方法：\n\n```js\nfunction foo(...params) {\n  if (params.length < 2) {\n        throw new Error(\"This function expects at least two arguments\");\n    } else if (params.length === 2) {\n        // do something\n    }\n}\n```\n\n## Callee 和 Caller 属性\n\n`callee` 属性指向当前正在运行的函数，而 `caller` 指向调用当前正在运行函数的函数。在 ES5 严格模式下，这些属性是被废弃掉的，如果要访问它们会抛出错误。\n\n`arguments.callee` 属性在递归函数（递归函数是一个普通函数，通过它的签名指向自身）下很有用，尤其是函数的签名不可用时（也就是匿名函数）。因为匿名函数没有名字，唯一指向自身的方法就是通过 `arguments.callee`。\n\n```js\nvar result = (function(n) {\n  if (n <= 1) {\n    return 1;\n  } else {\n    return n * arguments.callee(n - 1);\n  }\n})(4);   // 24\n```\n\n## 严格模式和非严格模式下的 arguments\n\n在 ES5 非严格模式下， `arguments` 对象有一个不常用的特性：它保持和命名参数值同步。\n\n```js\nfunction foo(param) {\n   console.log(param === arguments[0]);    // true\n   arguments[0] = 500;\n   console.log(param === arguments[0]);    // true\n   return param\n}\nfoo(200);    // 500\n```\n\n在函数内部，一个新的值赋给 `arguments[0]`。因为 `arguments` 一直和命名参数的值保持同步，`arguments[0]` 的改变也会引起 `param` 的改变。事实上，他们是同个变量的不同名称。在 ES5 严格模式下，这种令人迷惑的特性被移除了：\n\n```js\n\"use strict\";\nfunction foo(param) {\n   console.log(param === arguments[0]);    // true\n   arguments[0] = 500;\n   console.log(param === arguments[0]);    // false\n   return param\n}\nfoo(200);   // 200\n```\n\n这次，`arguments[0]` 的改变没有影响到 `param`，并且输出和期望一样。ES6下，输出结果和 ES5 的严格模式是一致的。但是请记住，在函数声明时使用了默认参数，`arguments` 不受影响。\n\n```js\nfunction foo(param1, param2 = 10, param3 = 20) {\n   console.log(param1 === arguments[0]);    // true\n   console.log(param2 === arguments[1]);    // true\n   console.log(param3 === arguments[2]);    // false\n   console.log(arguments[2]);    // undefined\n   console.log(param3);    // 20\n}\nfoo('string1', 'string2');\n```\n\n\n在这个函数中，尽管 `param3` 有默认值，但他和 `arguments[2]` 并不相等，因为只有两个参数传入了函数。也就是说，设置默认参数并不影响 arguments 对象。\n\n## 结论\n\nES6 给 JavaScript 带来了许多大大小小的改进。越来越多的开发者开始使用 ES6，而且很多所有的特性都可以无障碍使用。本文我们学习了 ES6 是如何提升JavaScript 处理参数的能力的。但我们仅仅学了 ES6 的一点皮毛。更多的有趣的特性等着我们去挖掘！\n\n* [ECMAScript 6 Compatibility Table](https://kangax.github.io/compat-table/es6/), Juriy Zaytsev\n* “[ECMAScript 2015 Language Specification](http://www.ecma-international.org/ecma-262/6.0/),” ECMA International\n\n--- \n\n看下时间现在正好是23：23，几乎用了一个下午和晚上把这篇文章读完又翻译完，这篇文章结合 ES5 和 ES6 来讲解，收益颇多。不过翻译水平有限，求多提意见多多指教 ~\n\n原文地址： [How To Use Arguments And Parameters In ECMAScript 6](https://www.smashingmagazine.com/2016/07/how-to-use-arguments-and-parameters-in-ecmascript-6/)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"how-to-use-arguments-and-parameters-in-es6","published":1,"date":"2019-01-17T13:00:11.000Z","updated":"2019-01-17T13:00:11.000Z","comments":1,"photos":[],"link":"","_id":"cjr1en2oo001zha9s9wx21zu6","content":"<p>ECMAScript 6（或者叫 ECMAScript 2015）是 ECMAScript 的最新标准，极大的提高了 JavaScript 中处理参数的能力。现在我们可以使用 rest 参数（rest parameters）、默认值（default values）和解构（destructuring）以及其他许多新的特性。本文我们将探索参数(arguments)和参数(parameter)的方方面面，看一下ES6是如何对他们改进和提升的。</p>\n<h2 id=\"arguments-和-parameters\">Arguments 和 Parameters</h2>\n<p>arguments 和 Parameters 的含义通常是可以互换的。尽管如此，为了本文的目标，还是要做出区分。在大多数的标准中，函数声明时给出的叫做 parameters（或者叫 formal parameters），而传递给函数的叫做的 arguments（或者叫 actual arguments），看下面的函数：</p>\n<pre><code class=\"language-js\">function foo(param1, param2) {\n    // do something\n}\nfoo(10, 20);\n</code></pre>\n<p>在这个函数中，<code>param1</code> 和 <code>param2</code> 是函数的 parameters，而传递给函数的值（<code>10</code> 和 <code>20</code>）是 arguments。</p>\n<p><strong>译者注：本文后面不再区分 arguments 和 parameters，统一译作参数。😂</strong></p>\n<h2 id=\"扩展运算符\">扩展运算符（…)</h2>\n<p>在 ES5 中，<code>apply()</code> 方法可以很方便将数组作为参数传递给函数，经常用于使用 <code>Math.max()</code> 来取得数组的最大值。看下面的代码段：</p>\n<pre><code class=\"language-js\">var myArray = [5, 10, 50];\nMath.max(myArray);    // Error: NaN\nMath.max.apply(Math, myArray);    // 50\n</code></pre>\n<p><code>Math.max()</code> 方法不支持数组，只接受数字作为参数。当数组传递给函数，函数会抛出错误。但是当使用 <code>apply()</code> 方法后，数组变成了一个个单独的数组传递给了函数，所以 <code>Math.max()</code> 就能够正确的执行了。</p>\n<p>幸运的是，ES6 给我们带来了扩展运算符，我们就不必再继续使用 <code>apply()</code> 方法了。我们可以将表达式轻松的展开为多个参数。</p>\n<pre><code class=\"language-js\">var myArray = [5, 10, 50];\nMath.max(...myArray);    // 50\n</code></pre>\n<p>在这里我们通过扩展运算符将 <code>myArray</code> 展开成了一个个单独的值。虽然 ES5 中我们可以通过 <code>apply()</code> 方法来模拟扩展运算符，但是语法上让人迷惑，并且缺少可扩展性。扩展运算符不仅易于使用，还带来了许多新的特性。比如，你可以在函数调用时多次使用扩展运算符，并且还可以和其他参数混合在一起。</p>\n<pre><code class=\"language-js\">function myFunction() {\n  for(var i in arguments){\n    console.log(arguments[i]);\n  }\n}\nvar params = [10, 15];\nmyFunction(5, ...params, 20, ...[25]);    // 5 10 15 20 25\n</code></pre>\n<p>扩展运算符另一大好处就是他可以很容易的和构造函数（constructor）一起使用：</p>\n<pre><code class=\"language-js\">new Date(...[2016, 5, 6]);    // Mon Jun 06 2016 00:00:00 GMT-0700 (Pacific Daylight Time)\n</code></pre>\n<p>当前我们可以使用 ES5 来重写上面的代码，不过我们需要一个复杂的方法来避免一个类型错误：</p>\n<pre><code class=\"language-js\">new Date.apply(null, [2016, 4, 24]);    // TypeError: Date.apply is not a constructor\nnew (Function.prototype.bind.apply(Date, [null].concat([2016, 5, 6])));   // Mon Jun 06 2016 00:00:00 GMT-0700 (Pacific Daylight Time)\n</code></pre>\n<h2 id=\"rest-参数\">REST 参数</h2>\n<p>rest 参数和扩展运算符是一样的语法，但是他不是将数组展开成一个个的参数，而是将一个个参数转换为数组。</p>\n<p><strong>译者注：rest 参数和扩展运算符虽然一样的语法，在这里你就可以看出作者强调的 arguments 和 parameters 的区别了。扩展运算符用于函数调用的参数（arguments）中，而 rest 参数用于函数声明的参数（parameters）中。</strong></p>\n<pre><code class=\"language-js\">function myFunction(...options) {\n     return options;\n}\nmyFunction('a', 'b', 'c');      // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]\n</code></pre>\n<p>如果没有提供参数，rest 参数会被设置为空数组：</p>\n<pre><code>function myFunction(...options) {\n     return options;\n}\nmyFunction();      // []\n</code></pre>\n<p>当创建可见函数（接受数量可变的参数的函数）的时候，rest 参数就显得十分有用。因为 rest 参数是一个数组，所以可以很方便的替换 <code>arguments</code> 对象（将会在下文讨论）。看下面一个使用 ES5 编写的方法：</p>\n<pre><code class=\"language-js\">function checkSubstrings(string) {\n  for (var i = 1; i &lt; arguments.length; i++) {\n    if (string.indexOf(arguments[i]) === -1) {\n      return false;\n    }\n  }\n  return true;\n}\ncheckSubstrings('this is a string', 'is', 'this');   // true\n</code></pre>\n<p>这个函数的作用是检查一个字符串是否包含指定的一系列字符串。这个函数的第一个问题就是，我们必须查看函数体才知道函数接受多个参数。另外 <code>arguments</code> 的迭代必须从 1 开始，因为 <code>arguments[0]</code> 是第一个参数。如果我们稍后给第一参数之后再添加参数，或许我们就忘记更新这个循环了。使用 rest 参数，我们可以很轻易的避开这个问题：</p>\n<pre><code class=\"language-js\">function checkSubstrings(string, ...keys) {\n  for (var key of keys) {\n    if (string.indexOf(key) === -1) {\n      return false;\n    }\n  }\n  return true;\n}\ncheckSubstrings('this is a string', 'is', 'this');   // true\n</code></pre>\n<p>函数的输出和上一个函数一样。再重复一次，<code>string</code> 参数作为第一个参数传入，剩下的参数被塞进一个数组并且赋值给了变量 <code>keys</code>。</p>\n<p>使用 rest 参数代替 <code>arguments</code> 不仅提高了代码的可读性，并且避免了 JavaScript 中的<a href=\"https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments\" target=\"_blank\" rel=\"noopener\">性能问题</a>。尽管如此，rest 参数并不能无限制使用，举个例子，它只能是最后一个参数，否则会导致语法错误。</p>\n<pre><code class=\"language-js\">function logArguments(a, ...params, b) {\n        console.log(a, params, b);\n}\nlogArguments(5, 10, 15);    // SyntaxError: parameter after rest parameter\n</code></pre>\n<p>另一个限制方法声明时只允许一个 rest 参数：</p>\n<pre><code class=\"language-js\">function logArguments(...param1, ...param2) {\n}\nlogArguments(5, 10, 15);    // SyntaxError: parameter after rest parameter\n</code></pre>\n<h2 id=\"默认值\">默认值</h2>\n<h3 id=\"es5-中的默认参数\">ES5 中的默认参数</h3>\n<p>ES5 中 JavaScript 并不支持默认值，但这里有个很简单的实现，使用 <code>OR</code><br>\n运算符（<code>||</code>），我们可以很容易的模拟默认参数，看下面的代码：</p>\n<pre><code class=\"language-js\">function foo(param1, param2) {\n   param1 = param1 || 10;\n   param2 = param2 || 10;\n   console.log(param1, param2);\n}\nfoo(5, 5);  // 5 5\nfoo(5);    // 5 10\nfoo();    // 10 10\n</code></pre>\n<p>这个函数期望接收两个参数，但当无参数调用时，它会使用默认值。在函数内，缺失的参数自动设置为 undefined，所以我们检查这些参数，并给他们设置默认值。为了检测缺失的参数并设置默认值，我们使用 <code>OR</code> 运算符（<code>||</code>）。这个运算符首先检查第一个值，如果是 <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Truthy\" target=\"_blank\" rel=\"noopener\">truthy</a>，运算符会返回它，否则返回第二个参数。</p>\n<p>这种方法在函数内很常用，但也存在瑕疵。如果传递 <code>0</code> 或者 <code>null</code> 也会返回默认值。因为它们被认为是 falsy 值。所以如果我们确实需要给函数传递 <code>0</code> 或者 <code>null</code>，我们需要换种方法来检测参数是否缺失：</p>\n<pre><code class=\"language-js\">function foo(param1, param2) {\n  if(param1 === undefined){\n    param1 = 10;\n  }\n  if(param2 === undefined){\n    param2 = 10;\n  }\n  console.log(param1, param2);\n}\nfoo(0, null);    // 0, null\nfoo();    // 10, 10\n</code></pre>\n<p>在这个函数中，通过检查参数的类型是否为 undefined 来确定是否要赋予默认值。这种方法代码量稍微大一些，但更安全，可以让我们给函数传递 <code>0</code> 或者 <code>null</code>。</p>\n<h3 id=\"es6-中的默认参数\">ES6 中的默认参数</h3>\n<p>ES6 中，我们不必再检查参数是否为 undefined 来模拟默认参数，我们可以直接将默认参数函数声明中。</p>\n<pre><code class=\"language-js\">function foo(a = 10, b = 10) {\n  console.log(a, b);\n}\nfoo(5);    // 5 10\nfoo(0, null);    // 0 null\n</code></pre>\n<p>正如你所看到的，忽略参数返回了默认值，但传递 <code>0</code> 或者 <code>null</code> 并没有。我们甚至可以使用函数来产生参数的默认值：</p>\n<pre><code class=\"language-js\">function getParam() {\n    alert(&quot;getParam was called&quot;);\n    return 3;\n}\nfunction multiply(param1, param2 = getParam()) {\n    return param1 * param2;\n}\nmultiply(2, 5);     // 10\nmultiply(2);     // 6 (also displays an alert dialog)\n</code></pre>\n<p>需要注意的是，只有缺少第二个参数的时候，<code>gegParam</code> 方法才会执行，所以当我们使用两个参数 <code>multiply()</code> 的时候并不会弹出 alert。</p>\n<p>默认参数另一个有意思的特性是在方法声明是可以引用其他参数和变量作为默认参数：</p>\n<pre><code class=\"language-js\">function myFunction(a=10, b=a) {\n     console.log('a = ' + a + '; b = '  + b);\n}\nmyFunction();     // a=10; b=10\nmyFunction(22);    // a=22; b=22\nmyFunction(2, 4);    // a=2; b=4\n</code></pre>\n<p>甚至可以在函数声明的时候执行操作符：</p>\n<pre><code class=\"language-js\">function myFunction(a, b = ++a, c = a*b) {\n     console.log(c);\n}\nmyFunction(5);    // 36\n</code></pre>\n<p>注意：不像其他语言，JavaScript 是在调用时才计算默认参数的：</p>\n<pre><code class=\"language-js\">function add(value, array = []) {\n  array.push(value);\n  return array;\n}\nadd(5);    // [5]\nadd(6);    // [6], not [5, 6]\n</code></pre>\n<h2 id=\"解构赋值\">解构赋值</h2>\n<p>解构赋值是 ES6 的新特性，让我们可以从数组或者对象中提取值并赋值给变量，语法上类似于对象和数组字面量。当给函数传参时，这种语法清晰且易于理解并且很实用。</p>\n<p>在 ES5 中，经常使用配置对象来处理大量的的可选参数，尤其是属性的顺序无关紧要的时候，看下面的函数：</p>\n<pre><code class=\"language-js\">function initiateTransfer(options) {\n    var  protocol = options.protocol,\n        port = options.port,\n        delay = options.delay,\n        retries = options.retries,\n        timeout = options.timeout,\n        log = options.log;\n    // code to initiate transfer\n}\noptions = {\n  protocol: 'http',\n  port: 800,\n  delay: 150,\n  retries: 10,\n  timeout: 500,\n  log: true\n};\ninitiateTransfer(options);\n</code></pre>\n<p>这种模式 JavaScript 开发者经常使用，并且很好用。但我们必须进入函数体内才知道到底需要多少参数，使用解构参数赋值，我们可以在函数声明时很清晰的指定需要的参数。</p>\n<pre><code class=\"language-js\">function initiateTransfer({protocol, port, delay, retries, timeout, log}) {\n     // code to initiate transfer\n};\nvar options = {\n  protocol: 'http',\n  port: 800,\n  delay: 150,\n  retries: 10,\n  timeout: 500,\n  log: true\n}\ninitiateTransfer(options);\n</code></pre>\n<p>在这个函数中，我们使用了对象解构模式，而不是一个配置型对象，让我们的代码更加清晰易读。</p>\n<p>我们也可以混用解构参数和普通参数：</p>\n<pre><code class=\"language-js\">function initiateTransfer(param1, {protocol, port, delay, retries, timeout, log}) {\n     // code to initiate transfer\n}\ninitiateTransfer('some value', options);\n</code></pre>\n<p>需要注意，如果函数调用时解构参数缺失会抛出一个类型错误：</p>\n<pre><code class=\"language-js\">function initiateTransfer({protocol, port, delay, retries, timeout, log}) {\n     // code to initiate transfer\n}\ninitiateTransfer();  // TypeError: Cannot match against 'undefined' or 'null'\n</code></pre>\n<p>当我们的参数是必须的，这种行为我们是想要的，但是如果我们期望参数可选呢？为阻止这种错误，我们需要给解构参数赋一个默认值：</p>\n<pre><code class=\"language-js\">function initiateTransfer({protocol, port, delay, retries, timeout, log} = {}) {\n     // code to initiate transfer\n}\ninitiateTransfer();    // no error\n</code></pre>\n<p>在这个函数中，我们给解构参数赋了一个空对象作为默认值。现在如果函数调用时没有赋予参数，不会抛出错误。</p>\n<p>我们也可以给解构参数每个属性都赋默认值：</p>\n<pre><code class=\"language-js\">function initiateTransfer({\n    protocol = 'http',\n    port = 800,\n    delay = 150,\n    retries = 10,\n    timeout = 500,\n    log = true\n}) {\n     // code to initiate transfer\n}\n</code></pre>\n<p>在这个例子中，每个属性都被赋予默认值，就无需在函数体内手动检查 undefined 的参数再赋予默认值。</p>\n<h2 id=\"参数传递\">参数传递</h2>\n<p>函数传参有两种方式：引用传递和值传递。如果是引用传递，修改参数会引起全局的变化，如果是值传递，只会引起函数内的变化。</p>\n<p>在一些语言中，像 Visual Basic 和 PowerShell，我们可以选择声明是值传递还是引用传递，但 JavaScript 不是这样。</p>\n<h3 id=\"值传递\">值传递</h3>\n<p>严格来说，JavaScript只能值传递。当我们通过值传递给函数传参，就在函数作用域内创建了这个值得副本。所以任何值得变化都只会反映在函数内部。看下面的例子：</p>\n<pre><code class=\"language-js\">var a = 5;\nfunction increment(a) {\n    a = ++a;\n    console.log(a);\n}\nincrement(a);   // 6\nconsole.log(a);    // 5\n</code></pre>\n<p>在这里，在函数内部修改修改参数并不会影响到原始值。所以在函数外打印这个变量，得到的结果始终是 <code>5</code>。</p>\n<h3 id=\"引用传递\">引用传递</h3>\n<p>在 JavaScript 中，所有的都是值传递，但是当我们传递一个变量指向一个对象（包括数组），这个“值”就指向了这个对象，改变了对象的某个属相也会引起其关联对象的改变。</p>\n<p>看这个函数：</p>\n<pre><code class=\"language-js\">function foo(param){\n    param.bar = 'new value';\n}\nobj = {\n    bar : 'value'\n}\nconsole.log(obj.bar);   // value\nfoo(obj);\nconsole.log(obj.bar);   // new value\n</code></pre>\n<p>正如你看到的，对象的属性在函数体内部被修改，但是却影响到了函数外部的对象。</p>\n<p>当我们传递一个非原始的值，像数组或者对象，程序会在内存中创建一个对象，指向原始地址。如果被修改，原始值也会随之修改。</p>\n<h2 id=\"类型检查和缺失或多余参数\">类型检查和缺失或多余参数</h2>\n<p>在强类型的语言中，我们必须在函数声明时声明参数的类型，但 JavaScript 中没有这种特性，在 JavaScript 中，并不关心传递给函数的参数的类型和个数。</p>\n<p>假设我们有一个函数，仅接受一个参数。当我们调用这个函数的使用，我们并不限制到底传递给函数多少个参数，甚至可以选择不传，都不会产生错误。</p>\n<p>参数的个数可以分为两种情况：</p>\n<ul>\n<li>\n<h4 id=\"参数缺失\">参数缺失</h4>\n缺失的变量赋值为 undefined</li>\n<li>\n<h4 id=\"参数过多\">参数过多</h4>\n多余的参数会被忽略，但可以从 arguments 变量中取到（下文即将讨论）。</li>\n</ul>\n<h2 id=\"强制参数\">强制参数</h2>\n<p>函数调用中如果函数缺失，它会被设置为 undefined。我们可以利用这一点，如果参数缺失就抛出错误：</p>\n<pre><code class=\"language-js\">function foo(mandatory, optional) {\n    if (mandatory === undefined) {\n        throw new Error('Missing parameter: mandatory');\n    }\n}\n</code></pre>\n<p>在 ES6 中，我们可以更近一步，使用默认参数来设置强制参数：</p>\n<pre><code class=\"language-js\">function throwError() {\n    throw new Error('Missing parameter');\n}\nfunction foo(param1 = throwError(), param2 = throwError()) {\n    // do something\n}\nfoo(10, 20);    // ok\nfoo(10);   // Error: missing parameter\n</code></pre>\n<h2 id=\"arguments-对象\">arguments 对象</h2>\n<p>在 ES4 的时候默认参数就被加入，来代替 <code>arguments</code> 对象，但 ES4 并没有实现。随着 ES6 的发布，JavaScript 现在官方支持了默认参数。但并没有取消支持 <code>arguments</code> 的计划。</p>\n<p><code>arguments</code> 对象是一个类数组的对象，可以在所有的函数中取到。<code>arguments</code> 通过数字索引来获取传入的参数，而不是通过参数的名字。这个对象允许我们给函数传入任意多的参数。看下面的代码判断：</p>\n<pre><code class=\"language-js\">function checkParams(param1) {\n    console.log(param1);    // 2\n    console.log(arguments[0], arguments[1]);    // 2 3\n    console.log(param1 + arguments[0]);    // 4\n}\ncheckParams(2, 3);\n</code></pre>\n<p>这个函数期望传入一个参数，当我们传入两个参数调用它的时候，我们通过 <code>param1</code> 或者 <code>arguments[0]</code> 来获取第一个参数，但第二个参数只能通过 <code>arguments[1]</code> 获取。也即是说，<code>arguments</code> 对象可以和有命名的参数一起使用。</p>\n<p><code>arguments</code> 对象包含了所有传入函数的参数，并且索引的起始是 <code>1</code>。当我们希望获取更多的参数的时候，我们会使用 <code>arguments[2]</code> 、<code>arguments[3]</code> 等等。</p>\n<p>我们可以跳过所有的参数命名设置，仅仅使用 <code>arguments</code> 对象：</p>\n<pre><code class=\"language-js\">function checkParams() {\n    console.log(arguments[1], arguments[0], arguments[2]);\n}\ncheckParams(2, 4, 6);  // 4 2 6\n</code></pre>\n<p>实际上，命名的参数是一种方便，但不是必需的。同样的，rest 参数也可以用来显示传入的参数：</p>\n<pre><code class=\"language-js\">function checkParams(...params) {\n    console.log(params[1], params[0], params[2]);    // 4 2 6\n    console.log(arguments[1], arguments[0], arguments[2]);    // 4 2 6\n}\ncheckParams(2, 4, 6);\n</code></pre>\n<p><code>arguments</code> 对象是一个类数组对象，但是缺少像 <code>slice</code> 和 <code>foreach</code> 等方法。为了在 <code>arguments</code> 对象上使用这些方法，需要将其转换为真实的数组：</p>\n<pre><code class=\"language-js\">function sort() {\n    var a = Array.prototype.slice.call(arguments);\n    return a.sort();\n}\nsort(40, 20, 50, 30);    // [20, 30, 40, 50]\n</code></pre>\n<p>在这个函数中，使用 <code>Array.prototype.slice.call()</code> 快速将 <code>arguments</code> 对象转换为数组。然后使用 <code>sort</code> 方法进行排序。</p>\n<p>ES6 有一种更直接的方法，<code>Array.from()</code>，ES6 新增的方法，用来通过类数组对象创建一个新的数组。</p>\n<pre><code class=\"language-js\">function sort() {\n    var a = Array.from(arguments);\n    return a.sort();\n}\nsort(40, 20, 50, 30);    // [20, 30, 40, 50]\n</code></pre>\n<h2 id=\"length-属性\">length 属性</h2>\n<p>虽然 arguments 对象并不是严格意义的数组，但它有一个 <code>length</code> 属性，可以用来检查传递给函数的参数的个数。</p>\n<pre><code class=\"language-js\">function countArguments() {\n    console.log(arguments.length);\n}\ncountArguments();    // 0\ncountArguments(10, null, &quot;string&quot;);    // 3\n</code></pre>\n<p>通过使用 <code>length</code> 属性，我们可以更好的控制参数的数量。比如说，如果一个函数需要两个参数，我们就可以使用 <code>length</code> 属性来检查参数数量，如果少于期望数量就抛出错误。</p>\n<pre><code class=\"language-js\">function foo(param1, param2) {\n    if (arguments.length &lt; 2) {\n        throw new Error(&quot;This function expects at least two arguments&quot;);\n    } else if (arguments.length === 2) {\n        // do something\n    }\n}\n</code></pre>\n<p>rest 参数是数组，所以他也有 <code>length</code> 属性，我们用 ES6 来重写上面的方法：</p>\n<pre><code class=\"language-js\">function foo(...params) {\n  if (params.length &lt; 2) {\n        throw new Error(&quot;This function expects at least two arguments&quot;);\n    } else if (params.length === 2) {\n        // do something\n    }\n}\n</code></pre>\n<h2 id=\"callee-和-caller-属性\">Callee 和 Caller 属性</h2>\n<p><code>callee</code> 属性指向当前正在运行的函数，而 <code>caller</code> 指向调用当前正在运行函数的函数。在 ES5 严格模式下，这些属性是被废弃掉的，如果要访问它们会抛出错误。</p>\n<p><code>arguments.callee</code> 属性在递归函数（递归函数是一个普通函数，通过它的签名指向自身）下很有用，尤其是函数的签名不可用时（也就是匿名函数）。因为匿名函数没有名字，唯一指向自身的方法就是通过 <code>arguments.callee</code>。</p>\n<pre><code class=\"language-js\">var result = (function(n) {\n  if (n &lt;= 1) {\n    return 1;\n  } else {\n    return n * arguments.callee(n - 1);\n  }\n})(4);   // 24\n</code></pre>\n<h2 id=\"严格模式和非严格模式下的-arguments\">严格模式和非严格模式下的 arguments</h2>\n<p>在 ES5 非严格模式下， <code>arguments</code> 对象有一个不常用的特性：它保持和命名参数值同步。</p>\n<pre><code class=\"language-js\">function foo(param) {\n   console.log(param === arguments[0]);    // true\n   arguments[0] = 500;\n   console.log(param === arguments[0]);    // true\n   return param\n}\nfoo(200);    // 500\n</code></pre>\n<p>在函数内部，一个新的值赋给 <code>arguments[0]</code>。因为 <code>arguments</code> 一直和命名参数的值保持同步，<code>arguments[0]</code> 的改变也会引起 <code>param</code> 的改变。事实上，他们是同个变量的不同名称。在 ES5 严格模式下，这种令人迷惑的特性被移除了：</p>\n<pre><code class=\"language-js\">&quot;use strict&quot;;\nfunction foo(param) {\n   console.log(param === arguments[0]);    // true\n   arguments[0] = 500;\n   console.log(param === arguments[0]);    // false\n   return param\n}\nfoo(200);   // 200\n</code></pre>\n<p>这次，<code>arguments[0]</code> 的改变没有影响到 <code>param</code>，并且输出和期望一样。ES6下，输出结果和 ES5 的严格模式是一致的。但是请记住，在函数声明时使用了默认参数，<code>arguments</code> 不受影响。</p>\n<pre><code class=\"language-js\">function foo(param1, param2 = 10, param3 = 20) {\n   console.log(param1 === arguments[0]);    // true\n   console.log(param2 === arguments[1]);    // true\n   console.log(param3 === arguments[2]);    // false\n   console.log(arguments[2]);    // undefined\n   console.log(param3);    // 20\n}\nfoo('string1', 'string2');\n</code></pre>\n<p>在这个函数中，尽管 <code>param3</code> 有默认值，但他和 <code>arguments[2]</code> 并不相等，因为只有两个参数传入了函数。也就是说，设置默认参数并不影响 arguments 对象。</p>\n<h2 id=\"结论\">结论</h2>\n<p>ES6 给 JavaScript 带来了许多大大小小的改进。越来越多的开发者开始使用 ES6，而且很多所有的特性都可以无障碍使用。本文我们学习了 ES6 是如何提升JavaScript 处理参数的能力的。但我们仅仅学了 ES6 的一点皮毛。更多的有趣的特性等着我们去挖掘！</p>\n<ul>\n<li><a href=\"https://kangax.github.io/compat-table/es6/\" target=\"_blank\" rel=\"noopener\">ECMAScript 6 Compatibility Table</a>, Juriy Zaytsev</li>\n<li>“<a href=\"http://www.ecma-international.org/ecma-262/6.0/\" target=\"_blank\" rel=\"noopener\">ECMAScript 2015 Language Specification</a>,” ECMA International</li>\n</ul>\n<hr>\n<p>看下时间现在正好是23：23，几乎用了一个下午和晚上把这篇文章读完又翻译完，这篇文章结合 ES5 和 ES6 来讲解，收益颇多。不过翻译水平有限，求多提意见多多指教 ~</p>\n<p>原文地址： <a href=\"https://www.smashingmagazine.com/2016/07/how-to-use-arguments-and-parameters-in-ecmascript-6/\" target=\"_blank\" rel=\"noopener\">How To Use Arguments And Parameters In ECMAScript 6</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>ECMAScript 6（或者叫 ECMAScript 2015）是 ECMAScript 的最新标准，极大的提高了 JavaScript 中处理参数的能力。现在我们可以使用 rest 参数（rest parameters）、默认值（default values）和解构（destructuring）以及其他许多新的特性。本文我们将探索参数(arguments)和参数(parameter)的方方面面，看一下ES6是如何对他们改进和提升的。</p>\n<h2 id=\"arguments-和-parameters\">Arguments 和 Parameters</h2>\n<p>arguments 和 Parameters 的含义通常是可以互换的。尽管如此，为了本文的目标，还是要做出区分。在大多数的标准中，函数声明时给出的叫做 parameters（或者叫 formal parameters），而传递给函数的叫做的 arguments（或者叫 actual arguments），看下面的函数：</p>\n<pre><code class=\"language-js\">function foo(param1, param2) {\n    // do something\n}\nfoo(10, 20);\n</code></pre>\n<p>在这个函数中，<code>param1</code> 和 <code>param2</code> 是函数的 parameters，而传递给函数的值（<code>10</code> 和 <code>20</code>）是 arguments。</p>\n<p><strong>译者注：本文后面不再区分 arguments 和 parameters，统一译作参数。😂</strong></p>\n<h2 id=\"扩展运算符\">扩展运算符（…)</h2>\n<p>在 ES5 中，<code>apply()</code> 方法可以很方便将数组作为参数传递给函数，经常用于使用 <code>Math.max()</code> 来取得数组的最大值。看下面的代码段：</p>\n<pre><code class=\"language-js\">var myArray = [5, 10, 50];\nMath.max(myArray);    // Error: NaN\nMath.max.apply(Math, myArray);    // 50\n</code></pre>\n<p><code>Math.max()</code> 方法不支持数组，只接受数字作为参数。当数组传递给函数，函数会抛出错误。但是当使用 <code>apply()</code> 方法后，数组变成了一个个单独的数组传递给了函数，所以 <code>Math.max()</code> 就能够正确的执行了。</p>\n<p>幸运的是，ES6 给我们带来了扩展运算符，我们就不必再继续使用 <code>apply()</code> 方法了。我们可以将表达式轻松的展开为多个参数。</p>\n<pre><code class=\"language-js\">var myArray = [5, 10, 50];\nMath.max(...myArray);    // 50\n</code></pre>\n<p>在这里我们通过扩展运算符将 <code>myArray</code> 展开成了一个个单独的值。虽然 ES5 中我们可以通过 <code>apply()</code> 方法来模拟扩展运算符，但是语法上让人迷惑，并且缺少可扩展性。扩展运算符不仅易于使用，还带来了许多新的特性。比如，你可以在函数调用时多次使用扩展运算符，并且还可以和其他参数混合在一起。</p>\n<pre><code class=\"language-js\">function myFunction() {\n  for(var i in arguments){\n    console.log(arguments[i]);\n  }\n}\nvar params = [10, 15];\nmyFunction(5, ...params, 20, ...[25]);    // 5 10 15 20 25\n</code></pre>\n<p>扩展运算符另一大好处就是他可以很容易的和构造函数（constructor）一起使用：</p>\n<pre><code class=\"language-js\">new Date(...[2016, 5, 6]);    // Mon Jun 06 2016 00:00:00 GMT-0700 (Pacific Daylight Time)\n</code></pre>\n<p>当前我们可以使用 ES5 来重写上面的代码，不过我们需要一个复杂的方法来避免一个类型错误：</p>\n<pre><code class=\"language-js\">new Date.apply(null, [2016, 4, 24]);    // TypeError: Date.apply is not a constructor\nnew (Function.prototype.bind.apply(Date, [null].concat([2016, 5, 6])));   // Mon Jun 06 2016 00:00:00 GMT-0700 (Pacific Daylight Time)\n</code></pre>\n<h2 id=\"rest-参数\">REST 参数</h2>\n<p>rest 参数和扩展运算符是一样的语法，但是他不是将数组展开成一个个的参数，而是将一个个参数转换为数组。</p>\n<p><strong>译者注：rest 参数和扩展运算符虽然一样的语法，在这里你就可以看出作者强调的 arguments 和 parameters 的区别了。扩展运算符用于函数调用的参数（arguments）中，而 rest 参数用于函数声明的参数（parameters）中。</strong></p>\n<pre><code class=\"language-js\">function myFunction(...options) {\n     return options;\n}\nmyFunction('a', 'b', 'c');      // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]\n</code></pre>\n<p>如果没有提供参数，rest 参数会被设置为空数组：</p>\n<pre><code>function myFunction(...options) {\n     return options;\n}\nmyFunction();      // []\n</code></pre>\n<p>当创建可见函数（接受数量可变的参数的函数）的时候，rest 参数就显得十分有用。因为 rest 参数是一个数组，所以可以很方便的替换 <code>arguments</code> 对象（将会在下文讨论）。看下面一个使用 ES5 编写的方法：</p>\n<pre><code class=\"language-js\">function checkSubstrings(string) {\n  for (var i = 1; i &lt; arguments.length; i++) {\n    if (string.indexOf(arguments[i]) === -1) {\n      return false;\n    }\n  }\n  return true;\n}\ncheckSubstrings('this is a string', 'is', 'this');   // true\n</code></pre>\n<p>这个函数的作用是检查一个字符串是否包含指定的一系列字符串。这个函数的第一个问题就是，我们必须查看函数体才知道函数接受多个参数。另外 <code>arguments</code> 的迭代必须从 1 开始，因为 <code>arguments[0]</code> 是第一个参数。如果我们稍后给第一参数之后再添加参数，或许我们就忘记更新这个循环了。使用 rest 参数，我们可以很轻易的避开这个问题：</p>\n<pre><code class=\"language-js\">function checkSubstrings(string, ...keys) {\n  for (var key of keys) {\n    if (string.indexOf(key) === -1) {\n      return false;\n    }\n  }\n  return true;\n}\ncheckSubstrings('this is a string', 'is', 'this');   // true\n</code></pre>\n<p>函数的输出和上一个函数一样。再重复一次，<code>string</code> 参数作为第一个参数传入，剩下的参数被塞进一个数组并且赋值给了变量 <code>keys</code>。</p>\n<p>使用 rest 参数代替 <code>arguments</code> 不仅提高了代码的可读性，并且避免了 JavaScript 中的<a href=\"https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments\" target=\"_blank\" rel=\"noopener\">性能问题</a>。尽管如此，rest 参数并不能无限制使用，举个例子，它只能是最后一个参数，否则会导致语法错误。</p>\n<pre><code class=\"language-js\">function logArguments(a, ...params, b) {\n        console.log(a, params, b);\n}\nlogArguments(5, 10, 15);    // SyntaxError: parameter after rest parameter\n</code></pre>\n<p>另一个限制方法声明时只允许一个 rest 参数：</p>\n<pre><code class=\"language-js\">function logArguments(...param1, ...param2) {\n}\nlogArguments(5, 10, 15);    // SyntaxError: parameter after rest parameter\n</code></pre>\n<h2 id=\"默认值\">默认值</h2>\n<h3 id=\"es5-中的默认参数\">ES5 中的默认参数</h3>\n<p>ES5 中 JavaScript 并不支持默认值，但这里有个很简单的实现，使用 <code>OR</code><br>\n运算符（<code>||</code>），我们可以很容易的模拟默认参数，看下面的代码：</p>\n<pre><code class=\"language-js\">function foo(param1, param2) {\n   param1 = param1 || 10;\n   param2 = param2 || 10;\n   console.log(param1, param2);\n}\nfoo(5, 5);  // 5 5\nfoo(5);    // 5 10\nfoo();    // 10 10\n</code></pre>\n<p>这个函数期望接收两个参数，但当无参数调用时，它会使用默认值。在函数内，缺失的参数自动设置为 undefined，所以我们检查这些参数，并给他们设置默认值。为了检测缺失的参数并设置默认值，我们使用 <code>OR</code> 运算符（<code>||</code>）。这个运算符首先检查第一个值，如果是 <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Truthy\" target=\"_blank\" rel=\"noopener\">truthy</a>，运算符会返回它，否则返回第二个参数。</p>\n<p>这种方法在函数内很常用，但也存在瑕疵。如果传递 <code>0</code> 或者 <code>null</code> 也会返回默认值。因为它们被认为是 falsy 值。所以如果我们确实需要给函数传递 <code>0</code> 或者 <code>null</code>，我们需要换种方法来检测参数是否缺失：</p>\n<pre><code class=\"language-js\">function foo(param1, param2) {\n  if(param1 === undefined){\n    param1 = 10;\n  }\n  if(param2 === undefined){\n    param2 = 10;\n  }\n  console.log(param1, param2);\n}\nfoo(0, null);    // 0, null\nfoo();    // 10, 10\n</code></pre>\n<p>在这个函数中，通过检查参数的类型是否为 undefined 来确定是否要赋予默认值。这种方法代码量稍微大一些，但更安全，可以让我们给函数传递 <code>0</code> 或者 <code>null</code>。</p>\n<h3 id=\"es6-中的默认参数\">ES6 中的默认参数</h3>\n<p>ES6 中，我们不必再检查参数是否为 undefined 来模拟默认参数，我们可以直接将默认参数函数声明中。</p>\n<pre><code class=\"language-js\">function foo(a = 10, b = 10) {\n  console.log(a, b);\n}\nfoo(5);    // 5 10\nfoo(0, null);    // 0 null\n</code></pre>\n<p>正如你所看到的，忽略参数返回了默认值，但传递 <code>0</code> 或者 <code>null</code> 并没有。我们甚至可以使用函数来产生参数的默认值：</p>\n<pre><code class=\"language-js\">function getParam() {\n    alert(&quot;getParam was called&quot;);\n    return 3;\n}\nfunction multiply(param1, param2 = getParam()) {\n    return param1 * param2;\n}\nmultiply(2, 5);     // 10\nmultiply(2);     // 6 (also displays an alert dialog)\n</code></pre>\n<p>需要注意的是，只有缺少第二个参数的时候，<code>gegParam</code> 方法才会执行，所以当我们使用两个参数 <code>multiply()</code> 的时候并不会弹出 alert。</p>\n<p>默认参数另一个有意思的特性是在方法声明是可以引用其他参数和变量作为默认参数：</p>\n<pre><code class=\"language-js\">function myFunction(a=10, b=a) {\n     console.log('a = ' + a + '; b = '  + b);\n}\nmyFunction();     // a=10; b=10\nmyFunction(22);    // a=22; b=22\nmyFunction(2, 4);    // a=2; b=4\n</code></pre>\n<p>甚至可以在函数声明的时候执行操作符：</p>\n<pre><code class=\"language-js\">function myFunction(a, b = ++a, c = a*b) {\n     console.log(c);\n}\nmyFunction(5);    // 36\n</code></pre>\n<p>注意：不像其他语言，JavaScript 是在调用时才计算默认参数的：</p>\n<pre><code class=\"language-js\">function add(value, array = []) {\n  array.push(value);\n  return array;\n}\nadd(5);    // [5]\nadd(6);    // [6], not [5, 6]\n</code></pre>\n<h2 id=\"解构赋值\">解构赋值</h2>\n<p>解构赋值是 ES6 的新特性，让我们可以从数组或者对象中提取值并赋值给变量，语法上类似于对象和数组字面量。当给函数传参时，这种语法清晰且易于理解并且很实用。</p>\n<p>在 ES5 中，经常使用配置对象来处理大量的的可选参数，尤其是属性的顺序无关紧要的时候，看下面的函数：</p>\n<pre><code class=\"language-js\">function initiateTransfer(options) {\n    var  protocol = options.protocol,\n        port = options.port,\n        delay = options.delay,\n        retries = options.retries,\n        timeout = options.timeout,\n        log = options.log;\n    // code to initiate transfer\n}\noptions = {\n  protocol: 'http',\n  port: 800,\n  delay: 150,\n  retries: 10,\n  timeout: 500,\n  log: true\n};\ninitiateTransfer(options);\n</code></pre>\n<p>这种模式 JavaScript 开发者经常使用，并且很好用。但我们必须进入函数体内才知道到底需要多少参数，使用解构参数赋值，我们可以在函数声明时很清晰的指定需要的参数。</p>\n<pre><code class=\"language-js\">function initiateTransfer({protocol, port, delay, retries, timeout, log}) {\n     // code to initiate transfer\n};\nvar options = {\n  protocol: 'http',\n  port: 800,\n  delay: 150,\n  retries: 10,\n  timeout: 500,\n  log: true\n}\ninitiateTransfer(options);\n</code></pre>\n<p>在这个函数中，我们使用了对象解构模式，而不是一个配置型对象，让我们的代码更加清晰易读。</p>\n<p>我们也可以混用解构参数和普通参数：</p>\n<pre><code class=\"language-js\">function initiateTransfer(param1, {protocol, port, delay, retries, timeout, log}) {\n     // code to initiate transfer\n}\ninitiateTransfer('some value', options);\n</code></pre>\n<p>需要注意，如果函数调用时解构参数缺失会抛出一个类型错误：</p>\n<pre><code class=\"language-js\">function initiateTransfer({protocol, port, delay, retries, timeout, log}) {\n     // code to initiate transfer\n}\ninitiateTransfer();  // TypeError: Cannot match against 'undefined' or 'null'\n</code></pre>\n<p>当我们的参数是必须的，这种行为我们是想要的，但是如果我们期望参数可选呢？为阻止这种错误，我们需要给解构参数赋一个默认值：</p>\n<pre><code class=\"language-js\">function initiateTransfer({protocol, port, delay, retries, timeout, log} = {}) {\n     // code to initiate transfer\n}\ninitiateTransfer();    // no error\n</code></pre>\n<p>在这个函数中，我们给解构参数赋了一个空对象作为默认值。现在如果函数调用时没有赋予参数，不会抛出错误。</p>\n<p>我们也可以给解构参数每个属性都赋默认值：</p>\n<pre><code class=\"language-js\">function initiateTransfer({\n    protocol = 'http',\n    port = 800,\n    delay = 150,\n    retries = 10,\n    timeout = 500,\n    log = true\n}) {\n     // code to initiate transfer\n}\n</code></pre>\n<p>在这个例子中，每个属性都被赋予默认值，就无需在函数体内手动检查 undefined 的参数再赋予默认值。</p>\n<h2 id=\"参数传递\">参数传递</h2>\n<p>函数传参有两种方式：引用传递和值传递。如果是引用传递，修改参数会引起全局的变化，如果是值传递，只会引起函数内的变化。</p>\n<p>在一些语言中，像 Visual Basic 和 PowerShell，我们可以选择声明是值传递还是引用传递，但 JavaScript 不是这样。</p>\n<h3 id=\"值传递\">值传递</h3>\n<p>严格来说，JavaScript只能值传递。当我们通过值传递给函数传参，就在函数作用域内创建了这个值得副本。所以任何值得变化都只会反映在函数内部。看下面的例子：</p>\n<pre><code class=\"language-js\">var a = 5;\nfunction increment(a) {\n    a = ++a;\n    console.log(a);\n}\nincrement(a);   // 6\nconsole.log(a);    // 5\n</code></pre>\n<p>在这里，在函数内部修改修改参数并不会影响到原始值。所以在函数外打印这个变量，得到的结果始终是 <code>5</code>。</p>\n<h3 id=\"引用传递\">引用传递</h3>\n<p>在 JavaScript 中，所有的都是值传递，但是当我们传递一个变量指向一个对象（包括数组），这个“值”就指向了这个对象，改变了对象的某个属相也会引起其关联对象的改变。</p>\n<p>看这个函数：</p>\n<pre><code class=\"language-js\">function foo(param){\n    param.bar = 'new value';\n}\nobj = {\n    bar : 'value'\n}\nconsole.log(obj.bar);   // value\nfoo(obj);\nconsole.log(obj.bar);   // new value\n</code></pre>\n<p>正如你看到的，对象的属性在函数体内部被修改，但是却影响到了函数外部的对象。</p>\n<p>当我们传递一个非原始的值，像数组或者对象，程序会在内存中创建一个对象，指向原始地址。如果被修改，原始值也会随之修改。</p>\n<h2 id=\"类型检查和缺失或多余参数\">类型检查和缺失或多余参数</h2>\n<p>在强类型的语言中，我们必须在函数声明时声明参数的类型，但 JavaScript 中没有这种特性，在 JavaScript 中，并不关心传递给函数的参数的类型和个数。</p>\n<p>假设我们有一个函数，仅接受一个参数。当我们调用这个函数的使用，我们并不限制到底传递给函数多少个参数，甚至可以选择不传，都不会产生错误。</p>\n<p>参数的个数可以分为两种情况：</p>\n<ul>\n<li>\n<h4 id=\"参数缺失\">参数缺失</h4>\n缺失的变量赋值为 undefined</li>\n<li>\n<h4 id=\"参数过多\">参数过多</h4>\n多余的参数会被忽略，但可以从 arguments 变量中取到（下文即将讨论）。</li>\n</ul>\n<h2 id=\"强制参数\">强制参数</h2>\n<p>函数调用中如果函数缺失，它会被设置为 undefined。我们可以利用这一点，如果参数缺失就抛出错误：</p>\n<pre><code class=\"language-js\">function foo(mandatory, optional) {\n    if (mandatory === undefined) {\n        throw new Error('Missing parameter: mandatory');\n    }\n}\n</code></pre>\n<p>在 ES6 中，我们可以更近一步，使用默认参数来设置强制参数：</p>\n<pre><code class=\"language-js\">function throwError() {\n    throw new Error('Missing parameter');\n}\nfunction foo(param1 = throwError(), param2 = throwError()) {\n    // do something\n}\nfoo(10, 20);    // ok\nfoo(10);   // Error: missing parameter\n</code></pre>\n<h2 id=\"arguments-对象\">arguments 对象</h2>\n<p>在 ES4 的时候默认参数就被加入，来代替 <code>arguments</code> 对象，但 ES4 并没有实现。随着 ES6 的发布，JavaScript 现在官方支持了默认参数。但并没有取消支持 <code>arguments</code> 的计划。</p>\n<p><code>arguments</code> 对象是一个类数组的对象，可以在所有的函数中取到。<code>arguments</code> 通过数字索引来获取传入的参数，而不是通过参数的名字。这个对象允许我们给函数传入任意多的参数。看下面的代码判断：</p>\n<pre><code class=\"language-js\">function checkParams(param1) {\n    console.log(param1);    // 2\n    console.log(arguments[0], arguments[1]);    // 2 3\n    console.log(param1 + arguments[0]);    // 4\n}\ncheckParams(2, 3);\n</code></pre>\n<p>这个函数期望传入一个参数，当我们传入两个参数调用它的时候，我们通过 <code>param1</code> 或者 <code>arguments[0]</code> 来获取第一个参数，但第二个参数只能通过 <code>arguments[1]</code> 获取。也即是说，<code>arguments</code> 对象可以和有命名的参数一起使用。</p>\n<p><code>arguments</code> 对象包含了所有传入函数的参数，并且索引的起始是 <code>1</code>。当我们希望获取更多的参数的时候，我们会使用 <code>arguments[2]</code> 、<code>arguments[3]</code> 等等。</p>\n<p>我们可以跳过所有的参数命名设置，仅仅使用 <code>arguments</code> 对象：</p>\n<pre><code class=\"language-js\">function checkParams() {\n    console.log(arguments[1], arguments[0], arguments[2]);\n}\ncheckParams(2, 4, 6);  // 4 2 6\n</code></pre>\n<p>实际上，命名的参数是一种方便，但不是必需的。同样的，rest 参数也可以用来显示传入的参数：</p>\n<pre><code class=\"language-js\">function checkParams(...params) {\n    console.log(params[1], params[0], params[2]);    // 4 2 6\n    console.log(arguments[1], arguments[0], arguments[2]);    // 4 2 6\n}\ncheckParams(2, 4, 6);\n</code></pre>\n<p><code>arguments</code> 对象是一个类数组对象，但是缺少像 <code>slice</code> 和 <code>foreach</code> 等方法。为了在 <code>arguments</code> 对象上使用这些方法，需要将其转换为真实的数组：</p>\n<pre><code class=\"language-js\">function sort() {\n    var a = Array.prototype.slice.call(arguments);\n    return a.sort();\n}\nsort(40, 20, 50, 30);    // [20, 30, 40, 50]\n</code></pre>\n<p>在这个函数中，使用 <code>Array.prototype.slice.call()</code> 快速将 <code>arguments</code> 对象转换为数组。然后使用 <code>sort</code> 方法进行排序。</p>\n<p>ES6 有一种更直接的方法，<code>Array.from()</code>，ES6 新增的方法，用来通过类数组对象创建一个新的数组。</p>\n<pre><code class=\"language-js\">function sort() {\n    var a = Array.from(arguments);\n    return a.sort();\n}\nsort(40, 20, 50, 30);    // [20, 30, 40, 50]\n</code></pre>\n<h2 id=\"length-属性\">length 属性</h2>\n<p>虽然 arguments 对象并不是严格意义的数组，但它有一个 <code>length</code> 属性，可以用来检查传递给函数的参数的个数。</p>\n<pre><code class=\"language-js\">function countArguments() {\n    console.log(arguments.length);\n}\ncountArguments();    // 0\ncountArguments(10, null, &quot;string&quot;);    // 3\n</code></pre>\n<p>通过使用 <code>length</code> 属性，我们可以更好的控制参数的数量。比如说，如果一个函数需要两个参数，我们就可以使用 <code>length</code> 属性来检查参数数量，如果少于期望数量就抛出错误。</p>\n<pre><code class=\"language-js\">function foo(param1, param2) {\n    if (arguments.length &lt; 2) {\n        throw new Error(&quot;This function expects at least two arguments&quot;);\n    } else if (arguments.length === 2) {\n        // do something\n    }\n}\n</code></pre>\n<p>rest 参数是数组，所以他也有 <code>length</code> 属性，我们用 ES6 来重写上面的方法：</p>\n<pre><code class=\"language-js\">function foo(...params) {\n  if (params.length &lt; 2) {\n        throw new Error(&quot;This function expects at least two arguments&quot;);\n    } else if (params.length === 2) {\n        // do something\n    }\n}\n</code></pre>\n<h2 id=\"callee-和-caller-属性\">Callee 和 Caller 属性</h2>\n<p><code>callee</code> 属性指向当前正在运行的函数，而 <code>caller</code> 指向调用当前正在运行函数的函数。在 ES5 严格模式下，这些属性是被废弃掉的，如果要访问它们会抛出错误。</p>\n<p><code>arguments.callee</code> 属性在递归函数（递归函数是一个普通函数，通过它的签名指向自身）下很有用，尤其是函数的签名不可用时（也就是匿名函数）。因为匿名函数没有名字，唯一指向自身的方法就是通过 <code>arguments.callee</code>。</p>\n<pre><code class=\"language-js\">var result = (function(n) {\n  if (n &lt;= 1) {\n    return 1;\n  } else {\n    return n * arguments.callee(n - 1);\n  }\n})(4);   // 24\n</code></pre>\n<h2 id=\"严格模式和非严格模式下的-arguments\">严格模式和非严格模式下的 arguments</h2>\n<p>在 ES5 非严格模式下， <code>arguments</code> 对象有一个不常用的特性：它保持和命名参数值同步。</p>\n<pre><code class=\"language-js\">function foo(param) {\n   console.log(param === arguments[0]);    // true\n   arguments[0] = 500;\n   console.log(param === arguments[0]);    // true\n   return param\n}\nfoo(200);    // 500\n</code></pre>\n<p>在函数内部，一个新的值赋给 <code>arguments[0]</code>。因为 <code>arguments</code> 一直和命名参数的值保持同步，<code>arguments[0]</code> 的改变也会引起 <code>param</code> 的改变。事实上，他们是同个变量的不同名称。在 ES5 严格模式下，这种令人迷惑的特性被移除了：</p>\n<pre><code class=\"language-js\">&quot;use strict&quot;;\nfunction foo(param) {\n   console.log(param === arguments[0]);    // true\n   arguments[0] = 500;\n   console.log(param === arguments[0]);    // false\n   return param\n}\nfoo(200);   // 200\n</code></pre>\n<p>这次，<code>arguments[0]</code> 的改变没有影响到 <code>param</code>，并且输出和期望一样。ES6下，输出结果和 ES5 的严格模式是一致的。但是请记住，在函数声明时使用了默认参数，<code>arguments</code> 不受影响。</p>\n<pre><code class=\"language-js\">function foo(param1, param2 = 10, param3 = 20) {\n   console.log(param1 === arguments[0]);    // true\n   console.log(param2 === arguments[1]);    // true\n   console.log(param3 === arguments[2]);    // false\n   console.log(arguments[2]);    // undefined\n   console.log(param3);    // 20\n}\nfoo('string1', 'string2');\n</code></pre>\n<p>在这个函数中，尽管 <code>param3</code> 有默认值，但他和 <code>arguments[2]</code> 并不相等，因为只有两个参数传入了函数。也就是说，设置默认参数并不影响 arguments 对象。</p>\n<h2 id=\"结论\">结论</h2>\n<p>ES6 给 JavaScript 带来了许多大大小小的改进。越来越多的开发者开始使用 ES6，而且很多所有的特性都可以无障碍使用。本文我们学习了 ES6 是如何提升JavaScript 处理参数的能力的。但我们仅仅学了 ES6 的一点皮毛。更多的有趣的特性等着我们去挖掘！</p>\n<ul>\n<li><a href=\"https://kangax.github.io/compat-table/es6/\" target=\"_blank\" rel=\"noopener\">ECMAScript 6 Compatibility Table</a>, Juriy Zaytsev</li>\n<li>“<a href=\"http://www.ecma-international.org/ecma-262/6.0/\" target=\"_blank\" rel=\"noopener\">ECMAScript 2015 Language Specification</a>,” ECMA International</li>\n</ul>\n<hr>\n<p>看下时间现在正好是23：23，几乎用了一个下午和晚上把这篇文章读完又翻译完，这篇文章结合 ES5 和 ES6 来讲解，收益颇多。不过翻译水平有限，求多提意见多多指教 ~</p>\n<p>原文地址： <a href=\"https://www.smashingmagazine.com/2016/07/how-to-use-arguments-and-parameters-in-ecmascript-6/\" target=\"_blank\" rel=\"noopener\">How To Use Arguments And Parameters In ECMAScript 6</a></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjr1en2mm0000ha9scx1jho3m","tag_id":"cjr1en2mr0002ha9snpqvqrfo","_id":"cjr1en2mw0007ha9sbwipxkx0"},{"post_id":"cjr1en2mp0001ha9slznarwsi","tag_id":"cjr1en2mw0006ha9surumie3l","_id":"cjr1en2n0000cha9smn6pihek"},{"post_id":"cjr1en2mz000bha9sy4wo8mhk","tag_id":"cjr1en2mr0002ha9snpqvqrfo","_id":"cjr1en2n2000fha9sdy1u9v88"},{"post_id":"cjr1en2mt0003ha9s0nwyxuy5","tag_id":"cjr1en2my000aha9sg7x7j594","_id":"cjr1en2n3000gha9s5q0clm7p"},{"post_id":"cjr1en2mu0004ha9sx4efxnc8","tag_id":"cjr1en2n2000eha9s0uiuqhl7","_id":"cjr1en2n6000jha9sevue318x"},{"post_id":"cjr1en2mu0004ha9sx4efxnc8","tag_id":"cjr1en2n4000hha9sw73zibxi","_id":"cjr1en2n6000kha9ss4nsaws1"},{"post_id":"cjr1en2mv0005ha9sxd871iqj","tag_id":"cjr1en2n2000eha9s0uiuqhl7","_id":"cjr1en2n7000nha9speqadfas"},{"post_id":"cjr1en2mv0005ha9sxd871iqj","tag_id":"cjr1en2n4000hha9sw73zibxi","_id":"cjr1en2n7000oha9swfi50wvn"},{"post_id":"cjr1en2mw0008ha9syl1fqrl7","tag_id":"cjr1en2n7000mha9sq9ddqvbx","_id":"cjr1en2n7000qha9sw3yx8a09"},{"post_id":"cjr1en2my0009ha9sik46dgz4","tag_id":"cjr1en2n7000pha9sieh5icwg","_id":"cjr1en2n8000sha9sbyt3e8js"},{"post_id":"cjr1en2n1000dha9splcwmd2s","tag_id":"cjr1en2n7000rha9sjc6ng4ei","_id":"cjr1en2n8000tha9simjuhh8m"},{"post_id":"cjr1en2nz000yha9sffn1uoxd","tag_id":"cjr1en2n7000mha9sq9ddqvbx","_id":"cjr1en2o20010ha9sed7ivmtn"},{"post_id":"cjr1en2o1000zha9s0xhbq4zo","tag_id":"cjr1en2my000aha9sg7x7j594","_id":"cjr1en2o30013ha9ss9fwb4mo"},{"post_id":"cjr1en2ns000uha9s1t2c6xkv","tag_id":"cjr1en2ny000xha9saej33jqi","_id":"cjr1en2o40015ha9sygnuamnm"},{"post_id":"cjr1en2o20011ha9syz8kbkvn","tag_id":"cjr1en2my000aha9sg7x7j594","_id":"cjr1en2o60017ha9sj50tfc4l"},{"post_id":"cjr1en2o30014ha9swxe09me4","tag_id":"cjr1en2my000aha9sg7x7j594","_id":"cjr1en2o70019ha9shqylezmk"},{"post_id":"cjr1en2nx000wha9s6xrz69ox","tag_id":"cjr1en2o30012ha9sj3iywcgz","_id":"cjr1en2o8001bha9sgs9x888w"},{"post_id":"cjr1en2o50016ha9swrmfdfkg","tag_id":"cjr1en2my000aha9sg7x7j594","_id":"cjr1en2o9001dha9soc3sfnzw"},{"post_id":"cjr1en2o60018ha9ssffw25a8","tag_id":"cjr1en2my000aha9sg7x7j594","_id":"cjr1en2oa001fha9svlwk8qao"},{"post_id":"cjr1en2o7001aha9stb9516fl","tag_id":"cjr1en2my000aha9sg7x7j594","_id":"cjr1en2ob001iha9sa4h3hmct"},{"post_id":"cjr1en2o8001cha9sbm1uegtx","tag_id":"cjr1en2my000aha9sg7x7j594","_id":"cjr1en2oc001kha9sbumltsk7"},{"post_id":"cjr1en2o9001eha9s1meomhvm","tag_id":"cjr1en2ob001hha9s9tsmje02","_id":"cjr1en2oe001oha9s6twk0ar0"},{"post_id":"cjr1en2oa001gha9s7f61mufw","tag_id":"cjr1en2n2000eha9s0uiuqhl7","_id":"cjr1en2og001qha9sasw5a86k"},{"post_id":"cjr1en2oa001gha9s7f61mufw","tag_id":"cjr1en2oe001nha9saanvdu5c","_id":"cjr1en2og001rha9szmxad823"},{"post_id":"cjr1en2ob001jha9s6hajqwoq","tag_id":"cjr1en2of001pha9saxuaxjxa","_id":"cjr1en2oh001tha9sb1xkstcp"},{"post_id":"cjr1en2oc001lha9sem2bzbqx","tag_id":"cjr1en2og001sha9scx9jrgsr","_id":"cjr1en2oi001vha9s4l04hr8x"},{"post_id":"cjr1en2od001mha9sg0hzm7e3","tag_id":"cjr1en2n2000eha9s0uiuqhl7","_id":"cjr1en2oj001wha9s4cxadj5v"},{"post_id":"cjr1en2od001mha9sg0hzm7e3","tag_id":"cjr1en2oi001uha9suv80s0kq","_id":"cjr1en2oj001xha9sl9ftkjha"},{"post_id":"cjr1en2oo001yha9sxbvdgada","tag_id":"cjr1en2ny000xha9saej33jqi","_id":"cjr1en2op0020ha9szaiq67f5"},{"post_id":"cjr1en2oo001zha9s9wx21zu6","tag_id":"cjr1en2mw0006ha9surumie3l","_id":"cjr1en2oq0021ha9sky9um4cu"}],"Tag":[{"name":"javascript","_id":"cjr1en2mr0002ha9snpqvqrfo"},{"name":"ES6","_id":"cjr1en2mw0006ha9surumie3l"},{"name":"life","_id":"cjr1en2my000aha9sg7x7j594"},{"name":"JavaScript","_id":"cjr1en2n2000eha9s0uiuqhl7"},{"name":"XHR","_id":"cjr1en2n4000hha9sw73zibxi"},{"name":"nodejs","_id":"cjr1en2n7000mha9sq9ddqvbx"},{"name":"gulp","_id":"cjr1en2n7000pha9sieh5icwg"},{"name":"Git","_id":"cjr1en2n7000rha9sjc6ng4ei"},{"name":"webpack","_id":"cjr1en2ny000xha9saej33jqi"},{"name":"electron","_id":"cjr1en2o30012ha9sj3iywcgz"},{"name":"algorithm","_id":"cjr1en2ob001hha9s9tsmje02"},{"name":"xhr","_id":"cjr1en2oe001nha9saanvdu5c"},{"name":"editor","_id":"cjr1en2of001pha9saxuaxjxa"},{"name":"game","_id":"cjr1en2og001sha9scx9jrgsr"},{"name":"performance","_id":"cjr1en2oi001uha9suv80s0kq"}]}}